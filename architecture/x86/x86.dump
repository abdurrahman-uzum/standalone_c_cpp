gcc (Debian 10.2.1-6) 10.2.1 20210110
Using: -std=gnu99 -m32 -g3 -O0 -c

main32.o:     file format elf32-i386


Disassembly of section .text:

00000000 <literals>:

#include <time.h>

//-----------------------------------------------------------------------------

void literals( void ) {
       0:	55                      	push   ebp
       1:	89 e5                   	mov    ebp,esp
       3:	57                      	push   edi
       4:	56                      	push   esi
       5:	53                      	push   ebx
       6:	81 ec 44 01 00 00       	sub    esp,0x144
       c:	e8 fc ff ff ff          	call   d <literals+0xd>
      11:	05 01 00 00 00          	add    eax,0x1

   // size as multiples of char
   size_t size = 0;
      16:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0

   // GCC -std=c99 komut satırı parametresi ve #include<stdbool.h> gerekli
   _Bool result = false;
      1d:	c6 45 eb 00             	mov    BYTE PTR [ebp-0x15],0x0
   Decimal: 97
   Hex    : 0x61
   Binary : 0b01100001
   Octal  : 0141
   */
   char c = 0;
      21:	c6 45 ea 00             	mov    BYTE PTR [ebp-0x16],0x0

   c = 97;   // decimal (base 10) literal
      25:	c6 45 ea 61             	mov    BYTE PTR [ebp-0x16],0x61
   c = 0x61; // hexadecimal (base 16) literal
      29:	c6 45 ea 61             	mov    BYTE PTR [ebp-0x16],0x61
   c = 0141; // octal (base 8) literal
      2d:	c6 45 ea 61             	mov    BYTE PTR [ebp-0x16],0x61
   c = 'a';  // character literal
      31:	c6 45 ea 61             	mov    BYTE PTR [ebp-0x16],0x61

   // binary literal, gcc specific
   c = 0b01100001;
      35:	c6 45 ea 61             	mov    BYTE PTR [ebp-0x16],0x61

   // single char literals (ASCII)
   char c01 = 'a';
      39:	c6 45 e9 61             	mov    BYTE PTR [ebp-0x17],0x61
   char c02 = -67;
      3d:	c6 45 e8 bd             	mov    BYTE PTR [ebp-0x18],0xbd
   char c03 = '\0';
      41:	c6 45 e7 00             	mov    BYTE PTR [ebp-0x19],0x0
   char c04 = 0;
      45:	c6 45 e6 00             	mov    BYTE PTR [ebp-0x1a],0x0

   char c05 = ' ';
      49:	c6 45 e5 20             	mov    BYTE PTR [ebp-0x1b],0x20
   char c06 = '\\';
      4d:	c6 45 e4 5c             	mov    BYTE PTR [ebp-0x1c],0x5c
   //char c07 = ''';

   // non printable chars (escape sequence)
   char c08 = '"';
      51:	c6 45 e3 22             	mov    BYTE PTR [ebp-0x1d],0x22
   char c09 = '\a';
      55:	c6 45 e2 07             	mov    BYTE PTR [ebp-0x1e],0x7
   char c10 = '\b';
      59:	c6 45 e1 08             	mov    BYTE PTR [ebp-0x1f],0x8
   char c11 = '\f';
      5d:	c6 45 e0 0c             	mov    BYTE PTR [ebp-0x20],0xc
   char c12 = '\n';
      61:	c6 45 df 0a             	mov    BYTE PTR [ebp-0x21],0xa
   char c13 = '\r';
      65:	c6 45 de 0d             	mov    BYTE PTR [ebp-0x22],0xd
   char c14 = '\t';
      69:	c6 45 dd 09             	mov    BYTE PTR [ebp-0x23],0x9
   char c15 = '\v';
      6d:	c6 45 dc 0b             	mov    BYTE PTR [ebp-0x24],0xb

   char c16 = '\456'; // octal
      71:	c6 45 db 2e             	mov    BYTE PTR [ebp-0x25],0x2e
   char c17 = '\xAF'; // hex
      75:	c6 45 da af             	mov    BYTE PTR [ebp-0x26],0xaf

   //unsigned short     c18 = '\u20AC';
   //unsigned short int c19 = '\u20AC';
   //unsigned int       c20 = '\U40FFAA11';

   signed int si1 = -3;
      79:	c7 45 d4 fd ff ff ff    	mov    DWORD PTR [ebp-0x2c],0xfffffffd
   int        si2 = -3;
      80:	c7 45 d0 fd ff ff ff    	mov    DWORD PTR [ebp-0x30],0xfffffffd

   long int liA = 10L;
      87:	c7 45 cc 0a 00 00 00    	mov    DWORD PTR [ebp-0x34],0xa
   long     liB = 10L;
      8e:	c7 45 c8 0a 00 00 00    	mov    DWORD PTR [ebp-0x38],0xa

   long long int  lliA = 10LL;
      95:	c7 45 c0 0a 00 00 00    	mov    DWORD PTR [ebp-0x40],0xa
      9c:	c7 45 c4 00 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x0
   long long      lliB = 10LL;
      a3:	c7 45 b8 0a 00 00 00    	mov    DWORD PTR [ebp-0x48],0xa
      aa:	c7 45 bc 00 00 00 00    	mov    DWORD PTR [ebp-0x44],0x0

   unsigned long long int ulliA = 10ULL;
      b1:	c7 45 b0 0a 00 00 00    	mov    DWORD PTR [ebp-0x50],0xa
      b8:	c7 45 b4 00 00 00 00    	mov    DWORD PTR [ebp-0x4c],0x0
   unsigned long long     ulliB = 10ULL;
      bf:	c7 45 a8 0a 00 00 00    	mov    DWORD PTR [ebp-0x58],0xa
      c6:	c7 45 ac 00 00 00 00    	mov    DWORD PTR [ebp-0x54],0x0

   char text01[] = "hello";
      cd:	c7 85 02 ff ff ff 68 65 	mov    DWORD PTR [ebp-0xfe],0x6c6c6568
      d5:	6c 6c 
      d7:	66 c7 85 06 ff ff ff 6f 	mov    WORD PTR [ebp-0xfa],0x6f
      df:	00 
   //char text03[] = "C:\Windows\System32\drivers\";
   //char text04[] = "he said "hello"";
   //char text05[] = "he said "hello"";

   // UNICODE char literal
   wchar_t wc01 = L'ç';
      e0:	c7 45 a4 e7 00 00 00    	mov    DWORD PTR [ebp-0x5c],0xe7
   size = sizeof( wc01 );
      e7:	c7 45 ec 04 00 00 00    	mov    DWORD PTR [ebp-0x14],0x4

   // UNICODE string literal
   wchar_t text06[] = L"ĞÜŞİÖÇ ğüşiöç Iı";
      ee:	8d 95 bc fe ff ff       	lea    edx,[ebp-0x144]
      f4:	8d 98 00 00 00 00       	lea    ebx,[eax+0x0]
      fa:	b9 11 00 00 00          	mov    ecx,0x11
      ff:	89 d7                   	mov    edi,edx
     101:	89 de                   	mov    esi,ebx
     103:	f3 a5                   	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
   size = sizeof( text06 );
     105:	c7 45 ec 44 00 00 00    	mov    DWORD PTR [ebp-0x14],0x44

   // IEEE 754 single precision floating point number (4 Byte)
   float f01 = 0;
     10c:	d9 ee                   	fldz   
     10e:	d9 5d a0                	fstp   DWORD PTR [ebp-0x60]
   float f02 = .0;
     111:	d9 ee                   	fldz   
     113:	d9 5d 9c                	fstp   DWORD PTR [ebp-0x64]
   float f03 = .0F;
     116:	d9 ee                   	fldz   
     118:	d9 5d 98                	fstp   DWORD PTR [ebp-0x68]
   float f04 = 3.14F;
     11b:	d9 80 48 03 00 00       	fld    DWORD PTR [eax+0x348]
     121:	d9 5d 94                	fstp   DWORD PTR [ebp-0x6c]
   float f05 = FLT_EPSILON;
     124:	d9 80 4c 03 00 00       	fld    DWORD PTR [eax+0x34c]
     12a:	d9 5d 90                	fstp   DWORD PTR [ebp-0x70]

   float pi          = 3.14159;
     12d:	d9 80 50 03 00 00       	fld    DWORD PTR [eax+0x350]
     133:	d9 5d 8c                	fstp   DWORD PTR [ebp-0x74]
   float aMole       = 6.02E23;
     136:	d9 80 54 03 00 00       	fld    DWORD PTR [eax+0x354]
     13c:	d9 5d 88                	fstp   DWORD PTR [ebp-0x78]
   float anotherMole = 6.022e23;
     13f:	d9 80 58 03 00 00       	fld    DWORD PTR [eax+0x358]
     145:	d9 5d 84                	fstp   DWORD PTR [ebp-0x7c]

   float electronCharge = 1.60217657e-19;
     148:	d9 80 5c 03 00 00       	fld    DWORD PTR [eax+0x35c]
     14e:	d9 5d 80                	fstp   DWORD PTR [ebp-0x80]
   float protonMass     = 1.67262178e-27;
     151:	d9 80 60 03 00 00       	fld    DWORD PTR [eax+0x360]
     157:	d9 9d 7c ff ff ff       	fstp   DWORD PTR [ebp-0x84]

   // IEEE 754 double precision floating point number (8 Byte)
   double d01 = .0;
     15d:	d9 ee                   	fldz   
     15f:	dd 9d 70 ff ff ff       	fstp   QWORD PTR [ebp-0x90]
   double d02 = .456;
     165:	dd 80 68 03 00 00       	fld    QWORD PTR [eax+0x368]
     16b:	dd 9d 68 ff ff ff       	fstp   QWORD PTR [ebp-0x98]
   double d03 = DBL_EPSILON;
     171:	dd 80 70 03 00 00       	fld    QWORD PTR [eax+0x370]
     177:	dd 9d 60 ff ff ff       	fstp   QWORD PTR [ebp-0xa0]

   // intel specific extended 80bit (10 Byte)
   long double ldGR = 1.618L;
     17d:	db a8 80 03 00 00       	fld    TBYTE PTR [eax+0x380]
     183:	db bd 54 ff ff ff       	fstp   TBYTE PTR [ebp-0xac]
   long double ldPI = 3.14159265358979323846264338328L;
     189:	d9 eb                   	fldpi  
     18b:	db bd 48 ff ff ff       	fstp   TBYTE PTR [ebp-0xb8]
   long double ld01 = LDBL_EPSILON;
     191:	db a8 90 03 00 00       	fld    TBYTE PTR [eax+0x390]
     197:	db bd 3c ff ff ff       	fstp   TBYTE PTR [ebp-0xc4]
            13 hexadecimal digits       (P - decimal)
   (0x1) . (999999999999A)              P(-4)
   */
   // C99 specific IEEE 754 double precision floating point HEXADECIMAL (base 16) literal
   // 1.100110011001100110011001100110011001100110011001101 x 2^(-4).
   double d04 = 0x1.999999999999Ap-4;
     19d:	dd 80 a0 03 00 00       	fld    QWORD PTR [eax+0x3a0]
     1a3:	dd 9d 30 ff ff ff       	fstp   QWORD PTR [ebp-0xd0]

   double d05 = 0xF.999999999999aP-4;
     1a9:	dd 80 a8 03 00 00       	fld    QWORD PTR [eax+0x3a8]
     1af:	dd 9d 28 ff ff ff       	fstp   QWORD PTR [ebp-0xd8]
   double d06 = 0xF.FFFFFFFFFFFFFP-4;
     1b5:	d9 e8                   	fld1   
     1b7:	dd 9d 20 ff ff ff       	fstp   QWORD PTR [ebp-0xe0]
   double d07 = 0x1p-1;
     1bd:	dd 80 b0 03 00 00       	fld    QWORD PTR [eax+0x3b0]
     1c3:	dd 9d 18 ff ff ff       	fstp   QWORD PTR [ebp-0xe8]
   double d08 = 0x2p-1;
     1c9:	d9 e8                   	fld1   
     1cb:	dd 9d 10 ff ff ff       	fstp   QWORD PTR [ebp-0xf0]
   double d09 = 0x3p-1;
     1d1:	dd 80 b8 03 00 00       	fld    QWORD PTR [eax+0x3b8]
     1d7:	dd 9d 08 ff ff ff       	fstp   QWORD PTR [ebp-0xf8]

}//literals
     1dd:	90                      	nop
     1de:	81 c4 44 01 00 00       	add    esp,0x144
     1e4:	5b                      	pop    ebx
     1e5:	5e                      	pop    esi
     1e6:	5f                      	pop    edi
     1e7:	5d                      	pop    ebp
     1e8:	c3                      	ret    

000001e9 <integers>:

//-----------------------------------------------------------------------------

itX;     // implicitly typed int
itY = 0; // implicitly typed int
void integers( void ) {
     1e9:	55                      	push   ebp
     1ea:	89 e5                   	mov    ebp,esp
     1ec:	83 ec 70                	sub    esp,0x70
     1ef:	e8 fc ff ff ff          	call   1f0 <integers+0x7>
     1f4:	05 01 00 00 00          	add    eax,0x1
    
	// char's signedness is implementation specific
	char          c  = 0;
     1f9:	c6 45 ff 00             	mov    BYTE PTR [ebp-0x1],0x0
	signed char   sc = 0;
     1fd:	c6 45 fe 00             	mov    BYTE PTR [ebp-0x2],0x0
	unsigned char uc = 0;
     201:	c6 45 fd 00             	mov    BYTE PTR [ebp-0x3],0x0

	short          s  = 0;
     205:	66 c7 45 fa 00 00       	mov    WORD PTR [ebp-0x6],0x0
	signed short   ss = 0;
     20b:	66 c7 45 f8 00 00       	mov    WORD PTR [ebp-0x8],0x0
	unsigned short us = 0;
     211:	66 c7 45 f6 00 00       	mov    WORD PTR [ebp-0xa],0x0

	int          i  = 0;
     217:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
	signed int   si = 0;
     21e:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
	unsigned int ui = 0;
     225:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

	signed   sn = 0; // int
     22c:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
	unsigned un = 0; // int
     233:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [ebp-0x20],0x0

	long          l  = 0;
     23a:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
	signed long   sl = 1;
     241:	c7 45 d8 01 00 00 00    	mov    DWORD PTR [ebp-0x28],0x1
	unsigned long ul = 1;
     248:	c7 45 d4 01 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x1

	long long          ll  = 0;
     24f:	c7 45 c8 00 00 00 00    	mov    DWORD PTR [ebp-0x38],0x0
     256:	c7 45 cc 00 00 00 00    	mov    DWORD PTR [ebp-0x34],0x0
	signed long long  sll  = 1;
     25d:	c7 45 c0 01 00 00 00    	mov    DWORD PTR [ebp-0x40],0x1
     264:	c7 45 c4 00 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x0
	unsigned long long ull = 1;
     26b:	c7 45 b8 01 00 00 00    	mov    DWORD PTR [ebp-0x48],0x1
     272:	c7 45 bc 00 00 00 00    	mov    DWORD PTR [ebp-0x44],0x0

	// fixed length across platforms (  stdint.h or inttypes.h )
	int16_t  i16  = 0;
     279:	66 c7 45 b6 00 00       	mov    WORD PTR [ebp-0x4a],0x0
	uint16_t ui16 = 0;
     27f:	66 c7 45 b4 00 00       	mov    WORD PTR [ebp-0x4c],0x0

	int32_t  i32  = 0;
     285:	c7 45 b0 00 00 00 00    	mov    DWORD PTR [ebp-0x50],0x0
	uint32_t ui32 = 0;
     28c:	c7 45 ac 00 00 00 00    	mov    DWORD PTR [ebp-0x54],0x0

	size_t size = 0;
     293:	c7 45 a8 00 00 00 00    	mov    DWORD PTR [ebp-0x58],0x0

   // platform dependant and may vary platform to platform ( limits.h )
	int bitCount = CHAR_BIT;
     29a:	c7 45 a4 08 00 00 00    	mov    DWORD PTR [ebp-0x5c],0x8
	int value = CHAR_MIN;
     2a1:	c7 45 a0 80 ff ff ff    	mov    DWORD PTR [ebp-0x60],0xffffff80
	value     = CHAR_MAX;
     2a8:	c7 45 a0 7f 00 00 00    	mov    DWORD PTR [ebp-0x60],0x7f

	size = sizeof( char );
     2af:	c7 45 a8 01 00 00 00    	mov    DWORD PTR [ebp-0x58],0x1
    //size = sizeof int;  //syntax error
    size = sizeof value;  // ok
     2b6:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4

    size = sizeof( c );
     2bd:	c7 45 a8 01 00 00 00    	mov    DWORD PTR [ebp-0x58],0x1
    size = sizeof( 0 );
     2c4:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4
	size = sizeof( 0L );
     2cb:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4
    size = sizeof( 0LL );
     2d2:	c7 45 a8 08 00 00 00    	mov    DWORD PTR [ebp-0x58],0x8

	size = sizeof( int );
     2d9:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4
	size = sizeof( unsigned int );
     2e0:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4
	bitCount = CHAR_BIT * sizeof( unsigned int );
     2e7:	c7 45 a4 20 00 00 00    	mov    DWORD PTR [ebp-0x5c],0x20

	size = sizeof( i );
     2ee:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4
	size = sizeof( ui );
     2f5:	c7 45 a8 04 00 00 00    	mov    DWORD PTR [ebp-0x58],0x4

	ui = (unsigned) 0xFFFFFFFF;
     2fc:	c7 45 e8 ff ff ff ff    	mov    DWORD PTR [ebp-0x18],0xffffffff
	i  = (signed) ui;
     303:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     306:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    ui = 0xFFFFFFFF;
     309:	c7 45 e8 ff ff ff ff    	mov    DWORD PTR [ebp-0x18],0xffffffff

    // !
    // i = ui / ( i + 1 );

    int x = -1;
     310:	c7 45 9c ff ff ff ff    	mov    DWORD PTR [ebp-0x64],0xffffffff
    int y = 4294967295;
     317:	c7 45 98 ff ff ff ff    	mov    DWORD PTR [ebp-0x68],0xffffffff
    _Bool result = x == y;
     31e:	8b 45 9c                	mov    eax,DWORD PTR [ebp-0x64]
     321:	3b 45 98                	cmp    eax,DWORD PTR [ebp-0x68]
     324:	0f 94 c0                	sete   al
     327:	88 45 97                	mov    BYTE PTR [ebp-0x69],al
	
}//integers
     32a:	90                      	nop
     32b:	c9                      	leave  
     32c:	c3                      	ret    

0000032d <decimals_Float>:


// refer: www.stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number
// refer: www.en.wikipedia.org/wiki/Subnormal_number
// https://observablehq.com/@rreusser/half-precision-floating-point-visualized
void decimals_Float( void ) {
     32d:	55                      	push   ebp
     32e:	89 e5                   	mov    ebp,esp
     330:	53                      	push   ebx
     331:	83 ec 34                	sub    esp,0x34
     334:	e8 fc ff ff ff          	call   335 <decimals_Float+0x8>
     339:	81 c3 02 00 00 00       	add    ebx,0x2

   float fA = .0F;
     33f:	d9 ee                   	fldz   
     341:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]
   float fB = .0F;
     344:	d9 ee                   	fldz   
     346:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]

   unsigned int count = 0;
     349:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   int value = 0;
     350:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0
   size_t size = 0;
     357:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0

   // size in memory as bytes
   size = sizeof( float );
     35e:	c7 45 e4 04 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x4
   size = sizeof( fA );
     365:	c7 45 e4 04 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x4

   // bit count
   size = CHAR_BIT * sizeof( float );
     36c:	c7 45 e4 20 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x20

   // include float.h
   fA = FLT_MIN;
     373:	d9 83 c0 03 00 00       	fld    DWORD PTR [ebx+0x3c0]
     379:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]
   fA = FLT_MAX;
     37c:	d9 83 c4 03 00 00       	fld    DWORD PTR [ebx+0x3c4]
     382:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

   // mantissa, precision  0.000000
   count = FLT_DIG;
     385:	c7 45 ec 06 00 00 00    	mov    DWORD PTR [ebp-0x14],0x6

   // base 10 of the exponent part of a float.
   value = FLT_MIN_10_EXP;
     38c:	c7 45 e8 db ff ff ff    	mov    DWORD PTR [ebp-0x18],0xffffffdb
   value = FLT_MAX_10_EXP;
     393:	c7 45 e8 26 00 00 00    	mov    DWORD PTR [ebp-0x18],0x26

   float epsilon = FLT_EPSILON;
     39a:	d9 83 4c 03 00 00       	fld    DWORD PTR [ebx+0x34c]
     3a0:	d9 5d e0                	fstp   DWORD PTR [ebp-0x20]

   fA = .0F / .0F;
     3a3:	d9 ee                   	fldz   
     3a5:	d8 f0                   	fdiv   st,st(0)
     3a7:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

   fB = sqrtf( -1.00F ); // math.h
     3aa:	83 ec 0c                	sub    esp,0xc
     3ad:	d9 e8                   	fld1   
     3af:	d9 e0                   	fchs   
     3b1:	8d 64 24 fc             	lea    esp,[esp-0x4]
     3b5:	d9 1c 24                	fstp   DWORD PTR [esp]
     3b8:	e8 fc ff ff ff          	call   3b9 <decimals_Float+0x8c>
     3bd:	83 c4 10                	add    esp,0x10
     3c0:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]
   fB = 1.0F / .00F;
     3c3:	d9 e8                   	fld1   
     3c5:	d9 ee                   	fldz   
     3c7:	de f9                   	fdivp  st(1),st
     3c9:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]
   fB = INFINITY;
     3cc:	d9 83 c8 03 00 00       	fld    DWORD PTR [ebx+0x3c8]
     3d2:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]

   float posInf =  1.0F / 0.0F;
     3d5:	d9 e8                   	fld1   
     3d7:	d9 ee                   	fldz   
     3d9:	de f9                   	fdivp  st(1),st
     3db:	d9 5d dc                	fstp   DWORD PTR [ebp-0x24]
   float negInf = -1.0F / 0.0F;
     3de:	d9 e8                   	fld1   
     3e0:	d9 e0                   	fchs   
     3e2:	d9 ee                   	fldz   
     3e4:	de f9                   	fdivp  st(1),st
     3e6:	d9 5d d8                	fstp   DWORD PTR [ebp-0x28]

   _Bool result = true;
     3e9:	c6 45 d7 01             	mov    BYTE PTR [ebp-0x29],0x1

   fA = NAN;
     3ed:	d9 83 cc 03 00 00       	fld    DWORD PTR [ebx+0x3cc]
     3f3:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

   result = fA == NAN;
     3f6:	c6 45 d7 00             	mov    BYTE PTR [ebp-0x29],0x0
   result = fA == fA;
     3fa:	b8 01 00 00 00          	mov    eax,0x1
     3ff:	d9 45 f4                	fld    DWORD PTR [ebp-0xc]
     402:	d9 45 f4                	fld    DWORD PTR [ebp-0xc]
     405:	df e9                   	fucomip st,st(1)
     407:	dd d8                   	fstp   st(0)
     409:	7a 0c                   	jp     417 <decimals_Float+0xea>
     40b:	d9 45 f4                	fld    DWORD PTR [ebp-0xc]
     40e:	d9 45 f4                	fld    DWORD PTR [ebp-0xc]
     411:	df e9                   	fucomip st,st(1)
     413:	dd d8                   	fstp   st(0)
     415:	74 05                   	je     41c <decimals_Float+0xef>
     417:	b8 00 00 00 00          	mov    eax,0x0
     41c:	88 45 d7                	mov    BYTE PTR [ebp-0x29],al

   result = NAN == NAN;
     41f:	c6 45 d7 00             	mov    BYTE PTR [ebp-0x29],0x0
   result = NAN != NAN;
     423:	c6 45 d7 01             	mov    BYTE PTR [ebp-0x29],0x1

   // include math.h
   result = isnan( fA );
     427:	d9 45 f4                	fld    DWORD PTR [ebp-0xc]
     42a:	d9 45 f4                	fld    DWORD PTR [ebp-0xc]
     42d:	df e9                   	fucomip st,st(1)
     42f:	dd d8                   	fstp   st(0)
     431:	0f 9a c0                	setp   al
     434:	88 45 d7                	mov    BYTE PTR [ebp-0x29],al

}//decimals_Float
     437:	90                      	nop
     438:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
     43b:	c9                      	leave  
     43c:	c3                      	ret    

0000043d <decimals_Double>:

//-----------------------------------------------------------------------------

void decimals_Double( void ) {
     43d:	55                      	push   ebp
     43e:	89 e5                   	mov    ebp,esp
     440:	e8 fc ff ff ff          	call   441 <decimals_Double+0x4>
     445:	05 01 00 00 00          	add    eax,0x1

   // TODO : implement the same aspects of floats as in decimals_Float() for the "double" type   

}//decimals_Double
     44a:	90                      	nop
     44b:	5d                      	pop    ebp
     44c:	c3                      	ret    

0000044d <floatQuirks>:

//-----------------------------------------------------------------------------

void floatQuirks( void ) {
     44d:	55                      	push   ebp
     44e:	89 e5                   	mov    ebp,esp
     450:	83 ec 50                	sub    esp,0x50
     453:	e8 fc ff ff ff          	call   454 <floatQuirks+0x7>
     458:	05 01 00 00 00          	add    eax,0x1

	float x = 1.1;
     45d:	d9 80 d0 03 00 00       	fld    DWORD PTR [eax+0x3d0]
     463:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]
	_Bool result = x != 1.1;
     466:	d9 45 e4                	fld    DWORD PTR [ebp-0x1c]
     469:	dd 80 d8 03 00 00       	fld    QWORD PTR [eax+0x3d8]
     46f:	df e9                   	fucomip st,st(1)
     471:	0f 9a c2                	setp   dl
     474:	b9 01 00 00 00          	mov    ecx,0x1
     479:	dd 80 d8 03 00 00       	fld    QWORD PTR [eax+0x3d8]
     47f:	df e9                   	fucomip st,st(1)
     481:	dd d8                   	fstp   st(0)
     483:	0f 45 d1                	cmovne edx,ecx
     486:	88 55 e3                	mov    BYTE PTR [ebp-0x1d],dl

    result = (float)x != (double)1.1;
     489:	d9 45 e4                	fld    DWORD PTR [ebp-0x1c]
     48c:	dd 80 d8 03 00 00       	fld    QWORD PTR [eax+0x3d8]
     492:	df e9                   	fucomip st,st(1)
     494:	0f 9a c2                	setp   dl
     497:	b9 01 00 00 00          	mov    ecx,0x1
     49c:	dd 80 d8 03 00 00       	fld    QWORD PTR [eax+0x3d8]
     4a2:	df e9                   	fucomip st,st(1)
     4a4:	dd d8                   	fstp   st(0)
     4a6:	0f 45 d1                	cmovne edx,ecx
     4a9:	88 55 e3                	mov    BYTE PTR [ebp-0x1d],dl
    result = x != 1.1F;
     4ac:	d9 45 e4                	fld    DWORD PTR [ebp-0x1c]
     4af:	d9 80 d0 03 00 00       	fld    DWORD PTR [eax+0x3d0]
     4b5:	df e9                   	fucomip st,st(1)
     4b7:	dd d8                   	fstp   st(0)
     4b9:	0f 9a c2                	setp   dl
     4bc:	b9 01 00 00 00          	mov    ecx,0x1
     4c1:	d9 45 e4                	fld    DWORD PTR [ebp-0x1c]
     4c4:	d9 80 d0 03 00 00       	fld    DWORD PTR [eax+0x3d0]
     4ca:	df e9                   	fucomip st,st(1)
     4cc:	dd d8                   	fstp   st(0)
     4ce:	0f 45 d1                	cmovne edx,ecx
     4d1:	88 55 e3                	mov    BYTE PTR [ebp-0x1d],dl

   float f = 0.1F;
     4d4:	d9 80 e0 03 00 00       	fld    DWORD PTR [eax+0x3e0]
     4da:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]

   // runtime calculations of values
   f = 0.0F;
     4dd:	d9 ee                   	fldz   
     4df:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     4e2:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     4e5:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     4eb:	de c1                   	faddp  st(1),st
     4ed:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     4f0:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     4f3:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     4f9:	de c1                   	faddp  st(1),st
     4fb:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]

   f += 0.2F;
     4fe:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     501:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     507:	de c1                   	faddp  st(1),st
     509:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     50c:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     50f:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     515:	de c1                   	faddp  st(1),st
     517:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     51a:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     51d:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     523:	de c1                   	faddp  st(1),st
     525:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]

   f += 0.2F;
     528:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     52b:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     531:	de c1                   	faddp  st(1),st
     533:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     536:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     539:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     53f:	de c1                   	faddp  st(1),st
     541:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]

   f += 0.2F;
     544:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     547:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     54d:	de c1                   	faddp  st(1),st
     54f:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     552:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     555:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     55b:	de c1                   	faddp  st(1),st
     55d:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   f += 0.2F;
     560:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     563:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     569:	de c1                   	faddp  st(1),st
     56b:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]

   // compile time calculations of values
   float ft = 0.2F * 10;
     56e:	d9 80 e8 03 00 00       	fld    DWORD PTR [eax+0x3e8]
     574:	d9 5d dc                	fstp   DWORD PTR [ebp-0x24]
   float fs = 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F;
     577:	d9 80 ec 03 00 00       	fld    DWORD PTR [eax+0x3ec]
     57d:	d9 5d d8                	fstp   DWORD PTR [ebp-0x28]

   float fk = 0.5F;
     580:	d9 80 f0 03 00 00       	fld    DWORD PTR [eax+0x3f0]
     586:	d9 5d d4                	fstp   DWORD PTR [ebp-0x2c]
   fk = 2.5F;
     589:	d9 80 f4 03 00 00       	fld    DWORD PTR [eax+0x3f4]
     58f:	d9 5d d4                	fstp   DWORD PTR [ebp-0x2c]
   float fk1 = 0;
     592:	d9 ee                   	fldz   
     594:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]

   // runtime calculations of values
   fk1 += 2.6F;
     597:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     59a:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5a0:	de c1                   	faddp  st(1),st
     5a2:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     5a5:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5a8:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5ae:	de c1                   	faddp  st(1),st
     5b0:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     5b3:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5b6:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5bc:	de c1                   	faddp  st(1),st
     5be:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     5c1:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5c4:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5ca:	de c1                   	faddp  st(1),st
     5cc:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     5cf:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5d2:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5d8:	de c1                   	faddp  st(1),st
     5da:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]

   fk1 += 2.6F;
     5dd:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5e0:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5e6:	de c1                   	faddp  st(1),st
     5e8:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     5eb:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5ee:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     5f4:	de c1                   	faddp  st(1),st
     5f6:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     5f9:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     5fc:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     602:	de c1                   	faddp  st(1),st
     604:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     607:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     60a:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     610:	de c1                   	faddp  st(1),st
     612:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fk1 += 2.6F;
     615:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     618:	d9 80 f8 03 00 00       	fld    DWORD PTR [eax+0x3f8]
     61e:	de c1                   	faddp  st(1),st
     620:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]

   float fk2 = 2.6F * 10;
     623:	d9 80 fc 03 00 00       	fld    DWORD PTR [eax+0x3fc]
     629:	d9 5d cc                	fstp   DWORD PTR [ebp-0x34]

   result = fk1 == fk2;
     62c:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     62f:	d9 45 cc                	fld    DWORD PTR [ebp-0x34]
     632:	df e9                   	fucomip st,st(1)
     634:	dd d8                   	fstp   st(0)
     636:	0f 9b c2                	setnp  dl
     639:	b9 00 00 00 00          	mov    ecx,0x0
     63e:	d9 45 d0                	fld    DWORD PTR [ebp-0x30]
     641:	d9 45 cc                	fld    DWORD PTR [ebp-0x34]
     644:	df e9                   	fucomip st,st(1)
     646:	dd d8                   	fstp   st(0)
     648:	0f 45 d1                	cmovne edx,ecx
     64b:	88 55 e3                	mov    BYTE PTR [ebp-0x1d],dl

   int loop = 10;
     64e:	c7 45 f8 0a 00 00 00    	mov    DWORD PTR [ebp-0x8],0xa
   f = 0.0F;
     655:	d9 ee                   	fldz   
     657:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]

   double value = .02;
     65a:	dd 80 00 04 00 00       	fld    QWORD PTR [eax+0x400]
     660:	dd 5d c0                	fstp   QWORD PTR [ebp-0x40]
   double diff = value - value;
     663:	dd 45 c0                	fld    QWORD PTR [ebp-0x40]
     666:	d8 e0                   	fsub   st,st(0)
     668:	dd 5d b8                	fstp   QWORD PTR [ebp-0x48]
   result = diff == NAN;
     66b:	c6 45 e3 00             	mov    BYTE PTR [ebp-0x1d],0x0


   while ( loop-- ) {
     66f:	eb 0e                   	jmp    67f <floatQuirks+0x232>
      f += 0.1F;
     671:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     674:	d9 80 e0 03 00 00       	fld    DWORD PTR [eax+0x3e0]
     67a:	de c1                   	faddp  st(1),st
     67c:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   while ( loop-- ) {
     67f:	8b 55 f8                	mov    edx,DWORD PTR [ebp-0x8]
     682:	8d 4a ff                	lea    ecx,[edx-0x1]
     685:	89 4d f8                	mov    DWORD PTR [ebp-0x8],ecx
     688:	85 d2                   	test   edx,edx
     68a:	75 e5                   	jne    671 <floatQuirks+0x224>
   }


   f = 0.0F;
     68c:	d9 ee                   	fldz   
     68e:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   for ( int j = 0 ; j < 10; j++ ){
     691:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
     698:	eb 12                   	jmp    6ac <floatQuirks+0x25f>
      f += 0.1F;
     69a:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     69d:	d9 80 e0 03 00 00       	fld    DWORD PTR [eax+0x3e0]
     6a3:	de c1                   	faddp  st(1),st
     6a5:	d9 5d fc                	fstp   DWORD PTR [ebp-0x4]
   for ( int j = 0 ; j < 10; j++ ){
     6a8:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1
     6ac:	83 7d f4 09             	cmp    DWORD PTR [ebp-0xc],0x9
     6b0:	7e e8                   	jle    69a <floatQuirks+0x24d>
   }

   result = f == ( 10 * 0.1F );
     6b2:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     6b5:	d9 e8                   	fld1   
     6b7:	df e9                   	fucomip st,st(1)
     6b9:	dd d8                   	fstp   st(0)
     6bb:	0f 9b c2                	setnp  dl
     6be:	b9 00 00 00 00          	mov    ecx,0x0
     6c3:	d9 45 fc                	fld    DWORD PTR [ebp-0x4]
     6c6:	d9 e8                   	fld1   
     6c8:	df e9                   	fucomip st,st(1)
     6ca:	dd d8                   	fstp   st(0)
     6cc:	0f 45 d1                	cmovne edx,ecx
     6cf:	88 55 e3                	mov    BYTE PTR [ebp-0x1d],dl

   float secondFromStart = nextafterf( FLT_EPSILON, INFINITY );
     6d2:	d9 80 08 04 00 00       	fld    DWORD PTR [eax+0x408]
     6d8:	d9 5d b4                	fstp   DWORD PTR [ebp-0x4c]

   // round(256.49999) == 256;
   // roundf(256.49999) == 257;

   // for(ever) : http://www.youtube.com/watch?v=IJNR2EpS0jw
   for( double d = 0; d != 0.3; d += 0.1 );
     6db:	d9 ee                   	fldz   
     6dd:	dd 5d e8                	fstp   QWORD PTR [ebp-0x18]
     6e0:	eb 0e                   	jmp    6f0 <floatQuirks+0x2a3>
     6e2:	dd 45 e8                	fld    QWORD PTR [ebp-0x18]
     6e5:	dd 80 a0 03 00 00       	fld    QWORD PTR [eax+0x3a0]
     6eb:	de c1                   	faddp  st(1),st
     6ed:	dd 5d e8                	fstp   QWORD PTR [ebp-0x18]
     6f0:	dd 45 e8                	fld    QWORD PTR [ebp-0x18]
     6f3:	dd 80 10 04 00 00       	fld    QWORD PTR [eax+0x410]
     6f9:	df e9                   	fucomip st,st(1)
     6fb:	dd d8                   	fstp   st(0)
     6fd:	7a e3                   	jp     6e2 <floatQuirks+0x295>
     6ff:	dd 45 e8                	fld    QWORD PTR [ebp-0x18]
     702:	dd 80 10 04 00 00       	fld    QWORD PTR [eax+0x410]
     708:	df f1                   	fcomip st,st(1)
     70a:	dd d8                   	fstp   st(0)
     70c:	75 d4                   	jne    6e2 <floatQuirks+0x295>

}//floatQuirks
     70e:	90                      	nop
     70f:	90                      	nop
     710:	c9                      	leave  
     711:	c3                      	ret    

00000712 <operators_equality>:

//-----------------------------------------------------------------------------


void operators_equality(void){
     712:	55                      	push   ebp
     713:	89 e5                   	mov    ebp,esp
     715:	83 ec 10                	sub    esp,0x10
     718:	e8 fc ff ff ff          	call   719 <operators_equality+0x7>
     71d:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int a = 2;
     722:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
   int b = 3;
     729:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
   int c = 2;
     730:	c7 45 f4 02 00 00 00    	mov    DWORD PTR [ebp-0xc],0x2

   _Bool result = 0;
     737:	c6 45 f3 00             	mov    BYTE PTR [ebp-0xd],0x0

   // equality
   result = a == a;
     73b:	c6 45 f3 01             	mov    BYTE PTR [ebp-0xd],0x1

   result = a == b;
     73f:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     742:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     745:	0f 94 c0                	sete   al
     748:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

   result = a == c;
     74b:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     74e:	3b 45 f4                	cmp    eax,DWORD PTR [ebp-0xc]
     751:	0f 94 c0                	sete   al
     754:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

   result = c == b;
     757:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     75a:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     75d:	0f 94 c0                	sete   al
     760:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al


   // inequality
   result = a != a;
     763:	c6 45 f3 00             	mov    BYTE PTR [ebp-0xd],0x0

   result = a != b;
     767:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     76a:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     76d:	0f 95 c0                	setne  al
     770:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

   result = a != c;
     773:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     776:	3b 45 f4                	cmp    eax,DWORD PTR [ebp-0xc]
     779:	0f 95 c0                	setne  al
     77c:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

   result = c != b;
     77f:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     782:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     785:	0f 95 c0                	setne  al
     788:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

}//operators_equality
     78b:	90                      	nop
     78c:	c9                      	leave  
     78d:	c3                      	ret    

0000078e <operators_relational>:

//-----------------------------------------------------------------------------

void operators_relational( void ) {
     78e:	55                      	push   ebp
     78f:	89 e5                   	mov    ebp,esp
     791:	83 ec 10                	sub    esp,0x10
     794:	e8 fc ff ff ff          	call   795 <operators_relational+0x7>
     799:	05 01 00 00 00          	add    eax,0x1

  // see disassembly
  int a = 2;
     79e:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
  int b = 3;
     7a5:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
  int c = 0;
     7ac:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

  _Bool result = 0;
     7b3:	c6 45 f3 00             	mov    BYTE PTR [ebp-0xd],0x0

  result = a > b;
     7b7:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     7ba:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     7bd:	0f 9f c0                	setg   al
     7c0:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  result = a >= b;
     7c3:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     7c6:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     7c9:	0f 9d c0                	setge  al
     7cc:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  result = a < b;
     7cf:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     7d2:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     7d5:	0f 9c c0                	setl   al
     7d8:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  result = a <= b;
     7db:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     7de:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     7e1:	0f 9e c0                	setle  al
     7e4:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

}//operators_relational
     7e7:	90                      	nop
     7e8:	c9                      	leave  
     7e9:	c3                      	ret    

000007ea <operators_logical>:

//-----------------------------------------------------------------------------

void operators_logical( void ) {
     7ea:	55                      	push   ebp
     7eb:	89 e5                   	mov    ebp,esp
     7ed:	83 ec 10                	sub    esp,0x10
     7f0:	e8 fc ff ff ff          	call   7f1 <operators_logical+0x7>
     7f5:	05 01 00 00 00          	add    eax,0x1

  // see disassembly
  int a = 2;
     7fa:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
  int b = 3;
     801:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
  int c = 0;
     808:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

  _Bool result = 0;
     80f:	c6 45 f3 00             	mov    BYTE PTR [ebp-0xd],0x0

  // equality
  result = a == a;
     813:	c6 45 f3 01             	mov    BYTE PTR [ebp-0xd],0x1
  result = !( a != b );
     817:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     81a:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     81d:	0f 94 c0                	sete   al
     820:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  // inequality
  result = a != b;
     823:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     826:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     829:	0f 95 c0                	setne  al
     82c:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
  result = !( a == b );
     82f:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     832:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     835:	0f 95 c0                	setne  al
     838:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  // logical and
  result = ( a > b ) && ( b > c );
     83b:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     83e:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     841:	7e 0f                   	jle    852 <operators_logical+0x68>
     843:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
     846:	3b 45 f4                	cmp    eax,DWORD PTR [ebp-0xc]
     849:	7e 07                   	jle    852 <operators_logical+0x68>
     84b:	b8 01 00 00 00          	mov    eax,0x1
     850:	eb 05                   	jmp    857 <operators_logical+0x6d>
     852:	b8 00 00 00 00          	mov    eax,0x0
     857:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
     85a:	80 65 f3 01             	and    BYTE PTR [ebp-0xd],0x1

  // logical inclusive or
  result = ( a > b ) || ( b > c );
     85e:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     861:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     864:	7f 08                   	jg     86e <operators_logical+0x84>
     866:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
     869:	3b 45 f4                	cmp    eax,DWORD PTR [ebp-0xc]
     86c:	7e 07                   	jle    875 <operators_logical+0x8b>
     86e:	b8 01 00 00 00          	mov    eax,0x1
     873:	eb 05                   	jmp    87a <operators_logical+0x90>
     875:	b8 00 00 00 00          	mov    eax,0x0
     87a:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
     87d:	80 65 f3 01             	and    BYTE PTR [ebp-0xd],0x1

  // logical exclusive or (equivalent)
  result = ( a > b ) != ( b > c );
     881:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     884:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     887:	0f 9f c2                	setg   dl
     88a:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
     88d:	3b 45 f4                	cmp    eax,DWORD PTR [ebp-0xc]
     890:	0f 9f c0                	setg   al
     893:	31 d0                   	xor    eax,edx
     895:	0f b6 c0                	movzx  eax,al
     898:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
     89b:	80 65 f3 01             	and    BYTE PTR [ebp-0xd],0x1

  // bool normalized exclusive or (equivalent)
  result = !a != !c;
     89f:	83 7d fc 00             	cmp    DWORD PTR [ebp-0x4],0x0
     8a3:	0f 94 c2                	sete   dl
     8a6:	83 7d f4 00             	cmp    DWORD PTR [ebp-0xc],0x0
     8aa:	0f 94 c0                	sete   al
     8ad:	31 d0                   	xor    eax,edx
     8af:	0f b6 c0                	movzx  eax,al
     8b2:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
     8b5:	80 65 f3 01             	and    BYTE PTR [ebp-0xd],0x1
  result = (_Bool)a != (_Bool)c;
     8b9:	83 7d fc 00             	cmp    DWORD PTR [ebp-0x4],0x0
     8bd:	0f 95 c2                	setne  dl
     8c0:	83 7d f4 00             	cmp    DWORD PTR [ebp-0xc],0x0
     8c4:	0f 95 c0                	setne  al
     8c7:	31 d0                   	xor    eax,edx
     8c9:	0f b6 c0                	movzx  eax,al
     8cc:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
     8cf:	80 65 f3 01             	and    BYTE PTR [ebp-0xd],0x1

  result = a >= b;
     8d3:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     8d6:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     8d9:	0f 9d c0                	setge  al
     8dc:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
  result = !( a < b );
     8df:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     8e2:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     8e5:	0f 9d c0                	setge  al
     8e8:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  result = a < b;
     8eb:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     8ee:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     8f1:	0f 9c c0                	setl   al
     8f4:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
  result = !( a >= b );
     8f7:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     8fa:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     8fd:	0f 9c c0                	setl   al
     900:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

  result = a <= b;
     903:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     906:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     909:	0f 9e c0                	setle  al
     90c:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al
  result = !( a > b );
     90f:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     912:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     915:	0f 9e c0                	setle  al
     918:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

}//operators_logical
     91b:	90                      	nop
     91c:	c9                      	leave  
     91d:	c3                      	ret    

0000091e <operators_assignment>:

//-----------------------------------------------------------------------------

void operators_assignment( void ) {
     91e:	55                      	push   ebp
     91f:	89 e5                   	mov    ebp,esp
     921:	83 ec 10                	sub    esp,0x10
     924:	e8 fc ff ff ff          	call   925 <operators_assignment+0x7>
     929:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int a = 2;
     92e:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
   int b = 3;
     935:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
   int r = 0;
     93c:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   r = r + 1;
     943:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1
   r += 1;
     947:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1

   r = r - 1;
     94b:	83 6d f4 01             	sub    DWORD PTR [ebp-0xc],0x1
   r -= 1;
     94f:	83 6d f4 01             	sub    DWORD PTR [ebp-0xc],0x1

   r = 1;
     953:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1
   r = r * a;
     95a:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     95d:	0f af 45 fc             	imul   eax,DWORD PTR [ebp-0x4]
     961:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   r *= a;
     964:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     967:	0f af 45 fc             	imul   eax,DWORD PTR [ebp-0x4]
     96b:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   r = r / 2;
     96e:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     971:	89 c2                   	mov    edx,eax
     973:	c1 ea 1f                	shr    edx,0x1f
     976:	01 d0                   	add    eax,edx
     978:	d1 f8                   	sar    eax,1
     97a:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   r /= 2;
     97d:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     980:	89 c2                   	mov    edx,eax
     982:	c1 ea 1f                	shr    edx,0x1f
     985:	01 d0                   	add    eax,edx
     987:	d1 f8                   	sar    eax,1
     989:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   r = 5;
     98c:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [ebp-0xc],0x5
   r = r % 2;
     993:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     996:	99                      	cdq    
     997:	c1 ea 1f                	shr    edx,0x1f
     99a:	01 d0                   	add    eax,edx
     99c:	83 e0 01                	and    eax,0x1
     99f:	29 d0                   	sub    eax,edx
     9a1:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   r = 5;
     9a4:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [ebp-0xc],0x5
   r %=  2;
     9ab:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     9ae:	99                      	cdq    
     9af:	c1 ea 1f                	shr    edx,0x1f
     9b2:	01 d0                   	add    eax,edx
     9b4:	83 e0 01                	and    eax,0x1
     9b7:	29 d0                   	sub    eax,edx
     9b9:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   // TODO : diğer "compound assignment" operatörleri

}//operators_assignment
     9bc:	90                      	nop
     9bd:	c9                      	leave  
     9be:	c3                      	ret    

000009bf <operators_conditionalExpression>:

//-----------------------------------------------------------------------------

void operators_conditionalExpression( void ) {
     9bf:	55                      	push   ebp
     9c0:	89 e5                   	mov    ebp,esp
     9c2:	83 ec 20                	sub    esp,0x20
     9c5:	e8 fc ff ff ff          	call   9c6 <operators_conditionalExpression+0x7>
     9ca:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int a = 2;
     9cf:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
   int b = 3;
     9d6:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3

   int min = 0;
     9dd:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
   int max = 0;
     9e4:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

   min =  a < b ? a : b;
     9eb:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     9ee:	39 45 f8                	cmp    DWORD PTR [ebp-0x8],eax
     9f1:	0f 4e 45 f8             	cmovle eax,DWORD PTR [ebp-0x8]
     9f5:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   max =  a > b ? a : b;
     9f8:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     9fb:	39 45 f8                	cmp    DWORD PTR [ebp-0x8],eax
     9fe:	0f 4d 45 f8             	cmovge eax,DWORD PTR [ebp-0x8]
     a02:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

   if ( a < b ) {
     a05:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     a08:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     a0b:	7d 08                   	jge    a15 <operators_conditionalExpression+0x56>
      min = a;
     a0d:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     a10:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
     a13:	eb 06                   	jmp    a1b <operators_conditionalExpression+0x5c>
   } else {
      min = b;
     a15:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
     a18:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   };

   if ( a > b ) {
     a1b:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     a1e:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
     a21:	7e 08                   	jle    a2b <operators_conditionalExpression+0x6c>
      max = a;
     a23:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
     a26:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
     a29:	eb 06                   	jmp    a31 <operators_conditionalExpression+0x72>
   } else {
      max = b;
     a2b:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
     a2e:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   };

   int  x    = 0;
     a31:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   char sign = '.';
     a38:	c6 45 eb 2e             	mov    BYTE PTR [ebp-0x15],0x2e

   x = 0;
     a3c:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   sign = x < 0 ? '-' :
     a43:	83 7d ec 00             	cmp    DWORD PTR [ebp-0x14],0x0
     a47:	78 14                   	js     a5d <operators_conditionalExpression+0x9e>
     a49:	83 7d ec 00             	cmp    DWORD PTR [ebp-0x14],0x0
     a4d:	7e 07                   	jle    a56 <operators_conditionalExpression+0x97>
     a4f:	b8 2b 00 00 00          	mov    eax,0x2b
     a54:	eb 0c                   	jmp    a62 <operators_conditionalExpression+0xa3>
     a56:	b8 2e 00 00 00          	mov    eax,0x2e
     a5b:	eb 05                   	jmp    a62 <operators_conditionalExpression+0xa3>
     a5d:	b8 2d 00 00 00          	mov    eax,0x2d
     a62:	88 45 eb                	mov    BYTE PTR [ebp-0x15],al
          x > 0 ? '+' :
          '.';

   x = -5;
     a65:	c7 45 ec fb ff ff ff    	mov    DWORD PTR [ebp-0x14],0xfffffffb
   sign = x < 0 ? '-' :
     a6c:	83 7d ec 00             	cmp    DWORD PTR [ebp-0x14],0x0
     a70:	78 14                   	js     a86 <operators_conditionalExpression+0xc7>
     a72:	83 7d ec 00             	cmp    DWORD PTR [ebp-0x14],0x0
     a76:	7e 07                   	jle    a7f <operators_conditionalExpression+0xc0>
     a78:	b8 2b 00 00 00          	mov    eax,0x2b
     a7d:	eb 0c                   	jmp    a8b <operators_conditionalExpression+0xcc>
     a7f:	b8 2e 00 00 00          	mov    eax,0x2e
     a84:	eb 05                   	jmp    a8b <operators_conditionalExpression+0xcc>
     a86:	b8 2d 00 00 00          	mov    eax,0x2d
     a8b:	88 45 eb                	mov    BYTE PTR [ebp-0x15],al
          x > 0 ? '+' :
          '.';

   x = +5;
     a8e:	c7 45 ec 05 00 00 00    	mov    DWORD PTR [ebp-0x14],0x5
   sign = x < 0 ? '-' :
     a95:	83 7d ec 00             	cmp    DWORD PTR [ebp-0x14],0x0
     a99:	78 14                   	js     aaf <operators_conditionalExpression+0xf0>
     a9b:	83 7d ec 00             	cmp    DWORD PTR [ebp-0x14],0x0
     a9f:	7e 07                   	jle    aa8 <operators_conditionalExpression+0xe9>
     aa1:	b8 2b 00 00 00          	mov    eax,0x2b
     aa6:	eb 0c                   	jmp    ab4 <operators_conditionalExpression+0xf5>
     aa8:	b8 2e 00 00 00          	mov    eax,0x2e
     aad:	eb 05                   	jmp    ab4 <operators_conditionalExpression+0xf5>
     aaf:	b8 2d 00 00 00          	mov    eax,0x2d
     ab4:	88 45 eb                	mov    BYTE PTR [ebp-0x15],al
          x > 0 ? '+' :
          '.';

   enum { colder, cold, warm, hot, hotter } climate = colder;
     ab7:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0

   int c = 18;
     abe:	c7 45 e0 12 00 00 00    	mov    DWORD PTR [ebp-0x20],0x12
   climate = ( c <= -10 ) ? colder :
     ac5:	83 7d e0 f7             	cmp    DWORD PTR [ebp-0x20],0xfffffff7
     ac9:	7c 40                   	jl     b0b <operators_conditionalExpression+0x14c>
     acb:	83 7d e0 f7             	cmp    DWORD PTR [ebp-0x20],0xfffffff7
     acf:	7c 06                   	jl     ad7 <operators_conditionalExpression+0x118>
             ( c > -10 ) && ( c <= 10 ) ? cold :
     ad1:	83 7d e0 0a             	cmp    DWORD PTR [ebp-0x20],0xa
     ad5:	7e 2d                   	jle    b04 <operators_conditionalExpression+0x145>
   climate = ( c <= -10 ) ? colder :
     ad7:	83 7d e0 0a             	cmp    DWORD PTR [ebp-0x20],0xa
     adb:	7e 06                   	jle    ae3 <operators_conditionalExpression+0x124>
             ( c >  10 ) && ( c <= 25 ) ? warm :
     add:	83 7d e0 19             	cmp    DWORD PTR [ebp-0x20],0x19
     ae1:	7e 1a                   	jle    afd <operators_conditionalExpression+0x13e>
   climate = ( c <= -10 ) ? colder :
     ae3:	83 7d e0 19             	cmp    DWORD PTR [ebp-0x20],0x19
     ae7:	7e 0d                   	jle    af6 <operators_conditionalExpression+0x137>
             ( c >  25 ) && ( c <= 35 ) ? hot  :
     ae9:	83 7d e0 23             	cmp    DWORD PTR [ebp-0x20],0x23
     aed:	7f 07                   	jg     af6 <operators_conditionalExpression+0x137>
   climate = ( c <= -10 ) ? colder :
     aef:	b8 03 00 00 00          	mov    eax,0x3
     af4:	eb 1a                   	jmp    b10 <operators_conditionalExpression+0x151>
     af6:	b8 04 00 00 00          	mov    eax,0x4
     afb:	eb 13                   	jmp    b10 <operators_conditionalExpression+0x151>
     afd:	b8 02 00 00 00          	mov    eax,0x2
     b02:	eb 0c                   	jmp    b10 <operators_conditionalExpression+0x151>
     b04:	b8 01 00 00 00          	mov    eax,0x1
     b09:	eb 05                   	jmp    b10 <operators_conditionalExpression+0x151>
     b0b:	b8 00 00 00 00          	mov    eax,0x0
     b10:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax
             hotter;

}//operators_conditionalExpression
     b13:	90                      	nop
     b14:	c9                      	leave  
     b15:	c3                      	ret    

00000b16 <operators_multiplicative>:

//-----------------------------------------------------------------------------

void operators_multiplicative( void ) {
     b16:	55                      	push   ebp
     b17:	89 e5                   	mov    ebp,esp
     b19:	83 ec 40                	sub    esp,0x40
     b1c:	e8 fc ff ff ff          	call   b1d <operators_multiplicative+0x7>
     b21:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   char ca = 2;
     b26:	c6 45 ff 02             	mov    BYTE PTR [ebp-0x1],0x2
   char cb = 3;
     b2a:	c6 45 fe 03             	mov    BYTE PTR [ebp-0x2],0x3
   char cc = 0;
     b2e:	c6 45 fd 00             	mov    BYTE PTR [ebp-0x3],0x0

   int ia = 2;
     b32:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
   int ib = 3;
     b39:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [ebp-0xc],0x3
   int ic = 0;
     b40:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

   unsigned int ua = 2;
     b47:	c7 45 ec 02 00 00 00    	mov    DWORD PTR [ebp-0x14],0x2
   unsigned int ub = 3;
     b4e:	c7 45 e8 03 00 00 00    	mov    DWORD PTR [ebp-0x18],0x3
   unsigned int uc = 0;
     b55:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0

   float fa = .2F;
     b5c:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     b62:	d9 5d e0                	fstp   DWORD PTR [ebp-0x20]
   float fb = .3F;
     b65:	d9 80 18 04 00 00       	fld    DWORD PTR [eax+0x418]
     b6b:	d9 5d dc                	fstp   DWORD PTR [ebp-0x24]
   float fc = .0F;
     b6e:	d9 ee                   	fldz   
     b70:	d9 5d d8                	fstp   DWORD PTR [ebp-0x28]

   cc = ca * cb;
     b73:	0f b6 45 ff             	movzx  eax,BYTE PTR [ebp-0x1]
     b77:	0f b6 55 fe             	movzx  edx,BYTE PTR [ebp-0x2]
     b7b:	0f af c2                	imul   eax,edx
     b7e:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = cc / ca;
     b81:	0f be 45 fd             	movsx  eax,BYTE PTR [ebp-0x3]
     b85:	0f be 4d ff             	movsx  ecx,BYTE PTR [ebp-0x1]
     b89:	99                      	cdq    
     b8a:	f7 f9                   	idiv   ecx
     b8c:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = cb % ca;
     b8f:	0f be 45 fe             	movsx  eax,BYTE PTR [ebp-0x2]
     b93:	0f be 4d ff             	movsx  ecx,BYTE PTR [ebp-0x1]
     b97:	99                      	cdq    
     b98:	f7 f9                   	idiv   ecx
     b9a:	89 d0                   	mov    eax,edx
     b9c:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al

   ic = ia * ib;
     b9f:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
     ba2:	0f af 45 f4             	imul   eax,DWORD PTR [ebp-0xc]
     ba6:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   ic = ic / ia;
     ba9:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     bac:	99                      	cdq    
     bad:	f7 7d f8                	idiv   DWORD PTR [ebp-0x8]
     bb0:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   ic = ib % ia;
     bb3:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
     bb6:	99                      	cdq    
     bb7:	f7 7d f8                	idiv   DWORD PTR [ebp-0x8]
     bba:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx

   uc = ua * ub;
     bbd:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
     bc0:	0f af 45 e8             	imul   eax,DWORD PTR [ebp-0x18]
     bc4:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax
   uc = uc / ua;
     bc7:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
     bca:	ba 00 00 00 00          	mov    edx,0x0
     bcf:	f7 75 ec                	div    DWORD PTR [ebp-0x14]
     bd2:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax
   uc = ub % ua; // remainder
     bd5:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     bd8:	ba 00 00 00 00          	mov    edx,0x0
     bdd:	f7 75 ec                	div    DWORD PTR [ebp-0x14]
     be0:	89 55 e4                	mov    DWORD PTR [ebp-0x1c],edx

   fc = fa * fb;
     be3:	d9 45 e0                	fld    DWORD PTR [ebp-0x20]
     be6:	d8 4d dc                	fmul   DWORD PTR [ebp-0x24]
     be9:	d9 5d d8                	fstp   DWORD PTR [ebp-0x28]
   fc = fc / fa;
     bec:	d9 45 d8                	fld    DWORD PTR [ebp-0x28]
     bef:	d8 75 e0                	fdiv   DWORD PTR [ebp-0x20]
     bf2:	d9 5d d8                	fstp   DWORD PTR [ebp-0x28]

   //fc = fc % fa; // ?
   //fc = fc % ia; // ?

   // remainder
   int a =  3 % -2;
     bf5:	c7 45 d4 01 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x1
   int b = -3 %  2;
     bfc:	c7 45 d0 ff ff ff ff    	mov    DWORD PTR [ebp-0x30],0xffffffff
   int c = -3 % -2;
     c03:	c7 45 cc ff ff ff ff    	mov    DWORD PTR [ebp-0x34],0xffffffff
	
}//operators_multiplicative
     c0a:	90                      	nop
     c0b:	c9                      	leave  
     c0c:	c3                      	ret    

00000c0d <Remainder>:

//-----------------------------------------------------------------------------

// remainder: causes conflict 
int Remainder( int a, int b ) {
     c0d:	55                      	push   ebp
     c0e:	89 e5                   	mov    ebp,esp
     c10:	e8 fc ff ff ff          	call   c11 <Remainder+0x4>
     c15:	05 01 00 00 00          	add    eax,0x1

   return a - (a / b) * b;
     c1a:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
     c1d:	99                      	cdq    
     c1e:	f7 7d 0c                	idiv   DWORD PTR [ebp+0xc]
     c21:	89 d0                   	mov    eax,edx

}
     c23:	5d                      	pop    ebp
     c24:	c3                      	ret    

00000c25 <modulo>:

//-----------------------------------------------------------------------------

int modulo( int a, int b ) {
     c25:	55                      	push   ebp
     c26:	89 e5                   	mov    ebp,esp
     c28:	83 ec 10                	sub    esp,0x10
     c2b:	e8 fc ff ff ff          	call   c2c <modulo+0x7>
     c30:	05 01 00 00 00          	add    eax,0x1

   int r = a % b;
     c35:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
     c38:	99                      	cdq    
     c39:	f7 7d 0c                	idiv   DWORD PTR [ebp+0xc]
     c3c:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
   return r < 0 ? r + b : r;
     c3f:	83 7d fc 00             	cmp    DWORD PTR [ebp-0x4],0x0
     c43:	79 0a                   	jns    c4f <modulo+0x2a>
     c45:	8b 55 fc                	mov    edx,DWORD PTR [ebp-0x4]
     c48:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
     c4b:	01 d0                   	add    eax,edx
     c4d:	eb 03                   	jmp    c52 <modulo+0x2d>
     c4f:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]

}
     c52:	c9                      	leave  
     c53:	c3                      	ret    

00000c54 <operators_additive>:

//-----------------------------------------------------------------------------

void operators_additive( void ) {
     c54:	55                      	push   ebp
     c55:	89 e5                   	mov    ebp,esp
     c57:	83 ec 30                	sub    esp,0x30
     c5a:	e8 fc ff ff ff          	call   c5b <operators_additive+0x7>
     c5f:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   char ca = 2;
     c64:	c6 45 ff 02             	mov    BYTE PTR [ebp-0x1],0x2
   char cb = 3;
     c68:	c6 45 fe 03             	mov    BYTE PTR [ebp-0x2],0x3
   char cc = 0;
     c6c:	c6 45 fd 00             	mov    BYTE PTR [ebp-0x3],0x0

   short sa = 2;
     c70:	66 c7 45 fa 02 00       	mov    WORD PTR [ebp-0x6],0x2
   short sb = 3;
     c76:	66 c7 45 f8 03 00       	mov    WORD PTR [ebp-0x8],0x3
   short sc = 0;
     c7c:	66 c7 45 f6 00 00       	mov    WORD PTR [ebp-0xa],0x0

   int ia = 2;
     c82:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [ebp-0x10],0x2
   int ib = 3;
     c89:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [ebp-0x14],0x3
   int ic = 0;
     c90:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

   unsigned int ua = 2;
     c97:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x2
   unsigned int ub = 3;
     c9e:	c7 45 e0 03 00 00 00    	mov    DWORD PTR [ebp-0x20],0x3
   unsigned int uc = 0;
     ca5:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0

   float fa = .2F;
     cac:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
     cb2:	d9 5d d8                	fstp   DWORD PTR [ebp-0x28]
   float fb = .3F;
     cb5:	d9 80 18 04 00 00       	fld    DWORD PTR [eax+0x418]
     cbb:	d9 5d d4                	fstp   DWORD PTR [ebp-0x2c]
   float fc = .0F;
     cbe:	d9 ee                   	fldz   
     cc0:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]

   cc = ca + cb;
     cc3:	0f b6 55 ff             	movzx  edx,BYTE PTR [ebp-0x1]
     cc7:	0f b6 45 fe             	movzx  eax,BYTE PTR [ebp-0x2]
     ccb:	01 d0                   	add    eax,edx
     ccd:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = cb - ca;
     cd0:	0f b6 45 fe             	movzx  eax,BYTE PTR [ebp-0x2]
     cd4:	0f b6 55 ff             	movzx  edx,BYTE PTR [ebp-0x1]
     cd8:	29 d0                   	sub    eax,edx
     cda:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = ca - cb;
     cdd:	0f b6 45 ff             	movzx  eax,BYTE PTR [ebp-0x1]
     ce1:	0f b6 55 fe             	movzx  edx,BYTE PTR [ebp-0x2]
     ce5:	29 d0                   	sub    eax,edx
     ce7:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al

   sc = sa + sb;
     cea:	0f b7 55 fa             	movzx  edx,WORD PTR [ebp-0x6]
     cee:	0f b7 45 f8             	movzx  eax,WORD PTR [ebp-0x8]
     cf2:	01 d0                   	add    eax,edx
     cf4:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = sb - sa;
     cf8:	0f b7 45 f8             	movzx  eax,WORD PTR [ebp-0x8]
     cfc:	0f b7 55 fa             	movzx  edx,WORD PTR [ebp-0x6]
     d00:	29 d0                   	sub    eax,edx
     d02:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = sa - sb;
     d06:	0f b7 45 fa             	movzx  eax,WORD PTR [ebp-0x6]
     d0a:	0f b7 55 f8             	movzx  edx,WORD PTR [ebp-0x8]
     d0e:	29 d0                   	sub    eax,edx
     d10:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax

   ic = ia + ib;
     d14:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
     d17:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
     d1a:	01 d0                   	add    eax,edx
     d1c:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   ic = ib - ia;
     d1f:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
     d22:	2b 45 f0                	sub    eax,DWORD PTR [ebp-0x10]
     d25:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   ic = ia - ib;
     d28:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     d2b:	2b 45 ec                	sub    eax,DWORD PTR [ebp-0x14]
     d2e:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

   uc = ua + ub;
     d31:	8b 55 e4                	mov    edx,DWORD PTR [ebp-0x1c]
     d34:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
     d37:	01 d0                   	add    eax,edx
     d39:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
   uc = ub - ua;
     d3c:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
     d3f:	2b 45 e4                	sub    eax,DWORD PTR [ebp-0x1c]
     d42:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
   uc = ua - ub;
     d45:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
     d48:	2b 45 e0                	sub    eax,DWORD PTR [ebp-0x20]
     d4b:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

   fc = fa + fb;
     d4e:	d9 45 d8                	fld    DWORD PTR [ebp-0x28]
     d51:	d8 45 d4                	fadd   DWORD PTR [ebp-0x2c]
     d54:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fc = fb - fa;
     d57:	d9 45 d4                	fld    DWORD PTR [ebp-0x2c]
     d5a:	d8 65 d8                	fsub   DWORD PTR [ebp-0x28]
     d5d:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]
   fc = fa - fb;
     d60:	d9 45 d8                	fld    DWORD PTR [ebp-0x28]
     d63:	d8 65 d4                	fsub   DWORD PTR [ebp-0x2c]
     d66:	d9 5d d0                	fstp   DWORD PTR [ebp-0x30]

}//operators_additive
     d69:	90                      	nop
     d6a:	c9                      	leave  
     d6b:	c3                      	ret    

00000d6c <operators_binary>:

//-----------------------------------------------------------------------------

void operators_binary( void ) {
     d6c:	55                      	push   ebp
     d6d:	89 e5                   	mov    ebp,esp
     d6f:	83 ec 30                	sub    esp,0x30
     d72:	e8 fc ff ff ff          	call   d73 <operators_binary+0x7>
     d77:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   char ca = 2;
     d7c:	c6 45 ff 02             	mov    BYTE PTR [ebp-0x1],0x2
   char cb = 3;
     d80:	c6 45 fe 03             	mov    BYTE PTR [ebp-0x2],0x3
   char cc = 0;
     d84:	c6 45 fd 00             	mov    BYTE PTR [ebp-0x3],0x0

   short sa = 2;
     d88:	66 c7 45 fa 02 00       	mov    WORD PTR [ebp-0x6],0x2
   short sb = 3;
     d8e:	66 c7 45 f8 03 00       	mov    WORD PTR [ebp-0x8],0x3
   short sc = 0;
     d94:	66 c7 45 f6 00 00       	mov    WORD PTR [ebp-0xa],0x0

   int ia = 2;
     d9a:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [ebp-0x10],0x2
   int ib = 3;
     da1:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [ebp-0x14],0x3
   int ic = 0;
     da8:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

   unsigned int ua = 2;
     daf:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x2
   unsigned int ub = 3;
     db6:	c7 45 e0 03 00 00 00    	mov    DWORD PTR [ebp-0x20],0x3
   unsigned int uc = 0;
     dbd:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0

   cc = ca & cb;
     dc4:	0f b6 45 ff             	movzx  eax,BYTE PTR [ebp-0x1]
     dc8:	22 45 fe                	and    al,BYTE PTR [ebp-0x2]
     dcb:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = ca | cb;
     dce:	0f b6 45 ff             	movzx  eax,BYTE PTR [ebp-0x1]
     dd2:	0a 45 fe                	or     al,BYTE PTR [ebp-0x2]
     dd5:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = ca ^ cb;
     dd8:	0f b6 45 ff             	movzx  eax,BYTE PTR [ebp-0x1]
     ddc:	32 45 fe                	xor    al,BYTE PTR [ebp-0x2]
     ddf:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = ~ca;
     de2:	0f b6 45 ff             	movzx  eax,BYTE PTR [ebp-0x1]
     de6:	f7 d0                   	not    eax
     de8:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al

   cc = ca << 1;
     deb:	0f be 45 ff             	movsx  eax,BYTE PTR [ebp-0x1]
     def:	01 c0                   	add    eax,eax
     df1:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al
   cc = ca << 2;
     df4:	0f be 45 ff             	movsx  eax,BYTE PTR [ebp-0x1]
     df8:	c1 e0 02                	shl    eax,0x2
     dfb:	88 45 fd                	mov    BYTE PTR [ebp-0x3],al

   sc = sa & sb;
     dfe:	0f b7 45 fa             	movzx  eax,WORD PTR [ebp-0x6]
     e02:	66 23 45 f8             	and    ax,WORD PTR [ebp-0x8]
     e06:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = sa | sb;
     e0a:	0f b7 45 fa             	movzx  eax,WORD PTR [ebp-0x6]
     e0e:	66 0b 45 f8             	or     ax,WORD PTR [ebp-0x8]
     e12:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = sa ^ sb;
     e16:	0f b7 45 fa             	movzx  eax,WORD PTR [ebp-0x6]
     e1a:	66 33 45 f8             	xor    ax,WORD PTR [ebp-0x8]
     e1e:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = ~sa;
     e22:	0f b7 45 fa             	movzx  eax,WORD PTR [ebp-0x6]
     e26:	f7 d0                   	not    eax
     e28:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax

   sc = sa << 1;
     e2c:	0f bf 45 fa             	movsx  eax,WORD PTR [ebp-0x6]
     e30:	01 c0                   	add    eax,eax
     e32:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = sa << 2;
     e36:	0f bf 45 fa             	movsx  eax,WORD PTR [ebp-0x6]
     e3a:	c1 e0 02                	shl    eax,0x2
     e3d:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax

   sc = -3;
     e41:	66 c7 45 f6 fd ff       	mov    WORD PTR [ebp-0xa],0xfffd
   sc = sc << 1;
     e47:	0f bf 45 f6             	movsx  eax,WORD PTR [ebp-0xa]
     e4b:	01 c0                   	add    eax,eax
     e4d:	66 89 45 f6             	mov    WORD PTR [ebp-0xa],ax
   sc = -3;
     e51:	66 c7 45 f6 fd ff       	mov    WORD PTR [ebp-0xa],0xfffd
   sc = sc >> 1;
     e57:	66 d1 7d f6             	sar    WORD PTR [ebp-0xa],1

   ic = ia & ib;
     e5b:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     e5e:	23 45 ec                	and    eax,DWORD PTR [ebp-0x14]
     e61:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   ic = ia | ib;
     e64:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     e67:	0b 45 ec                	or     eax,DWORD PTR [ebp-0x14]
     e6a:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   ic = ia ^ ib;
     e6d:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     e70:	33 45 ec                	xor    eax,DWORD PTR [ebp-0x14]
     e73:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   ic = ~ia;
     e76:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     e79:	f7 d0                   	not    eax
     e7b:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

   ic = -3;
     e7e:	c7 45 e8 fd ff ff ff    	mov    DWORD PTR [ebp-0x18],0xfffffffd
   ic = ic << 1;
     e85:	d1 65 e8                	shl    DWORD PTR [ebp-0x18],1
   ic = -3;
     e88:	c7 45 e8 fd ff ff ff    	mov    DWORD PTR [ebp-0x18],0xfffffffd
   ic = ic >> 1;
     e8f:	d1 7d e8                	sar    DWORD PTR [ebp-0x18],1

   uc = ua & ub;
     e92:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
     e95:	23 45 e0                	and    eax,DWORD PTR [ebp-0x20]
     e98:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
   uc = ua | ub;
     e9b:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
     e9e:	0b 45 e0                	or     eax,DWORD PTR [ebp-0x20]
     ea1:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
   uc = ua ^ ub;
     ea4:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
     ea7:	33 45 e0                	xor    eax,DWORD PTR [ebp-0x20]
     eaa:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
   uc = ~ua;
     ead:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
     eb0:	f7 d0                   	not    eax
     eb2:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

   uc = 8;
     eb5:	c7 45 dc 08 00 00 00    	mov    DWORD PTR [ebp-0x24],0x8
   uc = uc << 1;
     ebc:	d1 65 dc                	shl    DWORD PTR [ebp-0x24],1
   uc = 8;
     ebf:	c7 45 dc 08 00 00 00    	mov    DWORD PTR [ebp-0x24],0x8
   uc = uc >> 1;
     ec6:	d1 6d dc                	shr    DWORD PTR [ebp-0x24],1

}//operators_binary
     ec9:	90                      	nop
     eca:	c9                      	leave  
     ecb:	c3                      	ret    

00000ecc <pointers1>:

//-----------------------------------------------------------------------------

void pointers1( void ) {
     ecc:	55                      	push   ebp
     ecd:	89 e5                   	mov    ebp,esp
     ecf:	83 ec 30                	sub    esp,0x30
     ed2:	e8 fc ff ff ff          	call   ed3 <pointers1+0x7>
     ed7:	05 01 00 00 00          	add    eax,0x1

   int a = 0;
     edc:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [ebp-0x20],0x0
   int b = 0;
     ee3:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0


   unsigned int addressX = 0;
     eea:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
   unsigned int addressY = 0;
     ef1:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   char ar[] = "vwxyz";
     ef8:	c7 45 da 76 77 78 79    	mov    DWORD PTR [ebp-0x26],0x79787776
     eff:	66 c7 45 de 7a 00       	mov    WORD PTR [ebp-0x22],0x7a
   int  *pi;
   int* piA = NULL;
     f05:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
   int* piB = NULL;
     f0c:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0

   pi = 0;
     f13:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0
   pi = '\0';
     f1a:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0
   pi = NULL;
     f21:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

   pi  = &a;
     f28:	8d 45 e0                	lea    eax,[ebp-0x20]
     f2b:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *pi = 3;
     f2e:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     f31:	c7 00 03 00 00 00       	mov    DWORD PTR [eax],0x3

   addressX = &a;
     f37:	8d 45 e0                	lea    eax,[ebp-0x20]
     f3a:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax
   addressY = pi;
     f3d:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     f40:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   a = 5;
     f43:	c7 45 e0 05 00 00 00    	mov    DWORD PTR [ebp-0x20],0x5
   b = *pi;
     f4a:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     f4d:	8b 00                   	mov    eax,DWORD PTR [eax]
     f4f:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

   pi++;
     f52:	83 45 e8 04             	add    DWORD PTR [ebp-0x18],0x4
   *pi = 7;
     f56:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     f59:	c7 00 07 00 00 00       	mov    DWORD PTR [eax],0x7

   pi  = ar;
     f5f:	8d 45 da                	lea    eax,[ebp-0x26]
     f62:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *pi = 1684234849;
     f65:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     f68:	c7 00 61 62 63 64       	mov    DWORD PTR [eax],0x64636261

   a   = 3;
     f6e:	c7 45 e0 03 00 00 00    	mov    DWORD PTR [ebp-0x20],0x3
   piA = &a;
     f75:	8d 45 e0                	lea    eax,[ebp-0x20]
     f78:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   piB = &a;
     f7b:	8d 45 e0                	lea    eax,[ebp-0x20]
     f7e:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   int c = 0;
     f81:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
   c = *piA;
     f88:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     f8b:	8b 00                   	mov    eax,DWORD PTR [eax]
     f8d:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax
   c = *piB;
     f90:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
     f93:	8b 00                   	mov    eax,DWORD PTR [eax]
     f95:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax

   c = 4;
     f98:	c7 45 e4 04 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x4
   *piB = c;
     f9f:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
     fa2:	8b 55 e4                	mov    edx,DWORD PTR [ebp-0x1c]
     fa5:	89 10                   	mov    DWORD PTR [eax],edx
   c = a + *piA + *piB;
     fa7:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
     faa:	8b 10                   	mov    edx,DWORD PTR [eax]
     fac:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
     faf:	01 c2                   	add    edx,eax
     fb1:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
     fb4:	8b 00                   	mov    eax,DWORD PTR [eax]
     fb6:	01 d0                   	add    eax,edx
     fb8:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax

   char d[] = "efgh";
     fbb:	c7 45 d5 65 66 67 68    	mov    DWORD PTR [ebp-0x2b],0x68676665
     fc2:	c6 45 d9 00             	mov    BYTE PTR [ebp-0x27],0x0
   *pi = *(int*)d;
     fc6:	8d 45 d5                	lea    eax,[ebp-0x2b]
     fc9:	8b 10                   	mov    edx,DWORD PTR [eax]
     fcb:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
     fce:	89 10                   	mov    DWORD PTR [eax],edx

}//pointers1
     fd0:	90                      	nop
     fd1:	c9                      	leave  
     fd2:	c3                      	ret    

00000fd3 <pointers2>:

//-----------------------------------------------------------------------------

void pointers2( void ) {
     fd3:	55                      	push   ebp
     fd4:	89 e5                   	mov    ebp,esp
     fd6:	83 ec 30                	sub    esp,0x30
     fd9:	e8 fc ff ff ff          	call   fda <pointers2+0x7>
     fde:	05 01 00 00 00          	add    eax,0x1

   int a = 0;
     fe3:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
   int b = 0;
     fea:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
   int c = 0;
     ff1:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   int d = 0;
     ff8:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
   int e = 0;
     fff:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

   int* pi  = NULL;
    1006:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

   int arr[] = { 0, 0, 0, 0, 0 };
    100d:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x0
    1014:	c7 45 d8 00 00 00 00    	mov    DWORD PTR [ebp-0x28],0x0
    101b:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
    1022:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [ebp-0x20],0x0
    1029:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0

   pi = &arr[0];
    1030:	8d 45 d4                	lea    eax,[ebp-0x2c]
    1033:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *pi = 15;
    1036:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1039:	c7 00 0f 00 00 00       	mov    DWORD PTR [eax],0xf

   pi = pi + 1;
    103f:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1042:	83 c0 04                	add    eax,0x4
    1045:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *pi = 20;
    1048:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    104b:	c7 00 14 00 00 00       	mov    DWORD PTR [eax],0x14

   pi += 1;
    1051:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1054:	83 c0 04                	add    eax,0x4
    1057:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *pi = 25;
    105a:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    105d:	c7 00 19 00 00 00       	mov    DWORD PTR [eax],0x19

   pi++;
    1063:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1066:	83 c0 04                	add    eax,0x4
    1069:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *pi = 30;
    106c:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    106f:	c7 00 1e 00 00 00       	mov    DWORD PTR [eax],0x1e

   *pi++ = 35;
    1075:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1078:	8d 50 04                	lea    edx,[eax+0x4]
    107b:	89 55 e8                	mov    DWORD PTR [ebp-0x18],edx
    107e:	c7 00 23 00 00 00       	mov    DWORD PTR [eax],0x23

   *pi = 40;
    1084:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1087:	c7 00 28 00 00 00       	mov    DWORD PTR [eax],0x28

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    108d:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
    1094:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    1097:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax
    109a:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    109d:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
    10a0:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    10a3:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
    10a6:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    10a9:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

   pi = &arr[0];
    10ac:	8d 45 d4                	lea    eax,[ebp-0x2c]
    10af:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   *(pi + 0) = 2;
    10b2:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    10b5:	c7 00 02 00 00 00       	mov    DWORD PTR [eax],0x2
   *(pi + 1) = 4;
    10bb:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    10be:	83 c0 04                	add    eax,0x4
    10c1:	c7 00 04 00 00 00       	mov    DWORD PTR [eax],0x4
   *(pi + 2) = 6;
    10c7:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    10ca:	83 c0 08                	add    eax,0x8
    10cd:	c7 00 06 00 00 00       	mov    DWORD PTR [eax],0x6
   *(pi + 3) = 8;
    10d3:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    10d6:	83 c0 0c                	add    eax,0xc
    10d9:	c7 00 08 00 00 00       	mov    DWORD PTR [eax],0x8
   *(pi + 4) = 10;
    10df:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    10e2:	83 c0 10                	add    eax,0x10
    10e5:	c7 00 0a 00 00 00       	mov    DWORD PTR [eax],0xa

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    10eb:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
    10f2:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    10f5:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax
    10f8:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    10fb:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
    10fe:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    1101:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
    1104:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    1107:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

   pi = &arr[0];
    110a:	8d 45 d4                	lea    eax,[ebp-0x2c]
    110d:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   pi[0] = 3;
    1110:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1113:	c7 00 03 00 00 00       	mov    DWORD PTR [eax],0x3
   pi[1] = 5;
    1119:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    111c:	83 c0 04                	add    eax,0x4
    111f:	c7 00 05 00 00 00       	mov    DWORD PTR [eax],0x5
   pi[2] = 7;
    1125:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1128:	83 c0 08                	add    eax,0x8
    112b:	c7 00 07 00 00 00       	mov    DWORD PTR [eax],0x7
   pi[3] = 9;
    1131:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1134:	83 c0 0c                	add    eax,0xc
    1137:	c7 00 09 00 00 00       	mov    DWORD PTR [eax],0x9
   pi[4] = 11;
    113d:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1140:	83 c0 10                	add    eax,0x10
    1143:	c7 00 0b 00 00 00       	mov    DWORD PTR [eax],0xb

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    1149:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
    1150:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    1153:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax
    1156:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    1159:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
    115c:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    115f:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
    1162:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    1165:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

   *arr = 111;
    1168:	c7 45 d4 6f 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x6f
   *(arr + 0) = 100;
    116f:	c7 45 d4 64 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x64
   *(arr + 1) = 200;
    1176:	c7 45 d8 c8 00 00 00    	mov    DWORD PTR [ebp-0x28],0xc8
   *(arr + 2) = 300;
    117d:	c7 45 dc 2c 01 00 00    	mov    DWORD PTR [ebp-0x24],0x12c
   *(arr + 3) = 400;
    1184:	c7 45 e0 90 01 00 00    	mov    DWORD PTR [ebp-0x20],0x190
   *(arr + 4) = 500;
    118b:	c7 45 e4 f4 01 00 00    	mov    DWORD PTR [ebp-0x1c],0x1f4


   pi = &arr[4];
    1192:	8d 45 d4                	lea    eax,[ebp-0x2c]
    1195:	83 c0 10                	add    eax,0x10
    1198:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
   pi[-4] = 10;
    119b:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    119e:	83 e8 10                	sub    eax,0x10
    11a1:	c7 00 0a 00 00 00       	mov    DWORD PTR [eax],0xa
   pi[-3] = 20;
    11a7:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11aa:	83 e8 0c                	sub    eax,0xc
    11ad:	c7 00 14 00 00 00       	mov    DWORD PTR [eax],0x14
   pi[-2] = 30;
    11b3:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11b6:	83 e8 08                	sub    eax,0x8
    11b9:	c7 00 1e 00 00 00       	mov    DWORD PTR [eax],0x1e
   pi[-1] = 40;
    11bf:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11c2:	83 e8 04                	sub    eax,0x4
    11c5:	c7 00 28 00 00 00       	mov    DWORD PTR [eax],0x28
   pi[ 0] = 50;
    11cb:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11ce:	c7 00 32 00 00 00       	mov    DWORD PTR [eax],0x32


   pi = &c;
    11d4:	8d 45 ec                	lea    eax,[ebp-0x14]
    11d7:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

   // !! danger
   *(pi - 1) = 22;
    11da:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11dd:	83 e8 04                	sub    eax,0x4
    11e0:	c7 00 16 00 00 00       	mov    DWORD PTR [eax],0x16
   *(pi - 2) = 11;
    11e6:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11e9:	83 e8 08                	sub    eax,0x8
    11ec:	c7 00 0b 00 00 00       	mov    DWORD PTR [eax],0xb

   *(pi + 1) = 44;
    11f2:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    11f5:	83 c0 04                	add    eax,0x4
    11f8:	c7 00 2c 00 00 00       	mov    DWORD PTR [eax],0x2c
   *(pi + 2) = 55;
    11fe:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1201:	83 c0 08                	add    eax,0x8
    1204:	c7 00 37 00 00 00       	mov    DWORD PTR [eax],0x37

   *(pi + 3) = 66;
    120a:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    120d:	83 c0 0c                	add    eax,0xc
    1210:	c7 00 42 00 00 00       	mov    DWORD PTR [eax],0x42
   *(pi + 4) = 77;
    1216:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1219:	83 c0 10                	add    eax,0x10
    121c:	c7 00 4d 00 00 00       	mov    DWORD PTR [eax],0x4d

   a = b = c = d = e;
    1222:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    1225:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
    1228:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    122b:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax
    122e:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    1231:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax
    1234:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    1237:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

   pi = (int*)&pi;
    123a:	8d 45 e8                	lea    eax,[ebp-0x18]
    123d:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

   // !! danger
   pi[-1] = 8;
    1240:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1243:	83 e8 04                	sub    eax,0x4
    1246:	c7 00 08 00 00 00       	mov    DWORD PTR [eax],0x8
   pi[-2] = 7;
    124c:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    124f:	83 e8 08                	sub    eax,0x8
    1252:	c7 00 07 00 00 00       	mov    DWORD PTR [eax],0x7
   pi[-3] = 6;
    1258:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    125b:	83 e8 0c                	sub    eax,0xc
    125e:	c7 00 06 00 00 00       	mov    DWORD PTR [eax],0x6
   pi[-4] = 5;
    1264:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1267:	83 e8 10                	sub    eax,0x10
    126a:	c7 00 05 00 00 00       	mov    DWORD PTR [eax],0x5
   pi[-5] = 4;
    1270:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1273:	83 e8 14                	sub    eax,0x14
    1276:	c7 00 04 00 00 00       	mov    DWORD PTR [eax],0x4

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    127c:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
    1283:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    1286:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax
    1289:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    128c:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
    128f:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    1292:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
    1295:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    1298:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

   0[arr] = 7;
    129b:	c7 45 d4 07 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x7
   1[arr] = 6;
    12a2:	c7 45 d8 06 00 00 00    	mov    DWORD PTR [ebp-0x28],0x6
   2[arr] = 5;
    12a9:	c7 45 dc 05 00 00 00    	mov    DWORD PTR [ebp-0x24],0x5
   3[arr] = 4;
    12b0:	c7 45 e0 04 00 00 00    	mov    DWORD PTR [ebp-0x20],0x4
   4[arr] = 2;
    12b7:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x2

   // http://www.youtube.com/watch?v=IJNR2EpS0jw
   *(pi + 5) = 88;
    12be:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    12c1:	83 c0 14                	add    eax,0x14
    12c4:	c7 00 58 00 00 00       	mov    DWORD PTR [eax],0x58
   *(pi + 6) = 99;
    12ca:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    12cd:	83 c0 18                	add    eax,0x18
    12d0:	c7 00 63 00 00 00       	mov    DWORD PTR [eax],0x63

}//pointers2
    12d6:	90                      	nop
    12d7:	c9                      	leave  
    12d8:	c3                      	ret    

000012d9 <pointers3>:

//-----------------------------------------------------------------------------

void pointers3( void ) {
    12d9:	55                      	push   ebp
    12da:	89 e5                   	mov    ebp,esp
    12dc:	83 ec 10                	sub    esp,0x10
    12df:	e8 fc ff ff ff          	call   12e0 <pointers3+0x7>
    12e4:	05 01 00 00 00          	add    eax,0x1

	// see disassembly
	int    a =  3;
    12e9:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
	int   *b = &a;
    12f0:	8d 45 f8                	lea    eax,[ebp-0x8]
    12f3:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	int  **c = &b;
    12f6:	8d 45 f4                	lea    eax,[ebp-0xc]
    12f9:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
	int ***d = &c;
    12fc:	8d 45 f0                	lea    eax,[ebp-0x10]
    12ff:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

	   a = 2;
    1302:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
	  *b = 3;
    1309:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    130c:	c7 00 03 00 00 00       	mov    DWORD PTR [eax],0x3
     **c = 4;
    1312:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    1315:	8b 00                   	mov    eax,DWORD PTR [eax]
    1317:	c7 00 04 00 00 00       	mov    DWORD PTR [eax],0x4
	***d = 5;
    131d:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1320:	8b 00                   	mov    eax,DWORD PTR [eax]
    1322:	8b 00                   	mov    eax,DWORD PTR [eax]
    1324:	c7 00 05 00 00 00       	mov    DWORD PTR [eax],0x5

}//pointers3
    132a:	90                      	nop
    132b:	c9                      	leave  
    132c:	c3                      	ret    

0000132d <pointers4>:

//-----------------------------------------------------------------------------

void pointers4( void ) {
    132d:	55                      	push   ebp
    132e:	89 e5                   	mov    ebp,esp
    1330:	83 ec 70                	sub    esp,0x70
    1333:	e8 fc ff ff ff          	call   1334 <pointers4+0x7>
    1338:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int arrI[ 5 ] = { 10, 20, 30, 40, 50 };
    133d:	c7 45 d4 0a 00 00 00    	mov    DWORD PTR [ebp-0x2c],0xa
    1344:	c7 45 d8 14 00 00 00    	mov    DWORD PTR [ebp-0x28],0x14
    134b:	c7 45 dc 1e 00 00 00    	mov    DWORD PTR [ebp-0x24],0x1e
    1352:	c7 45 e0 28 00 00 00    	mov    DWORD PTR [ebp-0x20],0x28
    1359:	c7 45 e4 32 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x32

   int *piA = NULL;
    1360:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
   int *piB = NULL;
    1367:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0

   long double arrLD[ 5 ] = { .10L, .20L, .30L, .40L, .50L };
    136e:	db a8 20 04 00 00       	fld    TBYTE PTR [eax+0x420]
    1374:	db 7d 90                	fstp   TBYTE PTR [ebp-0x70]
    1377:	db a8 30 04 00 00       	fld    TBYTE PTR [eax+0x430]
    137d:	db 7d 9c                	fstp   TBYTE PTR [ebp-0x64]
    1380:	db a8 40 04 00 00       	fld    TBYTE PTR [eax+0x440]
    1386:	db 7d a8                	fstp   TBYTE PTR [ebp-0x58]
    1389:	db a8 50 04 00 00       	fld    TBYTE PTR [eax+0x450]
    138f:	db 7d b4                	fstp   TBYTE PTR [ebp-0x4c]
    1392:	db a8 60 04 00 00       	fld    TBYTE PTR [eax+0x460]
    1398:	db 7d c0                	fstp   TBYTE PTR [ebp-0x40]

   long double *pldA = NULL;
    139b:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
   long double *pldB = NULL;
    13a2:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

   size_t        size = 0;
    13a9:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   ptrdiff_t distance = 0;
    13b0:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

   piA = &arrI[ 0 ];
    13b7:	8d 45 d4                	lea    eax,[ebp-0x2c]
    13ba:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
   piB = &arrI[ 1 ];
    13bd:	8d 45 d4                	lea    eax,[ebp-0x2c]
    13c0:	83 c0 04                	add    eax,0x4
    13c3:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax

   size = sizeof( int );
    13c6:	c7 45 ec 04 00 00 00    	mov    DWORD PTR [ebp-0x14],0x4
   distance = piA - piB;
    13cd:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    13d0:	2b 45 f8                	sub    eax,DWORD PTR [ebp-0x8]
    13d3:	c1 f8 02                	sar    eax,0x2
    13d6:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax


   pldA = &arrLD[ 0 ];
    13d9:	8d 45 90                	lea    eax,[ebp-0x70]
    13dc:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   pldB = &arrLD[ 1 ];
    13df:	8d 45 90                	lea    eax,[ebp-0x70]
    13e2:	83 c0 0c                	add    eax,0xc
    13e5:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

   size = sizeof( long double );
    13e8:	c7 45 ec 0c 00 00 00    	mov    DWORD PTR [ebp-0x14],0xc
   distance = pldA - pldB;
    13ef:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    13f2:	2b 45 f0                	sub    eax,DWORD PTR [ebp-0x10]
    13f5:	c1 f8 02                	sar    eax,0x2
    13f8:	69 c0 ab aa aa aa       	imul   eax,eax,0xaaaaaaab
    13fe:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

}//pointers4
    1401:	90                      	nop
    1402:	c9                      	leave  
    1403:	c3                      	ret    

00001404 <pointers5>:

//-----------------------------------------------------------------------------

void pointers5( void ) {
    1404:	55                      	push   ebp
    1405:	89 e5                   	mov    ebp,esp
    1407:	83 ec 20                	sub    esp,0x20
    140a:	e8 fc ff ff ff          	call   140b <pointers5+0x7>
    140f:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int arr[ 5 ] = { 10, 20, 30, 40, 50 };
    1414:	c7 45 e8 0a 00 00 00    	mov    DWORD PTR [ebp-0x18],0xa
    141b:	c7 45 ec 14 00 00 00    	mov    DWORD PTR [ebp-0x14],0x14
    1422:	c7 45 f0 1e 00 00 00    	mov    DWORD PTR [ebp-0x10],0x1e
    1429:	c7 45 f4 28 00 00 00    	mov    DWORD PTR [ebp-0xc],0x28
    1430:	c7 45 f8 32 00 00 00    	mov    DWORD PTR [ebp-0x8],0x32

   int *pi = NULL;
    1437:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0

   pi = arr;
    143e:	8d 45 e8                	lea    eax,[ebp-0x18]
    1441:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

   arr[ 0 ]   = 11;
    1444:	c7 45 e8 0b 00 00 00    	mov    DWORD PTR [ebp-0x18],0xb
   *(arr + 0) = 12;
    144b:	c7 45 e8 0c 00 00 00    	mov    DWORD PTR [ebp-0x18],0xc
   pi[ 0 ]    = 13;
    1452:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1455:	c7 00 0d 00 00 00       	mov    DWORD PTR [eax],0xd
   *(pi + 0)  = 14;
    145b:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    145e:	c7 00 0e 00 00 00       	mov    DWORD PTR [eax],0xe

   arr[ 1 ]   = 22;
    1464:	c7 45 ec 16 00 00 00    	mov    DWORD PTR [ebp-0x14],0x16
   *(arr + 1) = 23;
    146b:	c7 45 ec 17 00 00 00    	mov    DWORD PTR [ebp-0x14],0x17
   pi[ 1 ]    = 24;
    1472:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1475:	83 c0 04                	add    eax,0x4
    1478:	c7 00 18 00 00 00       	mov    DWORD PTR [eax],0x18
   *(pi + 1)  = 25;
    147e:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1481:	83 c0 04                	add    eax,0x4
    1484:	c7 00 19 00 00 00       	mov    DWORD PTR [eax],0x19

   arr[ 2 ]   = 33;
    148a:	c7 45 f0 21 00 00 00    	mov    DWORD PTR [ebp-0x10],0x21
   *(arr + 2) = 34;
    1491:	c7 45 f0 22 00 00 00    	mov    DWORD PTR [ebp-0x10],0x22
   pi[ 2 ]    = 35;
    1498:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    149b:	83 c0 08                	add    eax,0x8
    149e:	c7 00 23 00 00 00       	mov    DWORD PTR [eax],0x23
   *(pi + 2)  = 36;
    14a4:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    14a7:	83 c0 08                	add    eax,0x8
    14aa:	c7 00 24 00 00 00       	mov    DWORD PTR [eax],0x24

   arr[ 3 ]   = 44;
    14b0:	c7 45 f4 2c 00 00 00    	mov    DWORD PTR [ebp-0xc],0x2c
   *(arr + 3) = 45;
    14b7:	c7 45 f4 2d 00 00 00    	mov    DWORD PTR [ebp-0xc],0x2d
   pi[ 3 ]    = 46;
    14be:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    14c1:	83 c0 0c                	add    eax,0xc
    14c4:	c7 00 2e 00 00 00       	mov    DWORD PTR [eax],0x2e
   *(pi + 3)  = 47;
    14ca:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    14cd:	83 c0 0c                	add    eax,0xc
    14d0:	c7 00 2f 00 00 00       	mov    DWORD PTR [eax],0x2f

   arr[ 4 ]   = 55;
    14d6:	c7 45 f8 37 00 00 00    	mov    DWORD PTR [ebp-0x8],0x37
   *(arr + 4) = 56;
    14dd:	c7 45 f8 38 00 00 00    	mov    DWORD PTR [ebp-0x8],0x38
   pi[ 4 ]    = 57;
    14e4:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    14e7:	83 c0 10                	add    eax,0x10
    14ea:	c7 00 39 00 00 00       	mov    DWORD PTR [eax],0x39
   *(pi + 4)  = 58;
    14f0:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    14f3:	83 c0 10                	add    eax,0x10
    14f6:	c7 00 3a 00 00 00       	mov    DWORD PTR [eax],0x3a

}//pointers5
    14fc:	90                      	nop
    14fd:	c9                      	leave  
    14fe:	c3                      	ret    

000014ff <pointers6>:

//-----------------------------------------------------------------------------

void pointers6( void ) {
    14ff:	55                      	push   ebp
    1500:	89 e5                   	mov    ebp,esp
    1502:	53                      	push   ebx
    1503:	83 ec 14                	sub    esp,0x14
    1506:	e8 fc ff ff ff          	call   1507 <pointers6+0x8>
    150b:	81 c3 02 00 00 00       	add    ebx,0x2

   // see disassembly
   int *arr = NULL;
    1511:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   arr = malloc( 5 * sizeof(int) );
    1518:	83 ec 0c                	sub    esp,0xc
    151b:	6a 14                   	push   0x14
    151d:	e8 fc ff ff ff          	call   151e <pointers6+0x1f>
    1522:	83 c4 10                	add    esp,0x10
    1525:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   arr[ 0 ]   = 11;
    1528:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    152b:	c7 00 0b 00 00 00       	mov    DWORD PTR [eax],0xb
   *(arr + 0) = 12;
    1531:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1534:	c7 00 0c 00 00 00       	mov    DWORD PTR [eax],0xc

   arr[ 1 ]   = 22;
    153a:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    153d:	83 c0 04                	add    eax,0x4
    1540:	c7 00 16 00 00 00       	mov    DWORD PTR [eax],0x16
   *(arr + 1) = 23;
    1546:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1549:	83 c0 04                	add    eax,0x4
    154c:	c7 00 17 00 00 00       	mov    DWORD PTR [eax],0x17

   arr[ 2 ]   = 33;
    1552:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1555:	83 c0 08                	add    eax,0x8
    1558:	c7 00 21 00 00 00       	mov    DWORD PTR [eax],0x21
   *(arr + 2) = 34;
    155e:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1561:	83 c0 08                	add    eax,0x8
    1564:	c7 00 22 00 00 00       	mov    DWORD PTR [eax],0x22

   arr[ 3 ]   = 44;
    156a:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    156d:	83 c0 0c                	add    eax,0xc
    1570:	c7 00 2c 00 00 00       	mov    DWORD PTR [eax],0x2c
   *(arr + 3) = 45;
    1576:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1579:	83 c0 0c                	add    eax,0xc
    157c:	c7 00 2d 00 00 00       	mov    DWORD PTR [eax],0x2d

   arr[ 4 ]   = 55;
    1582:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1585:	83 c0 10                	add    eax,0x10
    1588:	c7 00 37 00 00 00       	mov    DWORD PTR [eax],0x37
   *(arr + 4) = 56;
    158e:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1591:	83 c0 10                	add    eax,0x10
    1594:	c7 00 38 00 00 00       	mov    DWORD PTR [eax],0x38

   free( arr );
    159a:	83 ec 0c                	sub    esp,0xc
    159d:	ff 75 f4                	push   DWORD PTR [ebp-0xc]
    15a0:	e8 fc ff ff ff          	call   15a1 <pointers6+0xa2>
    15a5:	83 c4 10                	add    esp,0x10

}//pointers6
    15a8:	90                      	nop
    15a9:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    15ac:	c9                      	leave  
    15ad:	c3                      	ret    

000015ae <pointersConstantPointers>:

//-----------------------------------------------------------------------------

void pointersConstantPointers( void ) {
    15ae:	55                      	push   ebp
    15af:	89 e5                   	mov    ebp,esp
    15b1:	83 ec 20                	sub    esp,0x20
    15b4:	e8 fc ff ff ff          	call   15b5 <pointersConstantPointers+0x7>
    15b9:	05 01 00 00 00          	add    eax,0x1

   int a = 0;
    15be:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   int b = 0;
    15c5:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

   // both same
   const int *pcA;
   int const *pcB;

   int *const cpi = &a;
    15cc:	8d 45 ec                	lea    eax,[ebp-0x14]
    15cf:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

   const int *const cpci = &a;
    15d2:	8d 45 ec                	lea    eax,[ebp-0x14]
    15d5:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax

   pcA = &a;
    15d8:	8d 45 ec                	lea    eax,[ebp-0x14]
    15db:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   pcB = &b;
    15de:	8d 45 e8                	lea    eax,[ebp-0x18]
    15e1:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   // *pcA = 3; // error
   // *pcB = 5; // error

   // cpi = &b; // error

}//pointersConstantPointers
    15e4:	90                      	nop
    15e5:	c9                      	leave  
    15e6:	c3                      	ret    

000015e7 <arrays>:

//-----------------------------------------------------------------------------

void arrays( void ) {
    15e7:	55                      	push   ebp
    15e8:	89 e5                   	mov    ebp,esp
    15ea:	81 ec c0 00 00 00       	sub    esp,0xc0
    15f0:	e8 fc ff ff ff          	call   15f1 <arrays+0xa>
    15f5:	05 01 00 00 00          	add    eax,0x1
   int arrA3[] = {};
   int arrB[ 0 ];
   int arrC[ 5 ];


   char lettersA[] = { 65, 66, 67, 68, 69 };
    15fa:	c7 45 df 41 42 43 44    	mov    DWORD PTR [ebp-0x21],0x44434241
    1601:	c6 45 e3 45             	mov    BYTE PTR [ebp-0x1d],0x45
   char lettersB[] = { 'A','B','C','D','E' };
    1605:	c7 45 da 41 42 43 44    	mov    DWORD PTR [ebp-0x26],0x44434241
    160c:	c6 45 de 45             	mov    BYTE PTR [ebp-0x22],0x45

   char stringA[] = { 'A','B','C','D','E', 0 };
    1610:	c7 45 d4 41 42 43 44    	mov    DWORD PTR [ebp-0x2c],0x44434241
    1617:	66 c7 45 d8 45 00       	mov    WORD PTR [ebp-0x28],0x45
   char stringB[] = { 'A','B','C','D','E', '\0' };
    161d:	c7 45 ce 41 42 43 44    	mov    DWORD PTR [ebp-0x32],0x44434241
    1624:	66 c7 45 d2 45 00       	mov    WORD PTR [ebp-0x2e],0x45
   char stringC[] = { "ABCDE" };
    162a:	c7 45 c8 41 42 43 44    	mov    DWORD PTR [ebp-0x38],0x44434241
    1631:	66 c7 45 cc 45 00       	mov    WORD PTR [ebp-0x34],0x45

   wchar_t unicodeA[] = { L'Ğ', L'Ü', L'Ş', L'İ', L'Ö', L'Ç', 0 };
    1637:	c7 45 ac 1e 01 00 00    	mov    DWORD PTR [ebp-0x54],0x11e
    163e:	c7 45 b0 dc 00 00 00    	mov    DWORD PTR [ebp-0x50],0xdc
    1645:	c7 45 b4 5e 01 00 00    	mov    DWORD PTR [ebp-0x4c],0x15e
    164c:	c7 45 b8 30 01 00 00    	mov    DWORD PTR [ebp-0x48],0x130
    1653:	c7 45 bc d6 00 00 00    	mov    DWORD PTR [ebp-0x44],0xd6
    165a:	c7 45 c0 c7 00 00 00    	mov    DWORD PTR [ebp-0x40],0xc7
    1661:	c7 45 c4 00 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x0
   wchar_t unicodeB[] = L"ĞÜŞİÖÇ";
    1668:	c7 45 90 1e 01 00 00    	mov    DWORD PTR [ebp-0x70],0x11e
    166f:	c7 45 94 dc 00 00 00    	mov    DWORD PTR [ebp-0x6c],0xdc
    1676:	c7 45 98 5e 01 00 00    	mov    DWORD PTR [ebp-0x68],0x15e
    167d:	c7 45 9c 30 01 00 00    	mov    DWORD PTR [ebp-0x64],0x130
    1684:	c7 45 a0 d6 00 00 00    	mov    DWORD PTR [ebp-0x60],0xd6
    168b:	c7 45 a4 c7 00 00 00    	mov    DWORD PTR [ebp-0x5c],0xc7
    1692:	c7 45 a8 00 00 00 00    	mov    DWORD PTR [ebp-0x58],0x0

   int arrQ[ 2 ] = { 1, 2, 3 }; // initialize the first 2, discard the 3rd.
    1699:	c7 45 88 01 00 00 00    	mov    DWORD PTR [ebp-0x78],0x1
    16a0:	c7 45 8c 02 00 00 00    	mov    DWORD PTR [ebp-0x74],0x2
   int arrW[ 3 ] = { 1, 2, 3 }; // initialize all.
    16a7:	c7 85 7c ff ff ff 01 00 	mov    DWORD PTR [ebp-0x84],0x1
    16af:	00 00 
    16b1:	c7 45 80 02 00 00 00    	mov    DWORD PTR [ebp-0x80],0x2
    16b8:	c7 45 84 03 00 00 00    	mov    DWORD PTR [ebp-0x7c],0x3
   int arrX[ 4 ] = { 1, 2, 3 }; // initialize the first 3, leave 4th uninitialized.
    16bf:	c7 85 6c ff ff ff 00 00 	mov    DWORD PTR [ebp-0x94],0x0
    16c7:	00 00 
    16c9:	c7 85 70 ff ff ff 00 00 	mov    DWORD PTR [ebp-0x90],0x0
    16d1:	00 00 
    16d3:	c7 85 74 ff ff ff 00 00 	mov    DWORD PTR [ebp-0x8c],0x0
    16db:	00 00 
    16dd:	c7 85 78 ff ff ff 00 00 	mov    DWORD PTR [ebp-0x88],0x0
    16e5:	00 00 
    16e7:	c7 85 6c ff ff ff 01 00 	mov    DWORD PTR [ebp-0x94],0x1
    16ef:	00 00 
    16f1:	c7 85 70 ff ff ff 02 00 	mov    DWORD PTR [ebp-0x90],0x2
    16f9:	00 00 
    16fb:	c7 85 74 ff ff ff 03 00 	mov    DWORD PTR [ebp-0x8c],0x3
    1703:	00 00 
   int arrY[ 5 ] = { [2] = 30 };// initialize the 3rd. initialize the rest with zero.
    1705:	c7 85 58 ff ff ff 00 00 	mov    DWORD PTR [ebp-0xa8],0x0
    170d:	00 00 
    170f:	c7 85 5c ff ff ff 00 00 	mov    DWORD PTR [ebp-0xa4],0x0
    1717:	00 00 
    1719:	c7 85 60 ff ff ff 00 00 	mov    DWORD PTR [ebp-0xa0],0x0
    1721:	00 00 
    1723:	c7 85 64 ff ff ff 00 00 	mov    DWORD PTR [ebp-0x9c],0x0
    172b:	00 00 
    172d:	c7 85 68 ff ff ff 00 00 	mov    DWORD PTR [ebp-0x98],0x0
    1735:	00 00 
    1737:	c7 85 60 ff ff ff 1e 00 	mov    DWORD PTR [ebp-0xa0],0x1e
    173f:	00 00 
   int arrZ[ 5 ] = {};          // initialize all with zero.
    1741:	c7 85 44 ff ff ff 00 00 	mov    DWORD PTR [ebp-0xbc],0x0
    1749:	00 00 
    174b:	c7 85 48 ff ff ff 00 00 	mov    DWORD PTR [ebp-0xb8],0x0
    1753:	00 00 
    1755:	c7 85 4c ff ff ff 00 00 	mov    DWORD PTR [ebp-0xb4],0x0
    175d:	00 00 
    175f:	c7 85 50 ff ff ff 00 00 	mov    DWORD PTR [ebp-0xb0],0x0
    1767:	00 00 
    1769:	c7 85 54 ff ff ff 00 00 	mov    DWORD PTR [ebp-0xac],0x0
    1771:	00 00 

   size_t size = 0;
    1773:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
   int count   = 0;
    177a:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0

   size = sizeof( arrA1 );
    1781:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
   size = sizeof( arrB );
    1788:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0

   size  = sizeof( arrC );
    178f:	c7 45 fc 14 00 00 00    	mov    DWORD PTR [ebp-0x4],0x14
   size  = sizeof arrC;
    1796:	c7 45 fc 14 00 00 00    	mov    DWORD PTR [ebp-0x4],0x14
   count = sizeof( arrC ) / sizeof( int );
    179d:	c7 45 f8 05 00 00 00    	mov    DWORD PTR [ebp-0x8],0x5

   size = sizeof( lettersA );
    17a4:	c7 45 fc 05 00 00 00    	mov    DWORD PTR [ebp-0x4],0x5
   size = sizeof( lettersB );
    17ab:	c7 45 fc 05 00 00 00    	mov    DWORD PTR [ebp-0x4],0x5

   size = sizeof( stringA );
    17b2:	c7 45 fc 06 00 00 00    	mov    DWORD PTR [ebp-0x4],0x6
   size = sizeof( stringB );
    17b9:	c7 45 fc 06 00 00 00    	mov    DWORD PTR [ebp-0x4],0x6
   size = sizeof( stringC );
    17c0:	c7 45 fc 06 00 00 00    	mov    DWORD PTR [ebp-0x4],0x6

   size = sizeof( wchar_t );
    17c7:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [ebp-0x4],0x4
   size = sizeof( unicodeA );
    17ce:	c7 45 fc 1c 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1c

   size  = sizeof( unicodeB );
    17d5:	c7 45 fc 1c 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1c
   count = sizeof( unicodeB ) / sizeof( wchar_t );
    17dc:	c7 45 f8 07 00 00 00    	mov    DWORD PTR [ebp-0x8],0x7

   size = sizeof( arrW );
    17e3:	c7 45 fc 0c 00 00 00    	mov    DWORD PTR [ebp-0x4],0xc
   size = sizeof( arrX );
    17ea:	c7 45 fc 10 00 00 00    	mov    DWORD PTR [ebp-0x4],0x10
   size = sizeof( arrY );
    17f1:	c7 45 fc 14 00 00 00    	mov    DWORD PTR [ebp-0x4],0x14

   size = sizeof stringB;
    17f8:	c7 45 fc 06 00 00 00    	mov    DWORD PTR [ebp-0x4],0x6
   size = sizeof( arrX );
    17ff:	c7 45 fc 10 00 00 00    	mov    DWORD PTR [ebp-0x4],0x10
   size = sizeof( arrY );
    1806:	c7 45 fc 14 00 00 00    	mov    DWORD PTR [ebp-0x4],0x14

   size  = sizeof( arrC );
    180d:	c7 45 fc 14 00 00 00    	mov    DWORD PTR [ebp-0x4],0x14
   size  = sizeof arrC;
    1814:	c7 45 fc 14 00 00 00    	mov    DWORD PTR [ebp-0x4],0x14


   arrA1[ 0 ] = 1;
    181b:	c7 45 f8 01 00 00 00    	mov    DWORD PTR [ebp-0x8],0x1
   arrA2[ 0 ] = 2;
    1822:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
   arrA3[ 0 ] = 3;
    1829:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
   arrB[ 0 ]  = 1;
    1830:	c7 45 f8 01 00 00 00    	mov    DWORD PTR [ebp-0x8],0x1

   arrC[ 0 ] = 10;
    1837:	c7 45 e4 0a 00 00 00    	mov    DWORD PTR [ebp-0x1c],0xa
   arrC[ 1 ] = 20;
    183e:	c7 45 e8 14 00 00 00    	mov    DWORD PTR [ebp-0x18],0x14

   stringC[0] = 'F';
    1845:	c6 45 c8 46             	mov    BYTE PTR [ebp-0x38],0x46

}//arrays
    1849:	90                      	nop
    184a:	c9                      	leave  
    184b:	c3                      	ret    

0000184c <everyIdentifierHasAnAddress>:

//-----------------------------------------------------------------------------

void everyIdentifierHasAnAddress( void ) {
    184c:	55                      	push   ebp
    184d:	89 e5                   	mov    ebp,esp
    184f:	83 ec 60                	sub    esp,0x60
    1852:	e8 fc ff ff ff          	call   1853 <everyIdentifierHasAnAddress+0x7>
    1857:	05 01 00 00 00          	add    eax,0x1

   int a = 2;
    185c:	c7 45 ec 02 00 00 00    	mov    DWORD PTR [ebp-0x14],0x2
   int b = 3;
    1863:	c7 45 e8 03 00 00 00    	mov    DWORD PTR [ebp-0x18],0x3
   int c = 0;
    186a:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0

   int size = sizeof( int );
    1871:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [ebp-0x8],0x4
   size = sizeof( c );
    1878:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [ebp-0x8],0x4

   int arrA[] = { 10, 20, 30, 40, 50 };
    187f:	c7 45 d4 0a 00 00 00    	mov    DWORD PTR [ebp-0x2c],0xa
    1886:	c7 45 d8 14 00 00 00    	mov    DWORD PTR [ebp-0x28],0x14
    188d:	c7 45 dc 1e 00 00 00    	mov    DWORD PTR [ebp-0x24],0x1e
    1894:	c7 45 e0 28 00 00 00    	mov    DWORD PTR [ebp-0x20],0x28
    189b:	c7 45 e4 32 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x32
   int arrB[] = { 10, 20, 30, 40, 50 };
    18a2:	c7 45 c0 0a 00 00 00    	mov    DWORD PTR [ebp-0x40],0xa
    18a9:	c7 45 c4 14 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x14
    18b0:	c7 45 c8 1e 00 00 00    	mov    DWORD PTR [ebp-0x38],0x1e
    18b7:	c7 45 cc 28 00 00 00    	mov    DWORD PTR [ebp-0x34],0x28
    18be:	c7 45 d0 32 00 00 00    	mov    DWORD PTR [ebp-0x30],0x32
   int arrC[] = { 10, 20, 30, 40, 50 };
    18c5:	c7 45 ac 0a 00 00 00    	mov    DWORD PTR [ebp-0x54],0xa
    18cc:	c7 45 b0 14 00 00 00    	mov    DWORD PTR [ebp-0x50],0x14
    18d3:	c7 45 b4 1e 00 00 00    	mov    DWORD PTR [ebp-0x4c],0x1e
    18da:	c7 45 b8 28 00 00 00    	mov    DWORD PTR [ebp-0x48],0x28
    18e1:	c7 45 bc 32 00 00 00    	mov    DWORD PTR [ebp-0x44],0x32

   int *arrD  = { 10, 20, 30, 40, 50 };// !!
    18e8:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [ebp-0xc],0xa

   size = sizeof( arrC );
    18ef:	c7 45 f8 14 00 00 00    	mov    DWORD PTR [ebp-0x8],0x14
   size = sizeof( arrD );
    18f6:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [ebp-0x8],0x4

   int i = 2;
    18fd:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [ebp-0x10],0x2
   c = arrA[ i ];
    1904:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
    1907:	8b 54 95 d4             	mov    edx,DWORD PTR [ebp+edx*4-0x2c]
    190b:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
   c = arrA[ 2 ];
    190e:	8b 55 dc                	mov    edx,DWORD PTR [ebp-0x24]
    1911:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
   c = i[ arrA ];
    1914:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
    1917:	8b 54 95 d4             	mov    edx,DWORD PTR [ebp+edx*4-0x2c]
    191b:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
   c = 2[ arrA ];
    191e:	8b 55 dc                	mov    edx,DWORD PTR [ebp-0x24]
    1921:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx

   c = arrA[ 0 ];
    1924:	8b 55 d4                	mov    edx,DWORD PTR [ebp-0x2c]
    1927:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
   c = arrD[ 0 ];
    192a:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    192d:	8b 12                   	mov    edx,DWORD PTR [edx]
    192f:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx

   c = arrA[ 2 ];
    1932:	8b 55 dc                	mov    edx,DWORD PTR [ebp-0x24]
    1935:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
   //c = arrD[ 2 ];//!!

   c = arrays - everyIdentifierHasAnAddress;
    1938:	8d 90 00 00 00 00       	lea    edx,[eax+0x0]
    193e:	8d 88 00 00 00 00       	lea    ecx,[eax+0x0]
    1944:	89 d0                   	mov    eax,edx
    1946:	29 c8                   	sub    eax,ecx
    1948:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
   c = &b - &a;
    194b:	8d 45 e8                	lea    eax,[ebp-0x18]
    194e:	8d 55 ec                	lea    edx,[ebp-0x14]
    1951:	29 d0                   	sub    eax,edx
    1953:	c1 f8 02                	sar    eax,0x2
    1956:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
   c = (void*)&b - (void*)&a;
    1959:	8d 45 e8                	lea    eax,[ebp-0x18]
    195c:	8d 55 ec                	lea    edx,[ebp-0x14]
    195f:	29 d0                   	sub    eax,edx
    1961:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

}//everyIdentifierHasAnAddress
    1964:	90                      	nop
    1965:	c9                      	leave  
    1966:	c3                      	ret    

00001967 <controlFlow_if>:

//-----------------------------------------------------------------------------

void controlFlow_if() {
    1967:	55                      	push   ebp
    1968:	89 e5                   	mov    ebp,esp
    196a:	83 ec 20                	sub    esp,0x20
    196d:	e8 fc ff ff ff          	call   196e <controlFlow_if+0x7>
    1972:	05 01 00 00 00          	add    eax,0x1

   int a = 2;
    1977:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
   int b = 3;
    197e:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
   int c = 0;
    1985:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   _Bool result = a < b;
    198c:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    198f:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
    1992:	0f 9c c0                	setl   al
    1995:	88 45 f3                	mov    BYTE PTR [ebp-0xd],al

   if ( result )
    1998:	80 7d f3 00             	cmp    BYTE PTR [ebp-0xd],0x0
    199c:	74 09                   	je     19a7 <controlFlow_if+0x40>
      c = 1;
    199e:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1
    19a5:	eb 07                   	jmp    19ae <controlFlow_if+0x47>
   else
	  c = 0;
    19a7:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   if ( a < b )
    19ae:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    19b1:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
    19b4:	7d 09                   	jge    19bf <controlFlow_if+0x58>
      c = 1;
    19b6:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1
    19bd:	eb 07                   	jmp    19c6 <controlFlow_if+0x5f>
   else
	  c = 0;
    19bf:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   if ( !(a < b) )
    19c6:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    19c9:	3b 45 f8                	cmp    eax,DWORD PTR [ebp-0x8]
    19cc:	7c 07                   	jl     19d5 <controlFlow_if+0x6e>
      c = 0;
    19ce:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0


   enum { colder, cold, warm, hot, hotter } climate = colder;
    19d5:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0

   c = 18;
    19dc:	c7 45 f4 12 00 00 00    	mov    DWORD PTR [ebp-0xc],0x12

   // if ladder
   if ( c <= -10 ) {
    19e3:	83 7d f4 f7             	cmp    DWORD PTR [ebp-0xc],0xfffffff7
    19e7:	7d 09                   	jge    19f2 <controlFlow_if+0x8b>

	  climate = colder;
    19e9:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
    19f0:	eb 46                   	jmp    1a38 <controlFlow_if+0xd1>

   } else if ( ( c > -10 ) && ( c <= 10 ) ) {
    19f2:	83 7d f4 f7             	cmp    DWORD PTR [ebp-0xc],0xfffffff7
    19f6:	7c 0f                   	jl     1a07 <controlFlow_if+0xa0>
    19f8:	83 7d f4 0a             	cmp    DWORD PTR [ebp-0xc],0xa
    19fc:	7f 09                   	jg     1a07 <controlFlow_if+0xa0>

	   climate = cold;
    19fe:	c7 45 ec 01 00 00 00    	mov    DWORD PTR [ebp-0x14],0x1
    1a05:	eb 31                   	jmp    1a38 <controlFlow_if+0xd1>

   } else if ( ( c >  10 ) && ( c <= 25 ) ) {
    1a07:	83 7d f4 0a             	cmp    DWORD PTR [ebp-0xc],0xa
    1a0b:	7e 0f                   	jle    1a1c <controlFlow_if+0xb5>
    1a0d:	83 7d f4 19             	cmp    DWORD PTR [ebp-0xc],0x19
    1a11:	7f 09                   	jg     1a1c <controlFlow_if+0xb5>

	   climate = warm;
    1a13:	c7 45 ec 02 00 00 00    	mov    DWORD PTR [ebp-0x14],0x2
    1a1a:	eb 1c                   	jmp    1a38 <controlFlow_if+0xd1>

   } else if ( ( c >  25 ) && ( c <= 35 ) ) {
    1a1c:	83 7d f4 19             	cmp    DWORD PTR [ebp-0xc],0x19
    1a20:	7e 0f                   	jle    1a31 <controlFlow_if+0xca>
    1a22:	83 7d f4 23             	cmp    DWORD PTR [ebp-0xc],0x23
    1a26:	7f 09                   	jg     1a31 <controlFlow_if+0xca>

	   climate = hot;
    1a28:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [ebp-0x14],0x3
    1a2f:	eb 07                   	jmp    1a38 <controlFlow_if+0xd1>

   } else {

	   climate = hotter;
    1a31:	c7 45 ec 04 00 00 00    	mov    DWORD PTR [ebp-0x14],0x4

   }//if

   // if-ladder switch case alternative
   climate = ( c <= -10 ) ? colder :
    1a38:	83 7d f4 f7             	cmp    DWORD PTR [ebp-0xc],0xfffffff7
    1a3c:	7c 40                   	jl     1a7e <controlFlow_if+0x117>
    1a3e:	83 7d f4 f7             	cmp    DWORD PTR [ebp-0xc],0xfffffff7
    1a42:	7c 06                   	jl     1a4a <controlFlow_if+0xe3>
             ( c > -10 ) && ( c <= 10 ) ? cold :
    1a44:	83 7d f4 0a             	cmp    DWORD PTR [ebp-0xc],0xa
    1a48:	7e 2d                   	jle    1a77 <controlFlow_if+0x110>
   climate = ( c <= -10 ) ? colder :
    1a4a:	83 7d f4 0a             	cmp    DWORD PTR [ebp-0xc],0xa
    1a4e:	7e 06                   	jle    1a56 <controlFlow_if+0xef>
             ( c >  10 ) && ( c <= 25 ) ? warm :
    1a50:	83 7d f4 19             	cmp    DWORD PTR [ebp-0xc],0x19
    1a54:	7e 1a                   	jle    1a70 <controlFlow_if+0x109>
   climate = ( c <= -10 ) ? colder :
    1a56:	83 7d f4 19             	cmp    DWORD PTR [ebp-0xc],0x19
    1a5a:	7e 0d                   	jle    1a69 <controlFlow_if+0x102>
             ( c >  25 ) && ( c <= 35 ) ? hot  :
    1a5c:	83 7d f4 23             	cmp    DWORD PTR [ebp-0xc],0x23
    1a60:	7f 07                   	jg     1a69 <controlFlow_if+0x102>
   climate = ( c <= -10 ) ? colder :
    1a62:	b8 03 00 00 00          	mov    eax,0x3
    1a67:	eb 1a                   	jmp    1a83 <controlFlow_if+0x11c>
    1a69:	b8 04 00 00 00          	mov    eax,0x4
    1a6e:	eb 13                   	jmp    1a83 <controlFlow_if+0x11c>
    1a70:	b8 02 00 00 00          	mov    eax,0x2
    1a75:	eb 0c                   	jmp    1a83 <controlFlow_if+0x11c>
    1a77:	b8 01 00 00 00          	mov    eax,0x1
    1a7c:	eb 05                   	jmp    1a83 <controlFlow_if+0x11c>
    1a7e:	b8 00 00 00 00          	mov    eax,0x0
    1a83:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax
             hotter;


}//controlFlow_if
    1a86:	90                      	nop
    1a87:	c9                      	leave  
    1a88:	c3                      	ret    

00001a89 <controlFlow_Switch>:

//-----------------------------------------------------------------------------

void controlFlow_Switch() {
    1a89:	55                      	push   ebp
    1a8a:	89 e5                   	mov    ebp,esp
    1a8c:	83 ec 10                	sub    esp,0x10
    1a8f:	e8 fc ff ff ff          	call   1a90 <controlFlow_Switch+0x7>
    1a94:	05 01 00 00 00          	add    eax,0x1

   int  value = 3;
    1a99:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [ebp-0x4],0x3
   char rating = 'X';
    1aa0:	c6 45 fb 58             	mov    BYTE PTR [ebp-0x5],0x58

   // fall-through switch
   switch( value ) {
    1aa4:	83 7d fc 0a             	cmp    DWORD PTR [ebp-0x4],0xa
    1aa8:	7f 45                   	jg     1aef <controlFlow_Switch+0x66>
    1aaa:	83 7d fc 09             	cmp    DWORD PTR [ebp-0x4],0x9
    1aae:	7d 39                   	jge    1ae9 <controlFlow_Switch+0x60>
    1ab0:	83 7d fc 08             	cmp    DWORD PTR [ebp-0x4],0x8
    1ab4:	7f 39                   	jg     1aef <controlFlow_Switch+0x66>
    1ab6:	83 7d fc 06             	cmp    DWORD PTR [ebp-0x4],0x6
    1aba:	7d 27                   	jge    1ae3 <controlFlow_Switch+0x5a>
    1abc:	83 7d fc 02             	cmp    DWORD PTR [ebp-0x4],0x2
    1ac0:	7f 08                   	jg     1aca <controlFlow_Switch+0x41>
    1ac2:	83 7d fc 00             	cmp    DWORD PTR [ebp-0x4],0x0
    1ac6:	79 0f                   	jns    1ad7 <controlFlow_Switch+0x4e>
    1ac8:	eb 25                   	jmp    1aef <controlFlow_Switch+0x66>
    1aca:	8b 55 fc                	mov    edx,DWORD PTR [ebp-0x4]
    1acd:	83 ea 03                	sub    edx,0x3
    1ad0:	83 fa 02                	cmp    edx,0x2
    1ad3:	77 1a                   	ja     1aef <controlFlow_Switch+0x66>
    1ad5:	eb 06                   	jmp    1add <controlFlow_Switch+0x54>

	   case 0 :
	   case 1 :
	   case 2 :
		   rating = 'D';
    1ad7:	c6 45 fb 44             	mov    BYTE PTR [ebp-0x5],0x44
		   break;
    1adb:	eb 16                   	jmp    1af3 <controlFlow_Switch+0x6a>

	   case 3 :
	   case 4 :
	   case 5 :
		   rating = 'C';
    1add:	c6 45 fb 43             	mov    BYTE PTR [ebp-0x5],0x43
	   break;
    1ae1:	eb 10                   	jmp    1af3 <controlFlow_Switch+0x6a>

	   case 6 :
	   case 7 :
	   case 8 :
		   rating = 'B';
    1ae3:	c6 45 fb 42             	mov    BYTE PTR [ebp-0x5],0x42
		   break;
    1ae7:	eb 0a                   	jmp    1af3 <controlFlow_Switch+0x6a>

	   case 9 :
	   case 10 :
		   rating = 'A';
    1ae9:	c6 45 fb 41             	mov    BYTE PTR [ebp-0x5],0x41
		   break;
    1aed:	eb 04                   	jmp    1af3 <controlFlow_Switch+0x6a>

	   default :
		   rating = 'X';
    1aef:	c6 45 fb 58             	mov    BYTE PTR [ebp-0x5],0x58

   }//switch

	enum { colder, cold, warm, hot, hotter } climate = cold;
    1af3:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1
	wchar_t* text = "bilinmiyor";
    1afa:	8d 90 44 00 00 00       	lea    edx,[eax+0x44]
    1b00:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
    1b03:	83 7d f4 04             	cmp    DWORD PTR [ebp-0xc],0x4
    1b07:	77 47                   	ja     1b50 <.L98+0xa>
    1b09:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    1b0c:	c1 e2 02                	shl    edx,0x2
    1b0f:	8b 94 02 e4 00 00 00    	mov    edx,DWORD PTR [edx+eax*1+0xe4]
    1b16:	01 c2                   	add    edx,eax
    1b18:	ff e2                   	jmp    edx

00001b1a <.L103>:

	// switch without default
	switch ( climate ) {
		case colder : text = L"çok soğuk"; break;
    1b1a:	8d 80 50 00 00 00       	lea    eax,[eax+0x50]
    1b20:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    1b23:	eb 2b                   	jmp    1b50 <.L98+0xa>

00001b25 <.L102>:
		case cold   : text = L"soğuk";     break;
    1b25:	8d 80 78 00 00 00       	lea    eax,[eax+0x78]
    1b2b:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    1b2e:	eb 20                   	jmp    1b50 <.L98+0xa>

00001b30 <.L101>:
		case warm   : text = L"ılık";      break;
    1b30:	8d 80 90 00 00 00       	lea    eax,[eax+0x90]
    1b36:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    1b39:	eb 15                   	jmp    1b50 <.L98+0xa>

00001b3b <.L100>:
		case hot    : text = L"sıcak";     break;
    1b3b:	8d 80 a4 00 00 00       	lea    eax,[eax+0xa4]
    1b41:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    1b44:	eb 0a                   	jmp    1b50 <.L98+0xa>

00001b46 <.L98>:
		case hotter : text = L"çok sıcak"; break;
    1b46:	8d 80 bc 00 00 00       	lea    eax,[eax+0xbc]
    1b4c:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    1b4f:	90                      	nop
	};

}//controlFlow_Switch
    1b50:	90                      	nop
    1b51:	c9                      	leave  
    1b52:	c3                      	ret    

00001b53 <sinus>:
//-----------------------------------------------------------------------------

/*
 * switch sample : lookup table
 */
float sinus( int angle ) {
    1b53:	55                      	push   ebp
    1b54:	89 e5                   	mov    ebp,esp
    1b56:	e8 fc ff ff ff          	call   1b57 <sinus+0x4>
    1b5b:	05 01 00 00 00          	add    eax,0x1

	// TODO : process sign 0..360 degrees
	angle = angle > 45 ? 90 - angle : angle;
    1b60:	83 7d 08 2d             	cmp    DWORD PTR [ebp+0x8],0x2d
    1b64:	7e 0a                   	jle    1b70 <sinus+0x1d>
    1b66:	ba 5a 00 00 00          	mov    edx,0x5a
    1b6b:	2b 55 08                	sub    edx,DWORD PTR [ebp+0x8]
    1b6e:	eb 03                   	jmp    1b73 <sinus+0x20>
    1b70:	8b 55 08                	mov    edx,DWORD PTR [ebp+0x8]
    1b73:	89 55 08                	mov    DWORD PTR [ebp+0x8],edx
    1b76:	83 7d 08 2d             	cmp    DWORD PTR [ebp+0x8],0x2d
    1b7a:	77 11                   	ja     1b8d <sinus+0x3a>
    1b7c:	8b 55 08                	mov    edx,DWORD PTR [ebp+0x8]
    1b7f:	c1 e2 02                	shl    edx,0x2
    1b82:	8b 94 02 f8 00 00 00    	mov    edx,DWORD PTR [edx+eax*1+0xf8]
    1b89:	01 c2                   	add    edx,eax
    1b8b:	ff e2                   	jmp    edx

	switch( angle ) {

    	default : return NAN;
    1b8d:	d9 80 cc 03 00 00       	fld    DWORD PTR [eax+0x3cc]
    1b93:	e9 c1 01 00 00          	jmp    1d59 <.L110+0x6>

00001b98 <.L156>:

	    case 0  : return .0000;
    1b98:	d9 ee                   	fldz   
    1b9a:	e9 ba 01 00 00          	jmp    1d59 <.L110+0x6>

00001b9f <.L155>:
		case 1  : return .0175;
    1b9f:	d9 80 6c 04 00 00       	fld    DWORD PTR [eax+0x46c]
    1ba5:	e9 af 01 00 00          	jmp    1d59 <.L110+0x6>

00001baa <.L154>:
		case 2  : return .0349;
    1baa:	d9 80 70 04 00 00       	fld    DWORD PTR [eax+0x470]
    1bb0:	e9 a4 01 00 00          	jmp    1d59 <.L110+0x6>

00001bb5 <.L153>:
		case 3  : return .0523;
    1bb5:	d9 80 74 04 00 00       	fld    DWORD PTR [eax+0x474]
    1bbb:	e9 99 01 00 00          	jmp    1d59 <.L110+0x6>

00001bc0 <.L152>:
		case 4  : return .0698;
    1bc0:	d9 80 78 04 00 00       	fld    DWORD PTR [eax+0x478]
    1bc6:	e9 8e 01 00 00          	jmp    1d59 <.L110+0x6>

00001bcb <.L151>:
		case 5  : return .0872;
    1bcb:	d9 80 7c 04 00 00       	fld    DWORD PTR [eax+0x47c]
    1bd1:	e9 83 01 00 00          	jmp    1d59 <.L110+0x6>

00001bd6 <.L150>:
		case 6  : return .1045;
    1bd6:	d9 80 80 04 00 00       	fld    DWORD PTR [eax+0x480]
    1bdc:	e9 78 01 00 00          	jmp    1d59 <.L110+0x6>

00001be1 <.L149>:
		case 7  : return .1219;
    1be1:	d9 80 84 04 00 00       	fld    DWORD PTR [eax+0x484]
    1be7:	e9 6d 01 00 00          	jmp    1d59 <.L110+0x6>

00001bec <.L148>:
		case 8  : return .1392;
    1bec:	d9 80 88 04 00 00       	fld    DWORD PTR [eax+0x488]
    1bf2:	e9 62 01 00 00          	jmp    1d59 <.L110+0x6>

00001bf7 <.L147>:
		case 9  : return .1564;
    1bf7:	d9 80 8c 04 00 00       	fld    DWORD PTR [eax+0x48c]
    1bfd:	e9 57 01 00 00          	jmp    1d59 <.L110+0x6>

00001c02 <.L146>:
		case 10 : return .1736;
    1c02:	d9 80 90 04 00 00       	fld    DWORD PTR [eax+0x490]
    1c08:	e9 4c 01 00 00          	jmp    1d59 <.L110+0x6>

00001c0d <.L145>:
		case 11 : return .1908;
    1c0d:	d9 80 94 04 00 00       	fld    DWORD PTR [eax+0x494]
    1c13:	e9 41 01 00 00          	jmp    1d59 <.L110+0x6>

00001c18 <.L144>:
		case 12 : return .2079;
    1c18:	d9 80 98 04 00 00       	fld    DWORD PTR [eax+0x498]
    1c1e:	e9 36 01 00 00          	jmp    1d59 <.L110+0x6>

00001c23 <.L143>:
		case 13 : return .2250;
    1c23:	d9 80 9c 04 00 00       	fld    DWORD PTR [eax+0x49c]
    1c29:	e9 2b 01 00 00          	jmp    1d59 <.L110+0x6>

00001c2e <.L142>:
		case 14 : return .2419;
    1c2e:	d9 80 a0 04 00 00       	fld    DWORD PTR [eax+0x4a0]
    1c34:	e9 20 01 00 00          	jmp    1d59 <.L110+0x6>

00001c39 <.L141>:
		case 15 : return .2588;
    1c39:	d9 80 a4 04 00 00       	fld    DWORD PTR [eax+0x4a4]
    1c3f:	e9 15 01 00 00          	jmp    1d59 <.L110+0x6>

00001c44 <.L140>:
		case 16 : return .2756;
    1c44:	d9 80 a8 04 00 00       	fld    DWORD PTR [eax+0x4a8]
    1c4a:	e9 0a 01 00 00          	jmp    1d59 <.L110+0x6>

00001c4f <.L139>:
		case 17 : return .2924;
    1c4f:	d9 80 ac 04 00 00       	fld    DWORD PTR [eax+0x4ac]
    1c55:	e9 ff 00 00 00          	jmp    1d59 <.L110+0x6>

00001c5a <.L138>:
		case 18 : return .3090;
    1c5a:	d9 80 b0 04 00 00       	fld    DWORD PTR [eax+0x4b0]
    1c60:	e9 f4 00 00 00          	jmp    1d59 <.L110+0x6>

00001c65 <.L137>:
		case 19 : return .3256;
    1c65:	d9 80 b4 04 00 00       	fld    DWORD PTR [eax+0x4b4]
    1c6b:	e9 e9 00 00 00          	jmp    1d59 <.L110+0x6>

00001c70 <.L136>:
		case 20 : return .3420;
    1c70:	d9 80 b8 04 00 00       	fld    DWORD PTR [eax+0x4b8]
    1c76:	e9 de 00 00 00          	jmp    1d59 <.L110+0x6>

00001c7b <.L135>:
		case 21 : return .3584;
    1c7b:	d9 80 bc 04 00 00       	fld    DWORD PTR [eax+0x4bc]
    1c81:	e9 d3 00 00 00          	jmp    1d59 <.L110+0x6>

00001c86 <.L134>:
		case 22 : return .3746;
    1c86:	d9 80 c0 04 00 00       	fld    DWORD PTR [eax+0x4c0]
    1c8c:	e9 c8 00 00 00          	jmp    1d59 <.L110+0x6>

00001c91 <.L133>:
		case 23 : return .3907;
    1c91:	d9 80 c4 04 00 00       	fld    DWORD PTR [eax+0x4c4]
    1c97:	e9 bd 00 00 00          	jmp    1d59 <.L110+0x6>

00001c9c <.L132>:
		case 24 : return .4067;
    1c9c:	d9 80 c8 04 00 00       	fld    DWORD PTR [eax+0x4c8]
    1ca2:	e9 b2 00 00 00          	jmp    1d59 <.L110+0x6>

00001ca7 <.L131>:
		case 25 : return .4226;
    1ca7:	d9 80 cc 04 00 00       	fld    DWORD PTR [eax+0x4cc]
    1cad:	e9 a7 00 00 00          	jmp    1d59 <.L110+0x6>

00001cb2 <.L130>:
		case 26 : return .4384;
    1cb2:	d9 80 d0 04 00 00       	fld    DWORD PTR [eax+0x4d0]
    1cb8:	e9 9c 00 00 00          	jmp    1d59 <.L110+0x6>

00001cbd <.L129>:
		case 27 : return .4540;
    1cbd:	d9 80 d4 04 00 00       	fld    DWORD PTR [eax+0x4d4]
    1cc3:	e9 91 00 00 00          	jmp    1d59 <.L110+0x6>

00001cc8 <.L128>:
		case 28 : return .4695;
    1cc8:	d9 80 d8 04 00 00       	fld    DWORD PTR [eax+0x4d8]
    1cce:	e9 86 00 00 00          	jmp    1d59 <.L110+0x6>

00001cd3 <.L127>:
		case 29 : return .4848;
    1cd3:	d9 80 dc 04 00 00       	fld    DWORD PTR [eax+0x4dc]
    1cd9:	eb 7e                   	jmp    1d59 <.L110+0x6>

00001cdb <.L126>:
		case 30 : return .5000;
    1cdb:	d9 80 f0 03 00 00       	fld    DWORD PTR [eax+0x3f0]
    1ce1:	eb 76                   	jmp    1d59 <.L110+0x6>

00001ce3 <.L125>:
		case 31 : return .5150;
    1ce3:	d9 80 e0 04 00 00       	fld    DWORD PTR [eax+0x4e0]
    1ce9:	eb 6e                   	jmp    1d59 <.L110+0x6>

00001ceb <.L124>:
		case 32 : return .5299;
    1ceb:	d9 80 e4 04 00 00       	fld    DWORD PTR [eax+0x4e4]
    1cf1:	eb 66                   	jmp    1d59 <.L110+0x6>

00001cf3 <.L123>:
		case 33 : return .5446;
    1cf3:	d9 80 e8 04 00 00       	fld    DWORD PTR [eax+0x4e8]
    1cf9:	eb 5e                   	jmp    1d59 <.L110+0x6>

00001cfb <.L122>:
		case 34 : return .5592;
    1cfb:	d9 80 ec 04 00 00       	fld    DWORD PTR [eax+0x4ec]
    1d01:	eb 56                   	jmp    1d59 <.L110+0x6>

00001d03 <.L121>:
		case 35 : return .5736;
    1d03:	d9 80 f0 04 00 00       	fld    DWORD PTR [eax+0x4f0]
    1d09:	eb 4e                   	jmp    1d59 <.L110+0x6>

00001d0b <.L120>:
		case 36 : return .5878;
    1d0b:	d9 80 f4 04 00 00       	fld    DWORD PTR [eax+0x4f4]
    1d11:	eb 46                   	jmp    1d59 <.L110+0x6>

00001d13 <.L119>:
		case 37 : return .6018;
    1d13:	d9 80 f8 04 00 00       	fld    DWORD PTR [eax+0x4f8]
    1d19:	eb 3e                   	jmp    1d59 <.L110+0x6>

00001d1b <.L118>:
		case 38 : return .6157;
    1d1b:	d9 80 fc 04 00 00       	fld    DWORD PTR [eax+0x4fc]
    1d21:	eb 36                   	jmp    1d59 <.L110+0x6>

00001d23 <.L117>:
		case 39 : return .6293;
    1d23:	d9 80 00 05 00 00       	fld    DWORD PTR [eax+0x500]
    1d29:	eb 2e                   	jmp    1d59 <.L110+0x6>

00001d2b <.L116>:
		case 40 : return .6428;
    1d2b:	d9 80 04 05 00 00       	fld    DWORD PTR [eax+0x504]
    1d31:	eb 26                   	jmp    1d59 <.L110+0x6>

00001d33 <.L115>:
		case 41 : return .6561;
    1d33:	d9 80 08 05 00 00       	fld    DWORD PTR [eax+0x508]
    1d39:	eb 1e                   	jmp    1d59 <.L110+0x6>

00001d3b <.L114>:
		case 42 : return .6691;
    1d3b:	d9 80 0c 05 00 00       	fld    DWORD PTR [eax+0x50c]
    1d41:	eb 16                   	jmp    1d59 <.L110+0x6>

00001d43 <.L113>:
		case 43 : return .6820;
    1d43:	d9 80 10 05 00 00       	fld    DWORD PTR [eax+0x510]
    1d49:	eb 0e                   	jmp    1d59 <.L110+0x6>

00001d4b <.L112>:
		case 44 : return .6947;
    1d4b:	d9 80 14 05 00 00       	fld    DWORD PTR [eax+0x514]
    1d51:	eb 06                   	jmp    1d59 <.L110+0x6>

00001d53 <.L110>:
		case 45 : return .7071;
    1d53:	d9 80 18 05 00 00       	fld    DWORD PTR [eax+0x518]

	};//switch

}//sinus
    1d59:	5d                      	pop    ebp
    1d5a:	c3                      	ret    

00001d5b <dosomething>:

//-----------------------------------------------------------------------------

typedef int (*callsomething)( int, int );

int dosomething( int a, int b ) {
    1d5b:	55                      	push   ebp
    1d5c:	89 e5                   	mov    ebp,esp
    1d5e:	83 ec 10                	sub    esp,0x10
    1d61:	e8 fc ff ff ff          	call   1d62 <dosomething+0x7>
    1d66:	05 01 00 00 00          	add    eax,0x1

	int loop = 3;
    1d6b:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [ebp-0x4],0x3
	while ( loop-- );
    1d72:	90                      	nop
    1d73:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1d76:	8d 50 ff                	lea    edx,[eax-0x1]
    1d79:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
    1d7c:	85 c0                   	test   eax,eax
    1d7e:	75 f3                   	jne    1d73 <dosomething+0x18>

	return 0;
    1d80:	b8 00 00 00 00          	mov    eax,0x0

}//dosomething
    1d85:	c9                      	leave  
    1d86:	c3                      	ret    

00001d87 <dosomething_endmarker>:

void dosomething_endmarker( void ) {
    1d87:	55                      	push   ebp
    1d88:	89 e5                   	mov    ebp,esp
    1d8a:	e8 fc ff ff ff          	call   1d8b <dosomething_endmarker+0x4>
    1d8f:	05 01 00 00 00          	add    eax,0x1


}//dosomething_endmarker
    1d94:	90                      	nop
    1d95:	5d                      	pop    ebp
    1d96:	c3                      	ret    

00001d97 <messWithTheFunctions>:

void messWithTheFunctions() {
    1d97:	55                      	push   ebp
    1d98:	89 e5                   	mov    ebp,esp
    1d9a:	53                      	push   ebx
    1d9b:	83 ec 14                	sub    esp,0x14
    1d9e:	e8 fc ff ff ff          	call   1d9f <messWithTheFunctions+0x8>
    1da3:	05 01 00 00 00          	add    eax,0x1

	int size = (void*)dosomething_endmarker - (void*)dosomething;
    1da8:	8d 90 00 00 00 00       	lea    edx,[eax+0x0]
    1dae:	8d 88 00 00 00 00       	lea    ecx,[eax+0x0]
    1db4:	29 ca                   	sub    edx,ecx
    1db6:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx

	char *source = dosomething;
    1db9:	8d 90 00 00 00 00       	lea    edx,[eax+0x0]
    1dbf:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
	char *target = calloc( size, sizeof(char) );
    1dc2:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    1dc5:	83 ec 08                	sub    esp,0x8
    1dc8:	6a 01                   	push   0x1
    1dca:	52                      	push   edx
    1dcb:	89 c3                   	mov    ebx,eax
    1dcd:	e8 fc ff ff ff          	call   1dce <messWithTheFunctions+0x37>
    1dd2:	83 c4 10                	add    esp,0x10
    1dd5:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

	while ( size-- )
    1dd8:	eb 17                   	jmp    1df1 <messWithTheFunctions+0x5a>
		*target++ = *source++;
    1dda:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
    1ddd:	8d 42 01                	lea    eax,[edx+0x1]
    1de0:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    1de3:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    1de6:	8d 48 01                	lea    ecx,[eax+0x1]
    1de9:	89 4d ec                	mov    DWORD PTR [ebp-0x14],ecx
    1dec:	0f b6 12                	movzx  edx,BYTE PTR [edx]
    1def:	88 10                   	mov    BYTE PTR [eax],dl
	while ( size-- )
    1df1:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1df4:	8d 50 ff                	lea    edx,[eax-0x1]
    1df7:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
    1dfa:	85 c0                   	test   eax,eax
    1dfc:	75 dc                   	jne    1dda <messWithTheFunctions+0x43>

	callsomething call = target;
    1dfe:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    1e01:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	call( 3, 5 );
    1e04:	83 ec 08                	sub    esp,0x8
    1e07:	6a 05                   	push   0x5
    1e09:	6a 03                   	push   0x3
    1e0b:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    1e0e:	ff d0                   	call   eax
    1e10:	83 c4 10                	add    esp,0x10

}//messWithTheFunctions
    1e13:	90                      	nop
    1e14:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    1e17:	c9                      	leave  
    1e18:	c3                      	ret    

00001e19 <printArguments>:

//-----------------------------------------------------------------------------

void printArguments( int argc, char** argv ) {
    1e19:	55                      	push   ebp
    1e1a:	89 e5                   	mov    ebp,esp
    1e1c:	53                      	push   ebx
    1e1d:	83 ec 14                	sub    esp,0x14
    1e20:	e8 fc ff ff ff          	call   1e21 <printArguments+0x8>
    1e25:	81 c3 02 00 00 00       	add    ebx,0x2

	for ( int i = 0; i < argc; i++ ) {
    1e2b:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
    1e32:	eb 2f                   	jmp    1e63 <printArguments+0x4a>
		printf( "[%d] : %s\r\n", (i+1), argv[i] );
    1e34:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1e37:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    1e3e:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    1e41:	01 d0                   	add    eax,edx
    1e43:	8b 00                   	mov    eax,DWORD PTR [eax]
    1e45:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    1e48:	83 c2 01                	add    edx,0x1
    1e4b:	83 ec 04                	sub    esp,0x4
    1e4e:	50                      	push   eax
    1e4f:	52                      	push   edx
    1e50:	8d 83 b0 01 00 00       	lea    eax,[ebx+0x1b0]
    1e56:	50                      	push   eax
    1e57:	e8 fc ff ff ff          	call   1e58 <printArguments+0x3f>
    1e5c:	83 c4 10                	add    esp,0x10
	for ( int i = 0; i < argc; i++ ) {
    1e5f:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1
    1e63:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    1e66:	3b 45 08                	cmp    eax,DWORD PTR [ebp+0x8]
    1e69:	7c c9                   	jl     1e34 <printArguments+0x1b>
	}//for

}//printArguments
    1e6b:	90                      	nop
    1e6c:	90                      	nop
    1e6d:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    1e70:	c9                      	leave  
    1e71:	c3                      	ret    

00001e72 <nop>:

// iki "int" tipinde değer alan ve bir "int" tipinde değer döndüren
// her tür fonksiyonu gösterebilen "function pointer" tanımla.
typedef int (*operation)( int, int );

int nop( int a, int b ) {
    1e72:	55                      	push   ebp
    1e73:	89 e5                   	mov    ebp,esp
    1e75:	e8 fc ff ff ff          	call   1e76 <nop+0x4>
    1e7a:	05 01 00 00 00          	add    eax,0x1
	return 0;
    1e7f:	b8 00 00 00 00          	mov    eax,0x0
}
    1e84:	5d                      	pop    ebp
    1e85:	c3                      	ret    

00001e86 <add>:

int add( int a, int b ) {
    1e86:	55                      	push   ebp
    1e87:	89 e5                   	mov    ebp,esp
    1e89:	e8 fc ff ff ff          	call   1e8a <add+0x4>
    1e8e:	05 01 00 00 00          	add    eax,0x1
	return a + b;
    1e93:	8b 55 08                	mov    edx,DWORD PTR [ebp+0x8]
    1e96:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    1e99:	01 d0                   	add    eax,edx
}
    1e9b:	5d                      	pop    ebp
    1e9c:	c3                      	ret    

00001e9d <sub>:

int sub( int a, int b ) {
    1e9d:	55                      	push   ebp
    1e9e:	89 e5                   	mov    ebp,esp
    1ea0:	e8 fc ff ff ff          	call   1ea1 <sub+0x4>
    1ea5:	05 01 00 00 00          	add    eax,0x1
	return a - b;
    1eaa:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    1ead:	2b 45 0c                	sub    eax,DWORD PTR [ebp+0xc]
}
    1eb0:	5d                      	pop    ebp
    1eb1:	c3                      	ret    

00001eb2 <mul>:

int mul( int a, int b ) {
    1eb2:	55                      	push   ebp
    1eb3:	89 e5                   	mov    ebp,esp
    1eb5:	e8 fc ff ff ff          	call   1eb6 <mul+0x4>
    1eba:	05 01 00 00 00          	add    eax,0x1
	return a * b;
    1ebf:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    1ec2:	0f af 45 0c             	imul   eax,DWORD PTR [ebp+0xc]
}
    1ec6:	5d                      	pop    ebp
    1ec7:	c3                      	ret    

00001ec8 <idv>:

int idv( int a, int b ) {
    1ec8:	55                      	push   ebp
    1ec9:	89 e5                   	mov    ebp,esp
    1ecb:	e8 fc ff ff ff          	call   1ecc <idv+0x4>
    1ed0:	05 01 00 00 00          	add    eax,0x1
	return a / b;
    1ed5:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    1ed8:	99                      	cdq    
    1ed9:	f7 7d 0c                	idiv   DWORD PTR [ebp+0xc]
}
    1edc:	5d                      	pop    ebp
    1edd:	c3                      	ret    

00001ede <parseArguments>:
 * out_operandB : tamsayı değer.
 *
 * RETURN:
 * void
 */
void parseArguments( char** in_values, char* out_operator, int* out_operandA, int* out_operandB ) {
    1ede:	55                      	push   ebp
    1edf:	89 e5                   	mov    ebp,esp
    1ee1:	83 ec 20                	sub    esp,0x20
    1ee4:	e8 fc ff ff ff          	call   1ee5 <parseArguments+0x7>
    1ee9:	05 01 00 00 00          	add    eax,0x1

	*out_operator = in_values[ 1 ][ 0 ];
    1eee:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    1ef1:	83 c0 04                	add    eax,0x4
    1ef4:	8b 00                   	mov    eax,DWORD PTR [eax]
    1ef6:	0f b6 10                	movzx  edx,BYTE PTR [eax]
    1ef9:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    1efc:	88 10                   	mov    BYTE PTR [eax],dl

    int* values[] = { out_operandA, out_operandB };
    1efe:	8b 45 10                	mov    eax,DWORD PTR [ebp+0x10]
    1f01:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
    1f04:	8b 45 14                	mov    eax,DWORD PTR [ebp+0x14]
    1f07:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax
    int index     = ( sizeof(values) / sizeof(int*) );
    1f0a:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2

	while ( index ) {
    1f11:	e9 8f 00 00 00          	jmp    1fa5 <parseArguments+0xc7>

		char *valueStart = NULL;
    1f16:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
		char *valueEnd   = NULL;
    1f1d:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0

		// string'in başına git
		valueStart = valueEnd = in_values[ index + 1 ];
    1f24:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1f27:	83 c0 01                	add    eax,0x1
    1f2a:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    1f31:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    1f34:	01 d0                   	add    eax,edx
    1f36:	8b 00                   	mov    eax,DWORD PTR [eax]
    1f38:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax
    1f3b:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    1f3e:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

		// string'in sonuna git
		while ( *++valueEnd );
    1f41:	83 45 f8 01             	add    DWORD PTR [ebp-0x8],0x1
    1f45:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    1f48:	0f b6 00                	movzx  eax,BYTE PTR [eax]
    1f4b:	84 c0                   	test   al,al
    1f4d:	75 f2                   	jne    1f41 <parseArguments+0x63>

		// son, baştan büyük olduğu sürece "geri" git ve basamakların değerini hesapla
		int place = 1;
    1f4f:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1
		while ( valueStart < valueEnd-- ) {
    1f56:	eb 3b                   	jmp    1f93 <parseArguments+0xb5>

			*values[ index - 1 ] += ( *valueEnd - '0' ) * place;
    1f58:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1f5b:	83 e8 01                	sub    eax,0x1
    1f5e:	8b 44 85 e8             	mov    eax,DWORD PTR [ebp+eax*4-0x18]
    1f62:	8b 08                   	mov    ecx,DWORD PTR [eax]
    1f64:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    1f67:	0f b6 00                	movzx  eax,BYTE PTR [eax]
    1f6a:	0f be c0                	movsx  eax,al
    1f6d:	83 e8 30                	sub    eax,0x30
    1f70:	0f af 45 f4             	imul   eax,DWORD PTR [ebp-0xc]
    1f74:	89 c2                   	mov    edx,eax
    1f76:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    1f79:	83 e8 01                	sub    eax,0x1
    1f7c:	8b 44 85 e8             	mov    eax,DWORD PTR [ebp+eax*4-0x18]
    1f80:	01 ca                   	add    edx,ecx
    1f82:	89 10                   	mov    DWORD PTR [eax],edx
			place *= 10;
    1f84:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    1f87:	89 d0                   	mov    eax,edx
    1f89:	c1 e0 02                	shl    eax,0x2
    1f8c:	01 d0                   	add    eax,edx
    1f8e:	01 c0                   	add    eax,eax
    1f90:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
		while ( valueStart < valueEnd-- ) {
    1f93:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    1f96:	8d 50 ff                	lea    edx,[eax-0x1]
    1f99:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx
    1f9c:	39 45 f0                	cmp    DWORD PTR [ebp-0x10],eax
    1f9f:	72 b7                   	jb     1f58 <parseArguments+0x7a>

		}

		index--;
    1fa1:	83 6d fc 01             	sub    DWORD PTR [ebp-0x4],0x1
	while ( index ) {
    1fa5:	83 7d fc 00             	cmp    DWORD PTR [ebp-0x4],0x0
    1fa9:	0f 85 67 ff ff ff       	jne    1f16 <parseArguments+0x38>

	}//while

}//parseArguments
    1faf:	90                      	nop
    1fb0:	90                      	nop
    1fb1:	c9                      	leave  
    1fb2:	c3                      	ret    

00001fb3 <functionPointerSample>:

/*
 *  Eclipse, komut satırı parametrelerini belirle:
 *  Run => Debug Configurations... => tab[Arguments] => textbox[Program arguments]: + 1234 789
 */
int functionPointerSample( int argc, char** argv ) {
    1fb3:	55                      	push   ebp
    1fb4:	89 e5                   	mov    ebp,esp
    1fb6:	56                      	push   esi
    1fb7:	53                      	push   ebx
    1fb8:	83 ec 30                	sub    esp,0x30
    1fbb:	e8 fc ff ff ff          	call   1fbc <functionPointerSample+0x9>
    1fc0:	81 c3 02 00 00 00       	add    ebx,0x2
    1fc6:	89 e0                   	mov    eax,esp
    1fc8:	89 c6                   	mov    esi,eax

	const int minArgs = 4;
    1fca:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

	if ( argc < minArgs ) {
    1fd1:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    1fd4:	3b 45 f0                	cmp    eax,DWORD PTR [ebp-0x10]
    1fd7:	7d 1c                   	jge    1ff5 <functionPointerSample+0x42>
	   puts( "Argüman sayısı yetersiz. En az 3 argüman gerekli." );
    1fd9:	83 ec 0c                	sub    esp,0xc
    1fdc:	8d 83 bc 01 00 00       	lea    eax,[ebx+0x1bc]
    1fe2:	50                      	push   eax
    1fe3:	e8 fc ff ff ff          	call   1fe4 <functionPointerSample+0x31>
    1fe8:	83 c4 10                	add    esp,0x10
	   return EXIT_FAILURE;
    1feb:	b8 01 00 00 00          	mov    eax,0x1
    1ff0:	e9 0d 01 00 00          	jmp    2102 <functionPointerSample+0x14f>
	}

	// operatör ve operandların değerlerini tutacak değişkenleri hazırla
	char operator = '\0';
    1ff5:	c6 45 df 00             	mov    BYTE PTR [ebp-0x21],0x0
	int  operandA = 0;
    1ff9:	c7 45 d8 00 00 00 00    	mov    DWORD PTR [ebp-0x28],0x0
	int  operandB = 0;
    2000:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x0

	// komut satırından girlen "ham" metinleri "kullanılabilir" veriye çevir
	parseArguments( argv, &operator, &operandA, &operandB );
    2007:	8d 45 d4                	lea    eax,[ebp-0x2c]
    200a:	50                      	push   eax
    200b:	8d 45 d8                	lea    eax,[ebp-0x28]
    200e:	50                      	push   eax
    200f:	8d 45 df                	lea    eax,[ebp-0x21]
    2012:	50                      	push   eax
    2013:	ff 75 0c                	push   DWORD PTR [ebp+0xc]
    2016:	e8 fc ff ff ff          	call   2017 <functionPointerSample+0x64>
    201b:	83 c4 10                	add    esp,0x10

	// operatörlere karşılık gelen operasyonları sağlayan fonksiyonların
	// adreslerini tutan "lookup table"ı tanımla
	const int maxEntries = 255;
    201e:	c7 45 ec ff 00 00 00    	mov    DWORD PTR [ebp-0x14],0xff
	operation operations[ maxEntries ];
    2025:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2028:	83 e8 01                	sub    eax,0x1
    202b:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
    202e:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2031:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    2038:	b8 10 00 00 00          	mov    eax,0x10
    203d:	83 e8 01                	sub    eax,0x1
    2040:	01 d0                   	add    eax,edx
    2042:	b9 10 00 00 00          	mov    ecx,0x10
    2047:	ba 00 00 00 00          	mov    edx,0x0
    204c:	f7 f1                   	div    ecx
    204e:	6b c0 10                	imul   eax,eax,0x10
    2051:	29 c4                   	sub    esp,eax
    2053:	89 e0                   	mov    eax,esp
    2055:	83 c0 03                	add    eax,0x3
    2058:	c1 e8 02                	shr    eax,0x2
    205b:	c1 e0 02                	shl    eax,0x2
    205e:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax

	int entryCount = maxEntries;
    2061:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2064:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	// "lookup table"ı "no-operation" ile doldurarak başlat
	while ( entryCount-- )
    2067:	eb 0f                   	jmp    2078 <functionPointerSample+0xc5>
		operations[ entryCount ] = nop;
    2069:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    206c:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    206f:	8d 8b 00 00 00 00       	lea    ecx,[ebx+0x0]
    2075:	89 0c 90                	mov    DWORD PTR [eax+edx*4],ecx
	while ( entryCount-- )
    2078:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    207b:	8d 50 ff                	lea    edx,[eax-0x1]
    207e:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
    2081:	85 c0                   	test   eax,eax
    2083:	75 e4                   	jne    2069 <functionPointerSample+0xb6>

	// başlatılan tabloyu hazırla
	operations[ '+' ] = add;
    2085:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    2088:	8d 93 00 00 00 00       	lea    edx,[ebx+0x0]
    208e:	89 90 ac 00 00 00       	mov    DWORD PTR [eax+0xac],edx
	operations[ '-' ] = sub;
    2094:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    2097:	8d 93 00 00 00 00       	lea    edx,[ebx+0x0]
    209d:	89 90 b4 00 00 00       	mov    DWORD PTR [eax+0xb4],edx
	operations[ '*' ] = mul;
    20a3:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    20a6:	8d 93 00 00 00 00       	lea    edx,[ebx+0x0]
    20ac:	89 90 a8 00 00 00       	mov    DWORD PTR [eax+0xa8],edx
	operations[ '/' ] = idv;
    20b2:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    20b5:	8d 93 00 00 00 00       	lea    edx,[ebx+0x0]
    20bb:	89 90 bc 00 00 00       	mov    DWORD PTR [eax+0xbc],edx

	// verilen operatörün operasyonunu tablodan bul çağır ve işlem sonucunu al
	int result = operations[ operator ]( operandA, operandB );
    20c1:	0f b6 45 df             	movzx  eax,BYTE PTR [ebp-0x21]
    20c5:	0f be d0                	movsx  edx,al
    20c8:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    20cb:	8b 04 90                	mov    eax,DWORD PTR [eax+edx*4]
    20ce:	8b 4d d4                	mov    ecx,DWORD PTR [ebp-0x2c]
    20d1:	8b 55 d8                	mov    edx,DWORD PTR [ebp-0x28]
    20d4:	83 ec 08                	sub    esp,0x8
    20d7:	51                      	push   ecx
    20d8:	52                      	push   edx
    20d9:	ff d0                   	call   eax
    20db:	83 c4 10                	add    esp,0x10
    20de:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax

	// herhangi bir karakterle "no-operation"ı dene.
	result = operations[ '?' ]( operandA, operandB );
    20e1:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    20e4:	8b 80 fc 00 00 00       	mov    eax,DWORD PTR [eax+0xfc]
    20ea:	8b 4d d4                	mov    ecx,DWORD PTR [ebp-0x2c]
    20ed:	8b 55 d8                	mov    edx,DWORD PTR [ebp-0x28]
    20f0:	83 ec 08                	sub    esp,0x8
    20f3:	51                      	push   ecx
    20f4:	52                      	push   edx
    20f5:	ff d0                   	call   eax
    20f7:	83 c4 10                	add    esp,0x10
    20fa:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax

	return EXIT_SUCCESS;
    20fd:	b8 00 00 00 00          	mov    eax,0x0
    2102:	89 f4                   	mov    esp,esi

}//functionPointerSample
    2104:	8d 65 f8                	lea    esp,[ebp-0x8]
    2107:	5b                      	pop    ebx
    2108:	5e                      	pop    esi
    2109:	5d                      	pop    ebp
    210a:	c3                      	ret    

0000210b <functionPointers>:

//-----------------------------------------------------------------------------

void functionPointers( void ) {
    210b:	55                      	push   ebp
    210c:	89 e5                   	mov    ebp,esp
    210e:	53                      	push   ebx
    210f:	83 ec 14                	sub    esp,0x14
    2112:	e8 fc ff ff ff          	call   2113 <functionPointers+0x8>
    2117:	81 c3 02 00 00 00       	add    ebx,0x2

   int (*fp)( int, int ) = NULL;
    211d:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
   void *pv = NULL;
    2124:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

   int result = 0;
    212b:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0

   // both the same
   fp = add;
    2132:	8d 83 00 00 00 00       	lea    eax,[ebx+0x0]
    2138:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   fp = &add;
    213b:	8d 83 00 00 00 00       	lea    eax,[ebx+0x0]
    2141:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   // old style call
   result = (*fp)( 5,3 );
    2144:	83 ec 08                	sub    esp,0x8
    2147:	6a 03                   	push   0x3
    2149:	6a 05                   	push   0x5
    214b:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    214e:	ff d0                   	call   eax
    2150:	83 c4 10                	add    esp,0x10
    2153:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   // C99 style call
   result = fp( 5, 3 );
    2156:	83 ec 08                	sub    esp,0x8
    2159:	6a 03                   	push   0x3
    215b:	6a 05                   	push   0x5
    215d:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2160:	ff d0                   	call   eax
    2162:	83 c4 10                	add    esp,0x10
    2165:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   pv = add;
    2168:	8d 83 00 00 00 00       	lea    eax,[ebx+0x0]
    216e:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

   // function address assignment with and without casting
   fp = (int(*)(int,int)) pv;
    2171:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2174:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
   fp = pv;
    2177:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    217a:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   result = fp( 5, 3 );
    217d:	83 ec 08                	sub    esp,0x8
    2180:	6a 03                   	push   0x3
    2182:	6a 05                   	push   0x5
    2184:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2187:	ff d0                   	call   eax
    2189:	83 c4 10                	add    esp,0x10
    218c:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   // cast to function poimter than call :  int(*)(int,int)
   result = ( (int(*)(int,int))pv )( 5, 3 );
    218f:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2192:	83 ec 08                	sub    esp,0x8
    2195:	6a 03                   	push   0x3
    2197:	6a 05                   	push   0x5
    2199:	ff d0                   	call   eax
    219b:	83 c4 10                	add    esp,0x10
    219e:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   pv = sub;
    21a1:	8d 83 00 00 00 00       	lea    eax,[ebx+0x0]
    21a7:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   result = ( (int(*)(int,int))pv )( 5, 3 );
    21aa:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    21ad:	83 ec 08                	sub    esp,0x8
    21b0:	6a 03                   	push   0x3
    21b2:	6a 05                   	push   0x5
    21b4:	ff d0                   	call   eax
    21b6:	83 c4 10                	add    esp,0x10
    21b9:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   pv = mul;
    21bc:	8d 83 00 00 00 00       	lea    eax,[ebx+0x0]
    21c2:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   result = ( (int(*)(int,int))pv )( 5, 3 );
    21c5:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    21c8:	83 ec 08                	sub    esp,0x8
    21cb:	6a 03                   	push   0x3
    21cd:	6a 05                   	push   0x5
    21cf:	ff d0                   	call   eax
    21d1:	83 c4 10                	add    esp,0x10
    21d4:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

}//functionPointers
    21d7:	90                      	nop
    21d8:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    21db:	c9                      	leave  
    21dc:	c3                      	ret    

000021dd <enums>:
	yellow,
	black,
	white
} AllColor;

void enums( void ) {
    21dd:	55                      	push   ebp
    21de:	89 e5                   	mov    ebp,esp
    21e0:	83 ec 20                	sub    esp,0x20
    21e3:	e8 fc ff ff ff          	call   21e4 <enums+0x7>
    21e8:	05 01 00 00 00          	add    eax,0x1

	enum PrintColor { cyan, magenta, yellow, black };

	enum PrintColor colorW;
	enum PrintColor colorX;
	enum PrintColor colorY = black;
    21ed:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [ebp-0x4],0x3
	enum PrintColor colorZ = magenta;
    21f4:	c7 45 f8 01 00 00 00    	mov    DWORD PTR [ebp-0x8],0x1

    enum TAllColor allA;
    enum TAllColor allB = black;
    21fb:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [ebp-0xc],0x3
	AllColor       allC;
	AllColor       allD = white;
    2202:	c7 45 f0 0a 00 00 00    	mov    DWORD PTR [ebp-0x10],0xa

	size_t size = 0;
    2209:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
	size = sizeof( colorA );
    2210:	c7 45 ec 04 00 00 00    	mov    DWORD PTR [ebp-0x14],0x4

	colorA = 0;
    2217:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0
	colorA = 1;
    221e:	c7 45 e8 01 00 00 00    	mov    DWORD PTR [ebp-0x18],0x1
	colorA = 2;
    2225:	c7 45 e8 02 00 00 00    	mov    DWORD PTR [ebp-0x18],0x2

	colorA = red;
    222c:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0
	colorA = green;
    2233:	c7 45 e8 01 00 00 00    	mov    DWORD PTR [ebp-0x18],0x1
	colorA = blue;
    223a:	c7 45 e8 02 00 00 00    	mov    DWORD PTR [ebp-0x18],0x2

	colorA = colorA - 1;
    2241:	83 6d e8 01             	sub    DWORD PTR [ebp-0x18],0x1
	colorA = colorA - 1;
    2245:	83 6d e8 01             	sub    DWORD PTR [ebp-0x18],0x1
	colorA = colorA - 1;
    2249:	83 6d e8 01             	sub    DWORD PTR [ebp-0x18],0x1

	colorA = INT_MIN;
    224d:	c7 45 e8 00 00 00 80    	mov    DWORD PTR [ebp-0x18],0x80000000
	colorA = INT_MAX;
    2254:	c7 45 e8 ff ff ff 7f    	mov    DWORD PTR [ebp-0x18],0x7fffffff

    colorA = colorZ;
    225b:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    225e:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

}//enums
    2261:	90                      	nop
    2262:	c9                      	leave  
    2263:	c3                      	ret    

00002264 <arrays_variableSize>:

//------------------------------------------------------------------------------

void arrays_variableSize( int length ) {
    2264:	55                      	push   ebp
    2265:	89 e5                   	mov    ebp,esp
    2267:	56                      	push   esi
    2268:	53                      	push   ebx
    2269:	83 ec 10                	sub    esp,0x10
    226c:	e8 fc ff ff ff          	call   226d <arrays_variableSize+0x9>
    2271:	81 c1 02 00 00 00       	add    ecx,0x2
    2277:	89 e0                   	mov    eax,esp
    2279:	89 c6                   	mov    esi,eax

	//int valuesA[ length ] = {}; // error : variable-sized object may not be initialized
	int valuesA[ length ];
    227b:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    227e:	8d 50 ff                	lea    edx,[eax-0x1]
    2281:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
    2284:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    228b:	b8 10 00 00 00          	mov    eax,0x10
    2290:	83 e8 01                	sub    eax,0x1
    2293:	01 d0                   	add    eax,edx
    2295:	bb 10 00 00 00          	mov    ebx,0x10
    229a:	ba 00 00 00 00          	mov    edx,0x0
    229f:	f7 f3                   	div    ebx
    22a1:	6b c0 10                	imul   eax,eax,0x10
    22a4:	29 c4                   	sub    esp,eax
    22a6:	89 e0                   	mov    eax,esp
    22a8:	83 c0 03                	add    eax,0x3
    22ab:	c1 e8 02                	shr    eax,0x2
    22ae:	c1 e0 02                	shl    eax,0x2
    22b1:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

	int* valuesB = malloc( length * sizeof(int) );
    22b4:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    22b7:	c1 e0 02                	shl    eax,0x2
    22ba:	83 ec 0c                	sub    esp,0xc
    22bd:	50                      	push   eax
    22be:	89 cb                   	mov    ebx,ecx
    22c0:	e8 fc ff ff ff          	call   22c1 <arrays_variableSize+0x5d>
    22c5:	83 c4 10                	add    esp,0x10
    22c8:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	int loop = length;
    22cb:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    22ce:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	while( loop-- )
    22d1:	eb 28                   	jmp    22fb <arrays_variableSize+0x97>
	   valuesB[ loop ] = valuesA[ loop ] = 0;
    22d3:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    22d6:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    22d9:	c7 04 90 00 00 00 00    	mov    DWORD PTR [eax+edx*4],0x0
    22e0:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    22e3:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    22ea:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    22ed:	8d 0c 02                	lea    ecx,[edx+eax*1]
    22f0:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    22f3:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    22f6:	8b 04 90                	mov    eax,DWORD PTR [eax+edx*4]
    22f9:	89 01                   	mov    DWORD PTR [ecx],eax
	while( loop-- )
    22fb:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    22fe:	8d 50 ff                	lea    edx,[eax-0x1]
    2301:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
    2304:	85 c0                   	test   eax,eax
    2306:	75 cb                   	jne    22d3 <arrays_variableSize+0x6f>
    2308:	89 f4                   	mov    esp,esi

}//arrays_variableSize
    230a:	90                      	nop
    230b:	8d 65 f8                	lea    esp,[ebp-0x8]
    230e:	5b                      	pop    ebx
    230f:	5e                      	pop    esi
    2310:	5d                      	pop    ebp
    2311:	c3                      	ret    

00002312 <arrays_multiDimensional>:
//-----------------------------------------------------------------------------

// defines special type for ( 3 x 4 ) of integers.
typedef int Special3D[ 3 ][ 4 ];

void arrays_multiDimensional() {
    2312:	55                      	push   ebp
    2313:	89 e5                   	mov    ebp,esp
    2315:	57                      	push   edi
    2316:	56                      	push   esi
    2317:	53                      	push   ebx
    2318:	81 ec fc 00 00 00       	sub    esp,0xfc
    231e:	e8 fc ff ff ff          	call   231f <arrays_multiDimensional+0xd>
    2323:	81 c3 02 00 00 00       	add    ebx,0x2

    char valuesA[ 5 ][ 2 ] = { {0,1}, {2,3}, {4,5}, {6,7}, {8,9} };
    2329:	66 c7 45 8a 00 01       	mov    WORD PTR [ebp-0x76],0x100
    232f:	66 c7 45 8c 02 03       	mov    WORD PTR [ebp-0x74],0x302
    2335:	66 c7 45 8e 04 05       	mov    WORD PTR [ebp-0x72],0x504
    233b:	66 c7 45 90 06 07       	mov    WORD PTR [ebp-0x70],0x706
    2341:	66 c7 45 92 08 09       	mov    WORD PTR [ebp-0x6e],0x908

	int valuesB[   ][ 3 ] = { {1,3,5} , {2,4,6} };
    2347:	c7 85 70 ff ff ff 01 00 	mov    DWORD PTR [ebp-0x90],0x1
    234f:	00 00 
    2351:	c7 85 74 ff ff ff 03 00 	mov    DWORD PTR [ebp-0x8c],0x3
    2359:	00 00 
    235b:	c7 85 78 ff ff ff 05 00 	mov    DWORD PTR [ebp-0x88],0x5
    2363:	00 00 
    2365:	c7 85 7c ff ff ff 02 00 	mov    DWORD PTR [ebp-0x84],0x2
    236d:	00 00 
    236f:	c7 45 80 04 00 00 00    	mov    DWORD PTR [ebp-0x80],0x4
    2376:	c7 45 84 06 00 00 00    	mov    DWORD PTR [ebp-0x7c],0x6
	int valuesC[ 2 ][ 3 ] = { {1,3,5} , {2,4,6} };
    237d:	c7 85 58 ff ff ff 01 00 	mov    DWORD PTR [ebp-0xa8],0x1
    2385:	00 00 
    2387:	c7 85 5c ff ff ff 03 00 	mov    DWORD PTR [ebp-0xa4],0x3
    238f:	00 00 
    2391:	c7 85 60 ff ff ff 05 00 	mov    DWORD PTR [ebp-0xa0],0x5
    2399:	00 00 
    239b:	c7 85 64 ff ff ff 02 00 	mov    DWORD PTR [ebp-0x9c],0x2
    23a3:	00 00 
    23a5:	c7 85 68 ff ff ff 04 00 	mov    DWORD PTR [ebp-0x98],0x4
    23ad:	00 00 
    23af:	c7 85 6c ff ff ff 06 00 	mov    DWORD PTR [ebp-0x94],0x6
    23b7:	00 00 
	//int valuesC[ 2 ][  ] = { {1,3,5} , {2,4,6} };// error : array type has incomplete element type

	int valuesE[ 2 ][ 3 ][ 4 ] = {
    23b9:	8d 85 f8 fe ff ff       	lea    eax,[ebp-0x108]
    23bf:	8d 93 00 02 00 00       	lea    edx,[ebx+0x200]
    23c5:	b9 18 00 00 00          	mov    ecx,0x18
    23ca:	89 c7                   	mov    edi,eax
    23cc:	89 d6                   	mov    esi,edx
    23ce:	f3 a5                   	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
		{
			{211, 212, 213, 214} ,  {221, 222, 223, 224} ,  {231, 232, 233, 234}
		}
	};

	int distanceAsBytes = (int)&valuesA[0][0] - (int)&valuesA[1][0];
    23d0:	c7 45 cc fe ff ff ff    	mov    DWORD PTR [ebp-0x34],0xfffffffe

	// see disassembly
	int value = 0;
    23d7:	c7 45 c8 00 00 00 00    	mov    DWORD PTR [ebp-0x38],0x0
	value = valuesA[0][0];
    23de:	0f b6 45 8a             	movzx  eax,BYTE PTR [ebp-0x76]
    23e2:	0f be c0                	movsx  eax,al
    23e5:	89 45 c8                	mov    DWORD PTR [ebp-0x38],eax
	value = valuesA[0][1];
    23e8:	0f b6 45 8b             	movzx  eax,BYTE PTR [ebp-0x75]
    23ec:	0f be c0                	movsx  eax,al
    23ef:	89 45 c8                	mov    DWORD PTR [ebp-0x38],eax

	value = valuesA[1][0];
    23f2:	0f b6 45 8c             	movzx  eax,BYTE PTR [ebp-0x74]
    23f6:	0f be c0                	movsx  eax,al
    23f9:	89 45 c8                	mov    DWORD PTR [ebp-0x38],eax
	value = valuesA[1][1];
    23fc:	0f b6 45 8d             	movzx  eax,BYTE PTR [ebp-0x73]
    2400:	0f be c0                	movsx  eax,al
    2403:	89 45 c8                	mov    DWORD PTR [ebp-0x38],eax

	value = valuesA[2][0];
    2406:	0f b6 45 8e             	movzx  eax,BYTE PTR [ebp-0x72]
    240a:	0f be c0                	movsx  eax,al
    240d:	89 45 c8                	mov    DWORD PTR [ebp-0x38],eax
	value = valuesA[3][1];
    2410:	0f b6 45 91             	movzx  eax,BYTE PTR [ebp-0x6f]
    2414:	0f be c0                	movsx  eax,al
    2417:	89 45 c8                	mov    DWORD PTR [ebp-0x38],eax

	const int lengthI = 4;
    241a:	c7 45 c4 04 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x4
	const int lengthJ = 3;
    2421:	c7 45 c0 03 00 00 00    	mov    DWORD PTR [ebp-0x40],0x3
	const int lengthK = 2;
    2428:	c7 45 bc 02 00 00 00    	mov    DWORD PTR [ebp-0x44],0x2

	size_t size = sizeof valuesE;
    242f:	c7 45 b8 60 00 00 00    	mov    DWORD PTR [ebp-0x48],0x60

	for ( int k = 0; k < lengthK; k++ ) {
    2436:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
    243d:	e9 a1 00 00 00          	jmp    24e3 <arrays_multiDimensional+0x1d1>

		for ( int j = 0; j < lengthJ; j++ ) {
    2442:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [ebp-0x20],0x0
    2449:	e9 85 00 00 00          	jmp    24d3 <arrays_multiDimensional+0x1c1>

			for ( int i = 0; i < lengthI; i++ ) {
    244e:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
    2455:	eb 70                   	jmp    24c7 <arrays_multiDimensional+0x1b5>

				int hundreds = k + 1;
    2457:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    245a:	83 c0 01                	add    eax,0x1
    245d:	89 45 9c                	mov    DWORD PTR [ebp-0x64],eax
				int tens     = j + 1;
    2460:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    2463:	83 c0 01                	add    eax,0x1
    2466:	89 45 98                	mov    DWORD PTR [ebp-0x68],eax
				int ones     = i;
    2469:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    246c:	89 45 94                	mov    DWORD PTR [ebp-0x6c],eax

				valuesE[ k ][ j ][ i ] = 100*hundreds + 10*tens + ones;
    246f:	8b 45 9c                	mov    eax,DWORD PTR [ebp-0x64]
    2472:	6b c8 64                	imul   ecx,eax,0x64
    2475:	8b 55 98                	mov    edx,DWORD PTR [ebp-0x68]
    2478:	89 d0                   	mov    eax,edx
    247a:	c1 e0 02                	shl    eax,0x2
    247d:	01 d0                   	add    eax,edx
    247f:	01 c0                   	add    eax,eax
    2481:	8d 14 01                	lea    edx,[ecx+eax*1]
    2484:	8b 45 94                	mov    eax,DWORD PTR [ebp-0x6c]
    2487:	8d 0c 02                	lea    ecx,[edx+eax*1]
    248a:	8b 55 e4                	mov    edx,DWORD PTR [ebp-0x1c]
    248d:	89 d0                   	mov    eax,edx
    248f:	01 c0                   	add    eax,eax
    2491:	01 d0                   	add    eax,edx
    2493:	8b 55 e0                	mov    edx,DWORD PTR [ebp-0x20]
    2496:	01 d0                   	add    eax,edx
    2498:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    249f:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    24a2:	01 d0                   	add    eax,edx
    24a4:	89 8c 85 f8 fe ff ff    	mov    DWORD PTR [ebp+eax*4-0x108],ecx
				printf( "%d%d%d ", hundreds, tens, ones );
    24ab:	ff 75 94                	push   DWORD PTR [ebp-0x6c]
    24ae:	ff 75 98                	push   DWORD PTR [ebp-0x68]
    24b1:	ff 75 9c                	push   DWORD PTR [ebp-0x64]
    24b4:	8d 83 f2 01 00 00       	lea    eax,[ebx+0x1f2]
    24ba:	50                      	push   eax
    24bb:	e8 fc ff ff ff          	call   24bc <arrays_multiDimensional+0x1aa>
    24c0:	83 c4 10                	add    esp,0x10
			for ( int i = 0; i < lengthI; i++ ) {
    24c3:	83 45 dc 01             	add    DWORD PTR [ebp-0x24],0x1
    24c7:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    24ca:	3b 45 c4                	cmp    eax,DWORD PTR [ebp-0x3c]
    24cd:	7c 88                   	jl     2457 <arrays_multiDimensional+0x145>
		for ( int j = 0; j < lengthJ; j++ ) {
    24cf:	83 45 e0 01             	add    DWORD PTR [ebp-0x20],0x1
    24d3:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    24d6:	3b 45 c0                	cmp    eax,DWORD PTR [ebp-0x40]
    24d9:	0f 8c 6f ff ff ff       	jl     244e <arrays_multiDimensional+0x13c>
	for ( int k = 0; k < lengthK; k++ ) {
    24df:	83 45 e4 01             	add    DWORD PTR [ebp-0x1c],0x1
    24e3:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    24e6:	3b 45 bc                	cmp    eax,DWORD PTR [ebp-0x44]
    24e9:	0f 8c 53 ff ff ff       	jl     2442 <arrays_multiDimensional+0x130>

		}//forj

	}//fork

	Special3D* p3D = NULL;
    24ef:	c7 45 b4 00 00 00 00    	mov    DWORD PTR [ebp-0x4c],0x0
	size_t allocateBytes = sizeof(Special3D) * lengthK;
    24f6:	8b 55 bc                	mov    edx,DWORD PTR [ebp-0x44]
    24f9:	89 d0                   	mov    eax,edx
    24fb:	01 c0                   	add    eax,eax
    24fd:	01 d0                   	add    eax,edx
    24ff:	c1 e0 04                	shl    eax,0x4
    2502:	89 45 b0                	mov    DWORD PTR [ebp-0x50],eax

	void* buffer = malloc( allocateBytes );
    2505:	83 ec 0c                	sub    esp,0xc
    2508:	ff 75 b0                	push   DWORD PTR [ebp-0x50]
    250b:	e8 fc ff ff ff          	call   250c <arrays_multiDimensional+0x1fa>
    2510:	83 c4 10                	add    esp,0x10
    2513:	89 45 ac                	mov    DWORD PTR [ebp-0x54],eax
	if ( buffer == NULL ) {
    2516:	83 7d ac 00             	cmp    DWORD PTR [ebp-0x54],0x0
    251a:	75 0a                   	jne    2526 <arrays_multiDimensional+0x214>
		// not enough memory, terminate the program with failure
	    exit( EXIT_FAILURE );
    251c:	83 ec 0c                	sub    esp,0xc
    251f:	6a 01                   	push   0x1
    2521:	e8 fc ff ff ff          	call   2522 <arrays_multiDimensional+0x210>
	}

	// Casting void* to int(*)[3][4]. Same effect as casting to Special3D*
	p3D = (int(*)[3][4]) buffer;
    2526:	8b 45 ac                	mov    eax,DWORD PTR [ebp-0x54]
    2529:	89 45 b4                	mov    DWORD PTR [ebp-0x4c],eax

	for ( int k = 0; k < lengthK; k++ ) {
    252c:	c7 45 d8 00 00 00 00    	mov    DWORD PTR [ebp-0x28],0x0
    2533:	e9 84 00 00 00          	jmp    25bc <arrays_multiDimensional+0x2aa>

		for ( int j = 0; j < lengthJ; j++ ) {
    2538:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x0
    253f:	eb 6f                   	jmp    25b0 <arrays_multiDimensional+0x29e>

			for ( int i = 0; i < lengthI; i++ ) {
    2541:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [ebp-0x30],0x0
    2548:	eb 5a                   	jmp    25a4 <arrays_multiDimensional+0x292>

				int hundreds = k + 1;
    254a:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    254d:	83 c0 01                	add    eax,0x1
    2550:	89 45 a8                	mov    DWORD PTR [ebp-0x58],eax
				int tens     = j + 1;
    2553:	8b 45 d4                	mov    eax,DWORD PTR [ebp-0x2c]
    2556:	83 c0 01                	add    eax,0x1
    2559:	89 45 a4                	mov    DWORD PTR [ebp-0x5c],eax
				int ones     = i;
    255c:	8b 45 d0                	mov    eax,DWORD PTR [ebp-0x30]
    255f:	89 45 a0                	mov    DWORD PTR [ebp-0x60],eax

				p3D[ k ][ j ][ i ] = 100*hundreds + 10*tens + ones;
    2562:	8b 45 a8                	mov    eax,DWORD PTR [ebp-0x58]
    2565:	6b c8 64                	imul   ecx,eax,0x64
    2568:	8b 55 a4                	mov    edx,DWORD PTR [ebp-0x5c]
    256b:	89 d0                   	mov    eax,edx
    256d:	c1 e0 02                	shl    eax,0x2
    2570:	01 d0                   	add    eax,edx
    2572:	01 c0                   	add    eax,eax
    2574:	01 c1                   	add    ecx,eax
    2576:	8b 55 d8                	mov    edx,DWORD PTR [ebp-0x28]
    2579:	89 d0                   	mov    eax,edx
    257b:	01 c0                   	add    eax,eax
    257d:	01 d0                   	add    eax,edx
    257f:	c1 e0 04                	shl    eax,0x4
    2582:	89 c2                   	mov    edx,eax
    2584:	8b 45 b4                	mov    eax,DWORD PTR [ebp-0x4c]
    2587:	01 d0                   	add    eax,edx
    2589:	8b 55 a0                	mov    edx,DWORD PTR [ebp-0x60]
    258c:	01 d1                   	add    ecx,edx
    258e:	8b 55 d4                	mov    edx,DWORD PTR [ebp-0x2c]
    2591:	8d 34 95 00 00 00 00    	lea    esi,[edx*4+0x0]
    2598:	8b 55 d0                	mov    edx,DWORD PTR [ebp-0x30]
    259b:	01 f2                   	add    edx,esi
    259d:	89 0c 90                	mov    DWORD PTR [eax+edx*4],ecx
			for ( int i = 0; i < lengthI; i++ ) {
    25a0:	83 45 d0 01             	add    DWORD PTR [ebp-0x30],0x1
    25a4:	8b 45 d0                	mov    eax,DWORD PTR [ebp-0x30]
    25a7:	3b 45 c4                	cmp    eax,DWORD PTR [ebp-0x3c]
    25aa:	7c 9e                   	jl     254a <arrays_multiDimensional+0x238>
		for ( int j = 0; j < lengthJ; j++ ) {
    25ac:	83 45 d4 01             	add    DWORD PTR [ebp-0x2c],0x1
    25b0:	8b 45 d4                	mov    eax,DWORD PTR [ebp-0x2c]
    25b3:	3b 45 c0                	cmp    eax,DWORD PTR [ebp-0x40]
    25b6:	7c 89                   	jl     2541 <arrays_multiDimensional+0x22f>
	for ( int k = 0; k < lengthK; k++ ) {
    25b8:	83 45 d8 01             	add    DWORD PTR [ebp-0x28],0x1
    25bc:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    25bf:	3b 45 bc                	cmp    eax,DWORD PTR [ebp-0x44]
    25c2:	0f 8c 70 ff ff ff       	jl     2538 <arrays_multiDimensional+0x226>
		}//forj

	}//fork

    // free the previously allocated memory
	free( p3D );
    25c8:	83 ec 0c                	sub    esp,0xc
    25cb:	ff 75 b4                	push   DWORD PTR [ebp-0x4c]
    25ce:	e8 fc ff ff ff          	call   25cf <arrays_multiDimensional+0x2bd>
    25d3:	83 c4 10                	add    esp,0x10

}//arrays_multiDimensional
    25d6:	90                      	nop
    25d7:	8d 65 f4                	lea    esp,[ebp-0xc]
    25da:	5b                      	pop    ebx
    25db:	5e                      	pop    esi
    25dc:	5f                      	pop    edi
    25dd:	5d                      	pop    ebp
    25de:	c3                      	ret    

000025df <arrays_multiDimensionalJagged>:

//-----------------------------------------------------------------------------

void arrays_multiDimensionalJagged() {
    25df:	55                      	push   ebp
    25e0:	89 e5                   	mov    ebp,esp
    25e2:	53                      	push   ebx
    25e3:	83 ec 34                	sub    esp,0x34
    25e6:	e8 fc ff ff ff          	call   25e7 <arrays_multiDimensionalJagged+0x8>
    25eb:	81 c3 02 00 00 00       	add    ebx,0x2

	// jagged array sample
	// refer https://en.wikipedia.org/wiki/Jagged_array
	int** values = NULL;
    25f1:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0

    // TODO : implement check for return value of all "malloc()"s for an allocation error
    int arrayCount = 3;
    25f8:	c7 45 e8 03 00 00 00    	mov    DWORD PTR [ebp-0x18],0x3
    values = (int**) malloc( arrayCount * sizeof(int*) );
    25ff:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    2602:	c1 e0 02                	shl    eax,0x2
    2605:	83 ec 0c                	sub    esp,0xc
    2608:	50                      	push   eax
    2609:	e8 fc ff ff ff          	call   260a <arrays_multiDimensionalJagged+0x2b>
    260e:	83 c4 10                	add    esp,0x10
    2611:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

    const int leastElementCount = 2;
    2614:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x2
	for ( int i = 0; i < arrayCount; i++ ) {
    261b:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
    2622:	eb 7b                   	jmp    269f <arrays_multiDimensionalJagged+0xc0>

		int  length = i + leastElementCount;
    2624:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    2627:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    262a:	01 d0                   	add    eax,edx
    262c:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
		int* buffer = malloc( length * sizeof(int) );
    262f:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    2632:	c1 e0 02                	shl    eax,0x2
    2635:	83 ec 0c                	sub    esp,0xc
    2638:	50                      	push   eax
    2639:	e8 fc ff ff ff          	call   263a <arrays_multiDimensionalJagged+0x5b>
    263e:	83 c4 10                	add    esp,0x10
    2641:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

		values[ i ] = buffer;
    2644:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2647:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    264e:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2651:	01 c2                   	add    edx,eax
    2653:	8b 45 d4                	mov    eax,DWORD PTR [ebp-0x2c]
    2656:	89 02                   	mov    DWORD PTR [edx],eax

		// fill the buffer
		for ( int j = 0; j < length; j++ ) {
    2658:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
    265f:	eb 32                   	jmp    2693 <arrays_multiDimensionalJagged+0xb4>

			values[ i ][ j ] = i*10 + j;
    2661:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    2664:	89 d0                   	mov    eax,edx
    2666:	c1 e0 02                	shl    eax,0x2
    2669:	01 d0                   	add    eax,edx
    266b:	01 c0                   	add    eax,eax
    266d:	89 c1                   	mov    ecx,eax
    266f:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2672:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    2679:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    267c:	01 d0                   	add    eax,edx
    267e:	8b 10                   	mov    edx,DWORD PTR [eax]
    2680:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2683:	c1 e0 02                	shl    eax,0x2
    2686:	01 d0                   	add    eax,edx
    2688:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
    268b:	01 ca                   	add    edx,ecx
    268d:	89 10                   	mov    DWORD PTR [eax],edx
		for ( int j = 0; j < length; j++ ) {
    268f:	83 45 f0 01             	add    DWORD PTR [ebp-0x10],0x1
    2693:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2696:	3b 45 d8                	cmp    eax,DWORD PTR [ebp-0x28]
    2699:	7c c6                   	jl     2661 <arrays_multiDimensionalJagged+0x82>
	for ( int i = 0; i < arrayCount; i++ ) {
    269b:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1
    269f:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    26a2:	3b 45 e8                	cmp    eax,DWORD PTR [ebp-0x18]
    26a5:	0f 8c 79 ff ff ff       	jl     2624 <arrays_multiDimensionalJagged+0x45>
		}//forj

	}//fori


	int distanceAsBytes = (int)&values[0][0] - (int)&values[1][0];
    26ab:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26ae:	8b 00                   	mov    eax,DWORD PTR [eax]
    26b0:	89 c2                   	mov    edx,eax
    26b2:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26b5:	83 c0 04                	add    eax,0x4
    26b8:	8b 00                   	mov    eax,DWORD PTR [eax]
    26ba:	89 c1                   	mov    ecx,eax
    26bc:	89 d0                   	mov    eax,edx
    26be:	29 c8                   	sub    eax,ecx
    26c0:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax

	// see disassembly
	int value = 0;
    26c3:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
	value = values[0][0];
    26ca:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26cd:	8b 00                   	mov    eax,DWORD PTR [eax]
    26cf:	8b 00                   	mov    eax,DWORD PTR [eax]
    26d1:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = values[0][1];
    26d4:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26d7:	8b 00                   	mov    eax,DWORD PTR [eax]
    26d9:	8b 40 04                	mov    eax,DWORD PTR [eax+0x4]
    26dc:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = values[0][2];
    26df:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26e2:	8b 00                   	mov    eax,DWORD PTR [eax]
    26e4:	8b 40 08                	mov    eax,DWORD PTR [eax+0x8]
    26e7:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	value = values[1][0];
    26ea:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26ed:	83 c0 04                	add    eax,0x4
    26f0:	8b 00                   	mov    eax,DWORD PTR [eax]
    26f2:	8b 00                   	mov    eax,DWORD PTR [eax]
    26f4:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = values[1][1];
    26f7:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    26fa:	83 c0 04                	add    eax,0x4
    26fd:	8b 00                   	mov    eax,DWORD PTR [eax]
    26ff:	8b 40 04                	mov    eax,DWORD PTR [eax+0x4]
    2702:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = values[1][2];
    2705:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2708:	83 c0 04                	add    eax,0x4
    270b:	8b 00                   	mov    eax,DWORD PTR [eax]
    270d:	8b 40 08                	mov    eax,DWORD PTR [eax+0x8]
    2710:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	value = values[2][0];
    2713:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2716:	83 c0 08                	add    eax,0x8
    2719:	8b 00                   	mov    eax,DWORD PTR [eax]
    271b:	8b 00                   	mov    eax,DWORD PTR [eax]
    271d:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = values[2][1];
    2720:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2723:	83 c0 08                	add    eax,0x8
    2726:	8b 00                   	mov    eax,DWORD PTR [eax]
    2728:	8b 40 04                	mov    eax,DWORD PTR [eax+0x4]
    272b:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = values[2][2];
    272e:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2731:	83 c0 08                	add    eax,0x8
    2734:	8b 00                   	mov    eax,DWORD PTR [eax]
    2736:	8b 40 08                	mov    eax,DWORD PTR [eax+0x8]
    2739:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	// TODO : we need lots of "free()"s here...

}//arrays_multiDimensionalJagged
    273c:	90                      	nop
    273d:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    2740:	c9                      	leave  
    2741:	c3                      	ret    

00002742 <arrays_multiDimensionalJaggedvsFlat>:

//-----------------------------------------------------------------------------

void arrays_multiDimensionalJaggedvsFlat() {
    2742:	55                      	push   ebp
    2743:	89 e5                   	mov    ebp,esp
    2745:	53                      	push   ebx
    2746:	83 ec 54                	sub    esp,0x54
    2749:	e8 fc ff ff ff          	call   274a <arrays_multiDimensionalJaggedvsFlat+0x8>
    274e:	81 c3 02 00 00 00       	add    ebx,0x2

	// jagged array sample
	// refer https://en.wikipedia.org/wiki/Jagged_array

	int** jagged = NULL;
    2754:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
    int   flat[3][3] = { {0,1,2}, {10,11,12}, {20,21,22} };
    275b:	c7 45 b0 00 00 00 00    	mov    DWORD PTR [ebp-0x50],0x0
    2762:	c7 45 b4 01 00 00 00    	mov    DWORD PTR [ebp-0x4c],0x1
    2769:	c7 45 b8 02 00 00 00    	mov    DWORD PTR [ebp-0x48],0x2
    2770:	c7 45 bc 0a 00 00 00    	mov    DWORD PTR [ebp-0x44],0xa
    2777:	c7 45 c0 0b 00 00 00    	mov    DWORD PTR [ebp-0x40],0xb
    277e:	c7 45 c4 0c 00 00 00    	mov    DWORD PTR [ebp-0x3c],0xc
    2785:	c7 45 c8 14 00 00 00    	mov    DWORD PTR [ebp-0x38],0x14
    278c:	c7 45 cc 15 00 00 00    	mov    DWORD PTR [ebp-0x34],0x15
    2793:	c7 45 d0 16 00 00 00    	mov    DWORD PTR [ebp-0x30],0x16

    // TODO : implement check for return value of all "malloc"s for an allocation error
    int arrayCount = 3;
    279a:	c7 45 e8 03 00 00 00    	mov    DWORD PTR [ebp-0x18],0x3
    jagged = (int**) malloc( 2 * sizeof(int*) );
    27a1:	83 ec 0c                	sub    esp,0xc
    27a4:	6a 08                   	push   0x8
    27a6:	e8 fc ff ff ff          	call   27a7 <arrays_multiDimensionalJaggedvsFlat+0x65>
    27ab:	83 c4 10                	add    esp,0x10
    27ae:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

    const int leastElementCount = 2;
    27b1:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x2
	for ( int i = 0; i < arrayCount; i++ ) {
    27b8:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
    27bf:	eb 7b                   	jmp    283c <arrays_multiDimensionalJaggedvsFlat+0xfa>

		int  length = i + leastElementCount;
    27c1:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    27c4:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    27c7:	01 d0                   	add    eax,edx
    27c9:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
		int* buffer = malloc( length * sizeof(int) );
    27cc:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    27cf:	c1 e0 02                	shl    eax,0x2
    27d2:	83 ec 0c                	sub    esp,0xc
    27d5:	50                      	push   eax
    27d6:	e8 fc ff ff ff          	call   27d7 <arrays_multiDimensionalJaggedvsFlat+0x95>
    27db:	83 c4 10                	add    esp,0x10
    27de:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

		jagged[ i ] = buffer;
    27e1:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    27e4:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    27eb:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    27ee:	01 c2                   	add    edx,eax
    27f0:	8b 45 d4                	mov    eax,DWORD PTR [ebp-0x2c]
    27f3:	89 02                   	mov    DWORD PTR [edx],eax

		// fill the buffer
		for ( int j = 0; j < length; j++ ) {
    27f5:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
    27fc:	eb 32                   	jmp    2830 <arrays_multiDimensionalJaggedvsFlat+0xee>

			jagged[ i ][ j ] = i*10 + j;
    27fe:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    2801:	89 d0                   	mov    eax,edx
    2803:	c1 e0 02                	shl    eax,0x2
    2806:	01 d0                   	add    eax,edx
    2808:	01 c0                   	add    eax,eax
    280a:	89 c1                   	mov    ecx,eax
    280c:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    280f:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    2816:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2819:	01 d0                   	add    eax,edx
    281b:	8b 10                   	mov    edx,DWORD PTR [eax]
    281d:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2820:	c1 e0 02                	shl    eax,0x2
    2823:	01 d0                   	add    eax,edx
    2825:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
    2828:	01 ca                   	add    edx,ecx
    282a:	89 10                   	mov    DWORD PTR [eax],edx
		for ( int j = 0; j < length; j++ ) {
    282c:	83 45 f0 01             	add    DWORD PTR [ebp-0x10],0x1
    2830:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2833:	3b 45 d8                	cmp    eax,DWORD PTR [ebp-0x28]
    2836:	7c c6                   	jl     27fe <arrays_multiDimensionalJaggedvsFlat+0xbc>
	for ( int i = 0; i < arrayCount; i++ ) {
    2838:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1
    283c:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    283f:	3b 45 e8                	cmp    eax,DWORD PTR [ebp-0x18]
    2842:	0f 8c 79 ff ff ff       	jl     27c1 <arrays_multiDimensionalJaggedvsFlat+0x7f>

		}//forj

	}//fori

	int distanceAsBytes = 0;
    2848:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [ebp-0x20],0x0
	distanceAsBytes = (int)&jagged[0][0] - (int)&jagged[1][0];
    284f:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2852:	8b 00                   	mov    eax,DWORD PTR [eax]
    2854:	89 c2                   	mov    edx,eax
    2856:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2859:	83 c0 04                	add    eax,0x4
    285c:	8b 00                   	mov    eax,DWORD PTR [eax]
    285e:	89 c1                   	mov    ecx,eax
    2860:	89 d0                   	mov    eax,edx
    2862:	29 c8                   	sub    eax,ecx
    2864:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax
	distanceAsBytes = (int)&flat[0][0]   - (int)&flat[1][0];
    2867:	c7 45 e0 f4 ff ff ff    	mov    DWORD PTR [ebp-0x20],0xfffffff4

	// see disassembly
	int value = 0;
    286e:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0

	value = flat[0][0];
    2875:	8b 45 b0                	mov    eax,DWORD PTR [ebp-0x50]
    2878:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = jagged[0][0];
    287b:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    287e:	8b 00                   	mov    eax,DWORD PTR [eax]
    2880:	8b 00                   	mov    eax,DWORD PTR [eax]
    2882:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	value = jagged[0][0];
    2885:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2888:	8b 00                   	mov    eax,DWORD PTR [eax]
    288a:	8b 00                   	mov    eax,DWORD PTR [eax]
    288c:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = jagged[0][1];
    288f:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    2892:	8b 00                   	mov    eax,DWORD PTR [eax]
    2894:	8b 40 04                	mov    eax,DWORD PTR [eax+0x4]
    2897:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = jagged[0][2];
    289a:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    289d:	8b 00                   	mov    eax,DWORD PTR [eax]
    289f:	8b 40 08                	mov    eax,DWORD PTR [eax+0x8]
    28a2:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	value = jagged[1][0];
    28a5:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    28a8:	83 c0 04                	add    eax,0x4
    28ab:	8b 00                   	mov    eax,DWORD PTR [eax]
    28ad:	8b 00                   	mov    eax,DWORD PTR [eax]
    28af:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = jagged[1][1];
    28b2:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    28b5:	83 c0 04                	add    eax,0x4
    28b8:	8b 00                   	mov    eax,DWORD PTR [eax]
    28ba:	8b 40 04                	mov    eax,DWORD PTR [eax+0x4]
    28bd:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = jagged[1][2];
    28c0:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    28c3:	83 c0 04                	add    eax,0x4
    28c6:	8b 00                   	mov    eax,DWORD PTR [eax]
    28c8:	8b 40 08                	mov    eax,DWORD PTR [eax+0x8]
    28cb:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	value = flat[0][0];
    28ce:	8b 45 b0                	mov    eax,DWORD PTR [ebp-0x50]
    28d1:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = flat[0][1];
    28d4:	8b 45 b4                	mov    eax,DWORD PTR [ebp-0x4c]
    28d7:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = flat[0][2];
    28da:	8b 45 b8                	mov    eax,DWORD PTR [ebp-0x48]
    28dd:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	value = flat[1][0];
    28e0:	8b 45 bc                	mov    eax,DWORD PTR [ebp-0x44]
    28e3:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = flat[1][1];
    28e6:	8b 45 c0                	mov    eax,DWORD PTR [ebp-0x40]
    28e9:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax
	value = flat[1][2];
    28ec:	8b 45 c4                	mov    eax,DWORD PTR [ebp-0x3c]
    28ef:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	// TODO : we need lots of "free()"s here...

}//arrays_multiDimensionalJagged
    28f2:	90                      	nop
    28f3:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    28f6:	c9                      	leave  
    28f7:	c3                      	ret    

000028f8 <setBit>:

typedef unsigned char byte;
typedef unsigned int doubleword;
typedef enum { zero, one } BitValue;

doubleword setBit( doubleword value, byte bitIndex ) {
    28f8:	55                      	push   ebp
    28f9:	89 e5                   	mov    ebp,esp
    28fb:	83 ec 14                	sub    esp,0x14
    28fe:	e8 fc ff ff ff          	call   28ff <setBit+0x7>
    2903:	05 01 00 00 00          	add    eax,0x1
    2908:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    290b:	88 45 ec                	mov    BYTE PTR [ebp-0x14],al

	doubleword mask = 0;
    290e:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0

	mask = (unsigned) 1 << bitIndex;
    2915:	0f b6 45 ec             	movzx  eax,BYTE PTR [ebp-0x14]
    2919:	ba 01 00 00 00          	mov    edx,0x1
    291e:	89 c1                   	mov    ecx,eax
    2920:	d3 e2                   	shl    edx,cl
    2922:	89 d0                   	mov    eax,edx
    2924:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
    value |= mask;
    2927:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    292a:	09 45 08                	or     DWORD PTR [ebp+0x8],eax

	return value;
    292d:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]

}//setBit
    2930:	c9                      	leave  
    2931:	c3                      	ret    

00002932 <resetBit>:

doubleword resetBit( doubleword value, byte bitIndex ) {
    2932:	55                      	push   ebp
    2933:	89 e5                   	mov    ebp,esp
    2935:	83 ec 14                	sub    esp,0x14
    2938:	e8 fc ff ff ff          	call   2939 <resetBit+0x7>
    293d:	05 01 00 00 00          	add    eax,0x1
    2942:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    2945:	88 45 ec                	mov    BYTE PTR [ebp-0x14],al

	doubleword mask = 0;
    2948:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0

	mask = (unsigned) 1 << bitIndex;
    294f:	0f b6 45 ec             	movzx  eax,BYTE PTR [ebp-0x14]
    2953:	ba 01 00 00 00          	mov    edx,0x1
    2958:	89 c1                   	mov    ecx,eax
    295a:	d3 e2                   	shl    edx,cl
    295c:	89 d0                   	mov    eax,edx
    295e:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
	mask = ~mask;
    2961:	f7 55 fc                	not    DWORD PTR [ebp-0x4]

	value &= mask;
    2964:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    2967:	21 45 08                	and    DWORD PTR [ebp+0x8],eax

	return value;
    296a:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]

}//resetBit
    296d:	c9                      	leave  
    296e:	c3                      	ret    

0000296f <readBit>:

BitValue readBit( doubleword value, byte bitIndex ) {
    296f:	55                      	push   ebp
    2970:	89 e5                   	mov    ebp,esp
    2972:	83 ec 14                	sub    esp,0x14
    2975:	e8 fc ff ff ff          	call   2976 <readBit+0x7>
    297a:	05 01 00 00 00          	add    eax,0x1
    297f:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    2982:	88 45 ec                	mov    BYTE PTR [ebp-0x14],al

	doubleword mask = 0;
    2985:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0

	mask = (unsigned) 1 << bitIndex;
    298c:	0f b6 45 ec             	movzx  eax,BYTE PTR [ebp-0x14]
    2990:	ba 01 00 00 00          	mov    edx,0x1
    2995:	89 c1                   	mov    ecx,eax
    2997:	d3 e2                   	shl    edx,cl
    2999:	89 d0                   	mov    eax,edx
    299b:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
	mask = ~mask;
    299e:	f7 55 fc                	not    DWORD PTR [ebp-0x4]

	return (value & mask) ? one : zero;
    29a1:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    29a4:	23 45 fc                	and    eax,DWORD PTR [ebp-0x4]
    29a7:	85 c0                   	test   eax,eax
    29a9:	0f 95 c0                	setne  al
    29ac:	0f b6 c0                	movzx  eax,al

}//readBit
    29af:	c9                      	leave  
    29b0:	c3                      	ret    

000029b1 <xorSwap>:

void xorSwap( doubleword* pValueA, doubleword* pValueB ) {
    29b1:	55                      	push   ebp
    29b2:	89 e5                   	mov    ebp,esp
    29b4:	e8 fc ff ff ff          	call   29b5 <xorSwap+0x4>
    29b9:	05 01 00 00 00          	add    eax,0x1

	if ( *pValueA == *pValueA )
		return;
    29be:	90                      	nop
    *pValueB ^= *pValueA;
    *pValueA ^= *pValueB;

    //*pValueA ^= *pValueB ^= *pValueA ^= *pValueB;

}//xorSwap
    29bf:	5d                      	pop    ebp
    29c0:	c3                      	ret    

000029c1 <xorIsNonDestructiveOperation>:

void xorIsNonDestructiveOperation( void ) {
    29c1:	55                      	push   ebp
    29c2:	89 e5                   	mov    ebp,esp
    29c4:	83 ec 50                	sub    esp,0x50
    29c7:	e8 fc ff ff ff          	call   29c8 <xorIsNonDestructiveOperation+0x7>
    29cc:	05 01 00 00 00          	add    eax,0x1

   int value = 0xF0000000;
    29d1:	c7 45 f4 00 00 00 f0    	mov    DWORD PTR [ebp-0xc],0xf0000000

   value = value ^ value;
    29d8:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   value ^= value;
    29df:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
   value ^= value;
    29e6:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   value = 0xFFFF0000;
    29ed:	c7 45 f4 00 00 ff ff    	mov    DWORD PTR [ebp-0xc],0xffff0000

   value ^= value;
    29f4:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
   value ^= value;
    29fb:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

   byte cipherKey = '#';
    2a02:	c6 45 f3 23             	mov    BYTE PTR [ebp-0xd],0x23
   char message[] = "look to my coming on the first light of the fifth day";
    2a06:	c7 45 bd 6c 6f 6f 6b    	mov    DWORD PTR [ebp-0x43],0x6b6f6f6c
    2a0d:	c7 45 c1 20 74 6f 20    	mov    DWORD PTR [ebp-0x3f],0x206f7420
    2a14:	c7 45 c5 6d 79 20 63    	mov    DWORD PTR [ebp-0x3b],0x6320796d
    2a1b:	c7 45 c9 6f 6d 69 6e    	mov    DWORD PTR [ebp-0x37],0x6e696d6f
    2a22:	c7 45 cd 67 20 6f 6e    	mov    DWORD PTR [ebp-0x33],0x6e6f2067
    2a29:	c7 45 d1 20 74 68 65    	mov    DWORD PTR [ebp-0x2f],0x65687420
    2a30:	c7 45 d5 20 66 69 72    	mov    DWORD PTR [ebp-0x2b],0x72696620
    2a37:	c7 45 d9 73 74 20 6c    	mov    DWORD PTR [ebp-0x27],0x6c207473
    2a3e:	c7 45 dd 69 67 68 74    	mov    DWORD PTR [ebp-0x23],0x74686769
    2a45:	c7 45 e1 20 6f 66 20    	mov    DWORD PTR [ebp-0x1f],0x20666f20
    2a4c:	c7 45 e5 74 68 65 20    	mov    DWORD PTR [ebp-0x1b],0x20656874
    2a53:	c7 45 e9 66 69 66 74    	mov    DWORD PTR [ebp-0x17],0x74666966
    2a5a:	c7 45 ed 68 20 64 61    	mov    DWORD PTR [ebp-0x13],0x61642068
    2a61:	66 c7 45 f1 79 00       	mov    WORD PTR [ebp-0xf],0x79

   // cipher
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2a67:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
    2a6e:	eb 1f                   	jmp    2a8f <xorIsNonDestructiveOperation+0xce>

	   message[ i ] ^= (char) cipherKey;
    2a70:	8d 55 bd                	lea    edx,[ebp-0x43]
    2a73:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    2a76:	01 d0                   	add    eax,edx
    2a78:	0f b6 10                	movzx  edx,BYTE PTR [eax]
    2a7b:	0f b6 45 f3             	movzx  eax,BYTE PTR [ebp-0xd]
    2a7f:	31 c2                   	xor    edx,eax
    2a81:	8d 4d bd                	lea    ecx,[ebp-0x43]
    2a84:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    2a87:	01 c8                   	add    eax,ecx
    2a89:	88 10                   	mov    BYTE PTR [eax],dl
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2a8b:	83 45 fc 01             	add    DWORD PTR [ebp-0x4],0x1
    2a8f:	8d 55 bd                	lea    edx,[ebp-0x43]
    2a92:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    2a95:	01 d0                   	add    eax,edx
    2a97:	0f b6 00                	movzx  eax,BYTE PTR [eax]
    2a9a:	84 c0                   	test   al,al
    2a9c:	75 d2                   	jne    2a70 <xorIsNonDestructiveOperation+0xaf>

   }

   // decipher
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2a9e:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
    2aa5:	eb 1f                   	jmp    2ac6 <xorIsNonDestructiveOperation+0x105>

	   message[ i ] ^= (char) cipherKey;
    2aa7:	8d 55 bd                	lea    edx,[ebp-0x43]
    2aaa:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    2aad:	01 d0                   	add    eax,edx
    2aaf:	0f b6 10                	movzx  edx,BYTE PTR [eax]
    2ab2:	0f b6 45 f3             	movzx  eax,BYTE PTR [ebp-0xd]
    2ab6:	31 c2                   	xor    edx,eax
    2ab8:	8d 4d bd                	lea    ecx,[ebp-0x43]
    2abb:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    2abe:	01 c8                   	add    eax,ecx
    2ac0:	88 10                   	mov    BYTE PTR [eax],dl
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2ac2:	83 45 f8 01             	add    DWORD PTR [ebp-0x8],0x1
    2ac6:	8d 55 bd                	lea    edx,[ebp-0x43]
    2ac9:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    2acc:	01 d0                   	add    eax,edx
    2ace:	0f b6 00                	movzx  eax,BYTE PTR [eax]
    2ad1:	84 c0                   	test   al,al
    2ad3:	75 d2                   	jne    2aa7 <xorIsNonDestructiveOperation+0xe6>

   }

}//xorIsNonDestructiveOperation
    2ad5:	90                      	nop
    2ad6:	90                      	nop
    2ad7:	c9                      	leave  
    2ad8:	c3                      	ret    

00002ad9 <getHighNibble>:

#define CLEAR_LOW_NIBBLE (4)
#define CLEAR_HIGH_NIBBLE (0xF)

byte getHighNibble( byte value ) {
    2ad9:	55                      	push   ebp
    2ada:	89 e5                   	mov    ebp,esp
    2adc:	83 ec 04                	sub    esp,0x4
    2adf:	e8 fc ff ff ff          	call   2ae0 <getHighNibble+0x7>
    2ae4:	05 01 00 00 00          	add    eax,0x1
    2ae9:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2aec:	88 45 fc                	mov    BYTE PTR [ebp-0x4],al

	return (byte)( value >> CLEAR_LOW_NIBBLE );
    2aef:	0f b6 45 fc             	movzx  eax,BYTE PTR [ebp-0x4]
    2af3:	c0 e8 04                	shr    al,0x4

}//getHighNibble
    2af6:	c9                      	leave  
    2af7:	c3                      	ret    

00002af8 <getLowNibble>:

byte getLowNibble( byte value ) {
    2af8:	55                      	push   ebp
    2af9:	89 e5                   	mov    ebp,esp
    2afb:	83 ec 04                	sub    esp,0x4
    2afe:	e8 fc ff ff ff          	call   2aff <getLowNibble+0x7>
    2b03:	05 01 00 00 00          	add    eax,0x1
    2b08:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2b0b:	88 45 fc                	mov    BYTE PTR [ebp-0x4],al

	return value & CLEAR_HIGH_NIBBLE;
    2b0e:	0f b6 45 fc             	movzx  eax,BYTE PTR [ebp-0x4]
    2b12:	83 e0 0f                	and    eax,0xf

}//getLowNibble
    2b15:	c9                      	leave  
    2b16:	c3                      	ret    

00002b17 <bitManipulation>:

void bitManipulation() {
    2b17:	55                      	push   ebp
    2b18:	89 e5                   	mov    ebp,esp
    2b1a:	53                      	push   ebx
    2b1b:	83 ec 20                	sub    esp,0x20
    2b1e:	e8 fc ff ff ff          	call   2b1f <bitManipulation+0x8>
    2b23:	81 c3 02 00 00 00       	add    ebx,0x2

	BitValue valueAsBit = 0;
    2b29:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
	int      result     = 0;
    2b30:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
	int      testValue  = 6; // 00000000000000000000000000000110
    2b37:	c7 45 f0 06 00 00 00    	mov    DWORD PTR [ebp-0x10],0x6

	valueAsBit = readBit( testValue, 2 );
    2b3e:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2b41:	6a 02                   	push   0x2
    2b43:	50                      	push   eax
    2b44:	e8 fc ff ff ff          	call   2b45 <bitManipulation+0x2e>
    2b49:	83 c4 08                	add    esp,0x8
    2b4c:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax

	result = resetBit( testValue, 2 );
    2b4f:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2b52:	6a 02                   	push   0x2
    2b54:	50                      	push   eax
    2b55:	e8 fc ff ff ff          	call   2b56 <bitManipulation+0x3f>
    2b5a:	83 c4 08                	add    esp,0x8
    2b5d:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	result = setBit( result, 2 );
    2b60:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2b63:	6a 02                   	push   0x2
    2b65:	50                      	push   eax
    2b66:	e8 fc ff ff ff          	call   2b67 <bitManipulation+0x50>
    2b6b:	83 c4 08                	add    esp,0x8
    2b6e:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	const byte mostSignificantBit  = 31;
    2b71:	c6 45 ef 1f             	mov    BYTE PTR [ebp-0x11],0x1f
	const byte leastSignificantBit = 0;
    2b75:	c6 45 ee 00             	mov    BYTE PTR [ebp-0x12],0x0

	// negatif ?
	result = setBit( result, mostSignificantBit );
    2b79:	0f b6 55 ef             	movzx  edx,BYTE PTR [ebp-0x11]
    2b7d:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2b80:	52                      	push   edx
    2b81:	50                      	push   eax
    2b82:	e8 fc ff ff ff          	call   2b83 <bitManipulation+0x6c>
    2b87:	83 c4 08                	add    esp,0x8
    2b8a:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	result = setBit( result, leastSignificantBit );
    2b8d:	0f b6 55 ee             	movzx  edx,BYTE PTR [ebp-0x12]
    2b91:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2b94:	52                      	push   edx
    2b95:	50                      	push   eax
    2b96:	e8 fc ff ff ff          	call   2b97 <bitManipulation+0x80>
    2b9b:	83 c4 08                	add    esp,0x8
    2b9e:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	result = resetBit( result, leastSignificantBit );
    2ba1:	0f b6 55 ee             	movzx  edx,BYTE PTR [ebp-0x12]
    2ba5:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2ba8:	52                      	push   edx
    2ba9:	50                      	push   eax
    2baa:	e8 fc ff ff ff          	call   2bab <bitManipulation+0x94>
    2baf:	83 c4 08                	add    esp,0x8
    2bb2:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	result = resetBit( result, mostSignificantBit );
    2bb5:	0f b6 55 ef             	movzx  edx,BYTE PTR [ebp-0x11]
    2bb9:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2bbc:	52                      	push   edx
    2bbd:	50                      	push   eax
    2bbe:	e8 fc ff ff ff          	call   2bbf <bitManipulation+0xa8>
    2bc3:	83 c4 08                	add    esp,0x8
    2bc6:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	int a = 3;
    2bc9:	c7 45 e0 03 00 00 00    	mov    DWORD PTR [ebp-0x20],0x3
	int b = 5;
    2bd0:	c7 45 dc 05 00 00 00    	mov    DWORD PTR [ebp-0x24],0x5
	xorSwap( &a, &b );
    2bd7:	8d 45 dc                	lea    eax,[ebp-0x24]
    2bda:	50                      	push   eax
    2bdb:	8d 45 e0                	lea    eax,[ebp-0x20]
    2bde:	50                      	push   eax
    2bdf:	e8 fc ff ff ff          	call   2be0 <bitManipulation+0xc9>
    2be4:	83 c4 08                	add    esp,0x8

	xorIsNonDestructiveOperation();
    2be7:	e8 fc ff ff ff          	call   2be8 <bitManipulation+0xd1>

	result = getLowNibble( 221 );
    2bec:	68 dd 00 00 00          	push   0xdd
    2bf1:	e8 fc ff ff ff          	call   2bf2 <bitManipulation+0xdb>
    2bf6:	83 c4 04                	add    esp,0x4
    2bf9:	0f b6 c0                	movzx  eax,al
    2bfc:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	result = getHighNibble( 221 );
    2bff:	68 dd 00 00 00          	push   0xdd
    2c04:	e8 fc ff ff ff          	call   2c05 <bitManipulation+0xee>
    2c09:	83 c4 04                	add    esp,0x4
    2c0c:	0f b6 c0                	movzx  eax,al
    2c0f:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	result = getLowNibble( 13 );
    2c12:	6a 0d                   	push   0xd
    2c14:	e8 fc ff ff ff          	call   2c15 <bitManipulation+0xfe>
    2c19:	83 c4 04                	add    esp,0x4
    2c1c:	0f b6 c0                	movzx  eax,al
    2c1f:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	result = getHighNibble( 208 );
    2c22:	68 d0 00 00 00          	push   0xd0
    2c27:	e8 fc ff ff ff          	call   2c28 <bitManipulation+0x111>
    2c2c:	83 c4 04                	add    esp,0x4
    2c2f:	0f b6 c0                	movzx  eax,al
    2c32:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	float fA = 2.99F;
    2c35:	d9 83 1c 05 00 00       	fld    DWORD PTR [ebx+0x51c]
    2c3b:	d9 5d e8                	fstp   DWORD PTR [ebp-0x18]
	float fB = 1.99F;
    2c3e:	d9 83 20 05 00 00       	fld    DWORD PTR [ebx+0x520]
    2c44:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]
	//result = fA & fB; // error invalid operands

}//bitManipulation
    2c47:	90                      	nop
    2c48:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    2c4b:	c9                      	leave  
    2c4c:	c3                      	ret    

00002c4d <bitFields>:
     unsigned track         : 9;
     unsigned sector        : 5;
     unsigned command       : 5;
} DiskRegister;

void bitFields( void ) {
    2c4d:	55                      	push   ebp
    2c4e:	89 e5                   	mov    ebp,esp
    2c50:	83 ec 10                	sub    esp,0x10
    2c53:	e8 fc ff ff ff          	call   2c54 <bitFields+0x7>
    2c58:	05 01 00 00 00          	add    eax,0x1

	int size = 0;
    2c5d:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
	size = sizeof(FancyChar);
    2c64:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [ebp-0x4],0x2
    size = sizeof(Minireal);
    2c6b:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [ebp-0x4],0x4
    size = sizeof(DiskRegister);
    2c72:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [ebp-0x4],0x4

    // blinking underlined red "A"
    FancyChar character = { 'A',red, true, true };
    2c79:	0f b7 80 60 02 00 00    	movzx  eax,WORD PTR [eax+0x260]
    2c80:	66 89 45 fa             	mov    WORD PTR [ebp-0x6],ax

    character.underline = false;
    2c84:	0f b6 45 fb             	movzx  eax,BYTE PTR [ebp-0x5]
    2c88:	83 e0 ef                	and    eax,0xffffffef
    2c8b:	88 45 fb                	mov    BYTE PTR [ebp-0x5],al
    character.blink     = false;
    2c8e:	0f b6 45 fb             	movzx  eax,BYTE PTR [ebp-0x5]
    2c92:	83 e0 df                	and    eax,0xffffffdf
    2c95:	88 45 fb                	mov    BYTE PTR [ebp-0x5],al

	// +2345.678
	Minireal real = { 0, 2345, 1 };
    2c98:	0f b7 45 f4             	movzx  eax,WORD PTR [ebp-0xc]
    2c9c:	66 25 00 fc             	and    ax,0xfc00
    2ca0:	66 89 45 f4             	mov    WORD PTR [ebp-0xc],ax
    2ca4:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2ca7:	25 ff 03 00 80          	and    eax,0x800003ff
    2cac:	0d 00 a4 24 00          	or     eax,0x24a400
    2cb1:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
    2cb4:	0f b6 45 f7             	movzx  eax,BYTE PTR [ebp-0x9]
    2cb8:	83 c8 80                	or     eax,0xffffff80
    2cbb:	88 45 f7                	mov    BYTE PTR [ebp-0x9],al

	// -1234.567
	real.sign     = 1;
    2cbe:	0f b6 45 f7             	movzx  eax,BYTE PTR [ebp-0x9]
    2cc2:	83 c8 80                	or     eax,0xffffff80
    2cc5:	88 45 f7                	mov    BYTE PTR [ebp-0x9],al
	real.decimal  = 2345;
    2cc8:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2ccb:	25 ff 03 00 80          	and    eax,0x800003ff
    2cd0:	0d 00 a4 24 00          	or     eax,0x24a400
    2cd5:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	real.fraction = 0;
    2cd8:	0f b7 45 f4             	movzx  eax,WORD PTR [ebp-0xc]
    2cdc:	66 25 00 fc             	and    ax,0xfc00
    2ce0:	66 89 45 f4             	mov    WORD PTR [ebp-0xc],ax

}//bitFields
    2ce4:	90                      	nop
    2ce5:	c9                      	leave  
    2ce6:	c3                      	ret    

00002ce7 <swap>:

//-----------------------------------------------------------------------------

// fast executing small function ( gcc -std=c99 )
static inline void swap( int *x, int *y ) {
    2ce7:	55                      	push   ebp
    2ce8:	89 e5                   	mov    ebp,esp
    2cea:	e8 fc ff ff ff          	call   2ceb <swap+0x4>
    2cef:	05 01 00 00 00          	add    eax,0x1

    if ( x == y )
    2cf4:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2cf7:	3b 45 0c                	cmp    eax,DWORD PTR [ebp+0xc]
    2cfa:	74 35                   	je     2d31 <swap+0x4a>
    	return;

   *x ^= *y;
    2cfc:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2cff:	8b 10                   	mov    edx,DWORD PTR [eax]
    2d01:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    2d04:	8b 00                   	mov    eax,DWORD PTR [eax]
    2d06:	31 c2                   	xor    edx,eax
    2d08:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2d0b:	89 10                   	mov    DWORD PTR [eax],edx
	*y ^= *x;
    2d0d:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    2d10:	8b 10                   	mov    edx,DWORD PTR [eax]
    2d12:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2d15:	8b 00                   	mov    eax,DWORD PTR [eax]
    2d17:	31 c2                   	xor    edx,eax
    2d19:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    2d1c:	89 10                   	mov    DWORD PTR [eax],edx
	*x ^= *y;
    2d1e:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2d21:	8b 10                   	mov    edx,DWORD PTR [eax]
    2d23:	8b 45 0c                	mov    eax,DWORD PTR [ebp+0xc]
    2d26:	8b 00                   	mov    eax,DWORD PTR [eax]
    2d28:	31 c2                   	xor    edx,eax
    2d2a:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    2d2d:	89 10                   	mov    DWORD PTR [eax],edx
    2d2f:	eb 01                   	jmp    2d32 <swap+0x4b>
    	return;
    2d31:	90                      	nop

}//swap
    2d32:	5d                      	pop    ebp
    2d33:	c3                      	ret    

00002d34 <targetFound>:

//-----------------------------------------------------------------------------

void targetFound( void ) {
    2d34:	55                      	push   ebp
    2d35:	89 e5                   	mov    ebp,esp
    2d37:	53                      	push   ebx
    2d38:	83 ec 04                	sub    esp,0x4
    2d3b:	e8 fc ff ff ff          	call   2d3c <targetFound+0x8>
    2d40:	05 01 00 00 00          	add    eax,0x1
   printf( "Target value found." );
    2d45:	83 ec 0c                	sub    esp,0xc
    2d48:	8d 90 62 02 00 00       	lea    edx,[eax+0x262]
    2d4e:	52                      	push   edx
    2d4f:	89 c3                   	mov    ebx,eax
    2d51:	e8 fc ff ff ff          	call   2d52 <targetFound+0x1e>
    2d56:	83 c4 10                	add    esp,0x10
}//targetFound
    2d59:	90                      	nop
    2d5a:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    2d5d:	c9                      	leave  
    2d5e:	c3                      	ret    

00002d5f <goodGotosAlwaysBranchesForward>:

void goodGotosAlwaysBranchesForward() {
    2d5f:	55                      	push   ebp
    2d60:	89 e5                   	mov    ebp,esp
    2d62:	57                      	push   edi
    2d63:	56                      	push   esi
    2d64:	53                      	push   ebx
    2d65:	81 ec 8c 00 00 00       	sub    esp,0x8c
    2d6b:	e8 fc ff ff ff          	call   2d6c <goodGotosAlwaysBranchesForward+0xd>
    2d70:	81 c3 02 00 00 00       	add    ebx,0x2

	static const int meaningOfLife       = 42;
	static const unsigned int largePrime = 2147483647;

	int values[ 2 ][ 3 ][ 4 ] = {
    2d76:	8d 85 68 ff ff ff       	lea    eax,[ebp-0x98]
    2d7c:	8d 93 00 02 00 00       	lea    edx,[ebx+0x200]
    2d82:	b9 18 00 00 00          	mov    ecx,0x18
    2d87:	89 c7                   	mov    edi,eax
    2d89:	89 d6                   	mov    esi,edx
    2d8b:	f3 a5                   	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
		{
			{211, 212, 213, 214}, {221, 222, 223, 224}, {231, 232, 233, 234}
		}
	};

	const int sizeI = 4;
    2d8d:	c7 45 d8 04 00 00 00    	mov    DWORD PTR [ebp-0x28],0x4
	const int sizeJ = 3;
    2d94:	c7 45 d4 03 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x3
	const int sizeK = 2;
    2d9b:	c7 45 d0 02 00 00 00    	mov    DWORD PTR [ebp-0x30],0x2

	void *buffer = malloc( sizeof(values) );
    2da2:	83 ec 0c                	sub    esp,0xc
    2da5:	6a 60                   	push   0x60
    2da7:	e8 fc ff ff ff          	call   2da8 <goodGotosAlwaysBranchesForward+0x49>
    2dac:	83 c4 10                	add    esp,0x10
    2daf:	89 45 cc                	mov    DWORD PTR [ebp-0x34],eax

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == meaningOfLife )
    2db2:	e8 fc ff ff ff          	call   2db3 <goodGotosAlwaysBranchesForward+0x54>
    2db7:	8b 93 40 03 00 00       	mov    edx,DWORD PTR [ebx+0x340]
    2dbd:	39 d0                   	cmp    eax,edx
    2dbf:	0f 84 92 00 00 00       	je     2e57 <goodGotosAlwaysBranchesForward+0xf8>
	    goto CLEANUP;

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == largePrime )
    2dc5:	e8 fc ff ff ff          	call   2dc6 <goodGotosAlwaysBranchesForward+0x67>
    2dca:	8b 93 44 03 00 00       	mov    edx,DWORD PTR [ebx+0x344]
    2dd0:	39 d0                   	cmp    eax,edx
    2dd2:	0f 84 82 00 00 00       	je     2e5a <goodGotosAlwaysBranchesForward+0xfb>
	    goto CLEANUP;

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == NULL )
    2dd8:	e8 fc ff ff ff          	call   2dd9 <goodGotosAlwaysBranchesForward+0x7a>
    2ddd:	85 c0                   	test   eax,eax
    2ddf:	74 7c                   	je     2e5d <goodGotosAlwaysBranchesForward+0xfe>
	    goto CLEANUP;

	// bulunamadıysa aramaya devam
	int target = 222;
    2de1:	c7 45 c8 de 00 00 00    	mov    DWORD PTR [ebp-0x38],0xde
	for ( int k = 0; k < sizeK; k++ ) {
    2de8:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0
    2def:	eb 54                   	jmp    2e45 <goodGotosAlwaysBranchesForward+0xe6>

		for ( int j = 0; j < sizeJ; j++ ) {
    2df1:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [ebp-0x20],0x0
    2df8:	eb 3f                   	jmp    2e39 <goodGotosAlwaysBranchesForward+0xda>

			for ( int i = 0; i < sizeI; i++ ) {
    2dfa:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
    2e01:	eb 2a                   	jmp    2e2d <goodGotosAlwaysBranchesForward+0xce>

				if ( target == values[ k ][ j ][ i ] )
    2e03:	8b 55 e4                	mov    edx,DWORD PTR [ebp-0x1c]
    2e06:	89 d0                   	mov    eax,edx
    2e08:	01 c0                   	add    eax,eax
    2e0a:	01 d0                   	add    eax,edx
    2e0c:	8b 55 e0                	mov    edx,DWORD PTR [ebp-0x20]
    2e0f:	01 d0                   	add    eax,edx
    2e11:	8d 14 85 00 00 00 00    	lea    edx,[eax*4+0x0]
    2e18:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    2e1b:	01 d0                   	add    eax,edx
    2e1d:	8b 84 85 68 ff ff ff    	mov    eax,DWORD PTR [ebp+eax*4-0x98]
    2e24:	39 45 c8                	cmp    DWORD PTR [ebp-0x38],eax
    2e27:	74 26                   	je     2e4f <goodGotosAlwaysBranchesForward+0xf0>
			for ( int i = 0; i < sizeI; i++ ) {
    2e29:	83 45 dc 01             	add    DWORD PTR [ebp-0x24],0x1
    2e2d:	8b 45 dc                	mov    eax,DWORD PTR [ebp-0x24]
    2e30:	3b 45 d8                	cmp    eax,DWORD PTR [ebp-0x28]
    2e33:	7c ce                   	jl     2e03 <goodGotosAlwaysBranchesForward+0xa4>
		for ( int j = 0; j < sizeJ; j++ ) {
    2e35:	83 45 e0 01             	add    DWORD PTR [ebp-0x20],0x1
    2e39:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    2e3c:	3b 45 d4                	cmp    eax,DWORD PTR [ebp-0x2c]
    2e3f:	7c b9                   	jl     2dfa <goodGotosAlwaysBranchesForward+0x9b>
	for ( int k = 0; k < sizeK; k++ ) {
    2e41:	83 45 e4 01             	add    DWORD PTR [ebp-0x1c],0x1
    2e45:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    2e48:	3b 45 d0                	cmp    eax,DWORD PTR [ebp-0x30]
    2e4b:	7c a4                   	jl     2df1 <goodGotosAlwaysBranchesForward+0x92>

		}//forj

	}//fork

   goto CLEANUP;
    2e4d:	eb 0f                   	jmp    2e5e <goodGotosAlwaysBranchesForward+0xff>
				   goto MULTIBREAK;
    2e4f:	90                      	nop

MULTIBREAK:

   targetFound();
    2e50:	e8 fc ff ff ff          	call   2e51 <goodGotosAlwaysBranchesForward+0xf2>
    2e55:	eb 07                   	jmp    2e5e <goodGotosAlwaysBranchesForward+0xff>
	    goto CLEANUP;
    2e57:	90                      	nop
    2e58:	eb 04                   	jmp    2e5e <goodGotosAlwaysBranchesForward+0xff>
	    goto CLEANUP;
    2e5a:	90                      	nop
    2e5b:	eb 01                   	jmp    2e5e <goodGotosAlwaysBranchesForward+0xff>
	    goto CLEANUP;
    2e5d:	90                      	nop

CLEANUP:

	free( buffer );
    2e5e:	83 ec 0c                	sub    esp,0xc
    2e61:	ff 75 cc                	push   DWORD PTR [ebp-0x34]
    2e64:	e8 fc ff ff ff          	call   2e65 <goodGotosAlwaysBranchesForward+0x106>
    2e69:	83 c4 10                	add    esp,0x10

}//goodGotosAlwaysBranchesForward
    2e6c:	90                      	nop
    2e6d:	8d 65 f4                	lea    esp,[ebp-0xc]
    2e70:	5b                      	pop    ebx
    2e71:	5e                      	pop    esi
    2e72:	5f                      	pop    edi
    2e73:	5d                      	pop    ebp
    2e74:	c3                      	ret    

00002e75 <functions_recursiveFunction>:

//-----------------------------------------------------------------------------

int recursionLimit = 16;
void functions_recursiveFunction( void ) {
    2e75:	55                      	push   ebp
    2e76:	89 e5                   	mov    ebp,esp
    2e78:	83 ec 08                	sub    esp,0x8
    2e7b:	e8 fc ff ff ff          	call   2e7c <functions_recursiveFunction+0x7>
    2e80:	05 01 00 00 00          	add    eax,0x1

	if ( recursionLimit-- ) {
    2e85:	8b 90 00 00 00 00       	mov    edx,DWORD PTR [eax+0x0]
    2e8b:	8d 4a ff                	lea    ecx,[edx-0x1]
    2e8e:	89 88 00 00 00 00       	mov    DWORD PTR [eax+0x0],ecx
    2e94:	85 d2                   	test   edx,edx
    2e96:	74 05                   	je     2e9d <functions_recursiveFunction+0x28>
		functions_recursiveFunction();
    2e98:	e8 fc ff ff ff          	call   2e99 <functions_recursiveFunction+0x24>
	}

}//functions_recursiveFunction
    2e9d:	90                      	nop
    2e9e:	c9                      	leave  
    2e9f:	c3                      	ret    

00002ea0 <functions_recursiveFactorial>:

long long int functions_recursiveFactorial( long long int number ) {
    2ea0:	55                      	push   ebp
    2ea1:	89 e5                   	mov    ebp,esp
    2ea3:	53                      	push   ebx
    2ea4:	83 ec 14                	sub    esp,0x14
    2ea7:	e8 fc ff ff ff          	call   2ea8 <functions_recursiveFactorial+0x8>
    2eac:	81 c1 02 00 00 00       	add    ecx,0x2
    2eb2:	8b 4d 08                	mov    ecx,DWORD PTR [ebp+0x8]
    2eb5:	89 4d f0                	mov    DWORD PTR [ebp-0x10],ecx
    2eb8:	8b 4d 0c                	mov    ecx,DWORD PTR [ebp+0xc]
    2ebb:	89 4d f4                	mov    DWORD PTR [ebp-0xc],ecx
	} else {
	   return number * functions_recursiveFactorial( number - 1 );
	}
    */

	return number == 0 ? 1 : number * functions_recursiveFactorial( number - 1 );
    2ebe:	8b 4d f0                	mov    ecx,DWORD PTR [ebp-0x10]
    2ec1:	80 f5 00                	xor    ch,0x0
    2ec4:	89 c8                   	mov    eax,ecx
    2ec6:	8b 4d f4                	mov    ecx,DWORD PTR [ebp-0xc]
    2ec9:	80 f5 00                	xor    ch,0x0
    2ecc:	89 ca                   	mov    edx,ecx
    2ece:	09 d0                   	or     eax,edx
    2ed0:	85 c0                   	test   eax,eax
    2ed2:	74 32                   	je     2f06 <functions_recursiveFactorial+0x66>
    2ed4:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2ed7:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    2eda:	83 c0 ff                	add    eax,0xffffffff
    2edd:	83 d2 ff                	adc    edx,0xffffffff
    2ee0:	83 ec 08                	sub    esp,0x8
    2ee3:	52                      	push   edx
    2ee4:	50                      	push   eax
    2ee5:	e8 fc ff ff ff          	call   2ee6 <functions_recursiveFactorial+0x46>
    2eea:	83 c4 10                	add    esp,0x10
    2eed:	8b 4d f0                	mov    ecx,DWORD PTR [ebp-0x10]
    2ef0:	89 cb                   	mov    ebx,ecx
    2ef2:	0f af da                	imul   ebx,edx
    2ef5:	8b 4d f4                	mov    ecx,DWORD PTR [ebp-0xc]
    2ef8:	0f af c8                	imul   ecx,eax
    2efb:	01 d9                   	add    ecx,ebx
    2efd:	f7 65 f0                	mul    DWORD PTR [ebp-0x10]
    2f00:	01 d1                   	add    ecx,edx
    2f02:	89 ca                   	mov    edx,ecx
    2f04:	eb 0a                   	jmp    2f10 <functions_recursiveFactorial+0x70>
    2f06:	b8 01 00 00 00          	mov    eax,0x1
    2f0b:	ba 00 00 00 00          	mov    edx,0x0

}//functions_recursionFactorial
    2f10:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    2f13:	c9                      	leave  
    2f14:	c3                      	ret    

00002f15 <functions_sum>:

//-----------------------------------------------------------------------------

long long int functions_sum( int argc, ... ) {
    2f15:	55                      	push   ebp
    2f16:	89 e5                   	mov    ebp,esp
    2f18:	83 ec 10                	sub    esp,0x10
    2f1b:	e8 fc ff ff ff          	call   2f1c <functions_sum+0x7>
    2f20:	05 01 00 00 00          	add    eax,0x1

	long long int sum = 0;
    2f25:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
    2f2c:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
	va_list valist;

	// initialize macro
	va_start( valist, argc );
    2f33:	8d 45 0c                	lea    eax,[ebp+0xc]
    2f36:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

	for ( int i = 0; i < argc; i++)
    2f39:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
    2f40:	eb 16                   	jmp    2f58 <functions_sum+0x43>
	{
	   sum += va_arg( valist, int );
    2f42:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    2f45:	8d 50 04                	lea    edx,[eax+0x4]
    2f48:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
    2f4b:	8b 00                   	mov    eax,DWORD PTR [eax]
    2f4d:	99                      	cdq    
    2f4e:	01 45 f8                	add    DWORD PTR [ebp-0x8],eax
    2f51:	11 55 fc                	adc    DWORD PTR [ebp-0x4],edx
	for ( int i = 0; i < argc; i++)
    2f54:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1
    2f58:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    2f5b:	3b 45 08                	cmp    eax,DWORD PTR [ebp+0x8]
    2f5e:	7c e2                   	jl     2f42 <functions_sum+0x2d>
	}

	// clean valist left overs
	va_end( valist );

	return sum;
    2f60:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    2f63:	8b 55 fc                	mov    edx,DWORD PTR [ebp-0x4]

}//functions_sum
    2f66:	c9                      	leave  
    2f67:	c3                      	ret    

00002f68 <unions>:
	MixCSI     mixCSI;
	FloatBits  bits;

} VeryMix;

void unions( void ) {
    2f68:	55                      	push   ebp
    2f69:	89 e5                   	mov    ebp,esp
    2f6b:	53                      	push   ebx
    2f6c:	83 ec 40                	sub    esp,0x40
    2f6f:	e8 fc ff ff ff          	call   2f70 <unions+0x8>
    2f74:	05 01 00 00 00          	add    eax,0x1

   // left uninitialized
   FloatBits bits;
   size_t size = 0;
    2f79:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

   size = sizeof( bits );
    2f80:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

   bits.fv      = -3.14F;
    2f87:	d9 80 24 05 00 00       	fld    DWORD PTR [eax+0x524]
    2f8d:	d9 5d e0                	fstp   DWORD PTR [ebp-0x20]
   bits.bv.sign = 0;
    2f90:	0f b6 55 e3             	movzx  edx,BYTE PTR [ebp-0x1d]
    2f94:	83 e2 7f                	and    edx,0x7f
    2f97:	88 55 e3                	mov    BYTE PTR [ebp-0x1d],dl

   // initialize with zeros
   MixCSI mcsi = {};
    2f9a:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
   mcsi.iValue = 0xFAFBFCFD;
    2fa1:	c7 45 dc fd fc fb fa    	mov    DWORD PTR [ebp-0x24],0xfafbfcfd

   size = sizeof( MixCSI );
    2fa8:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

   char c = mcsi.cA;
    2faf:	0f b6 55 df             	movzx  edx,BYTE PTR [ebp-0x21]
    2fb3:	88 55 ef                	mov    BYTE PTR [ebp-0x11],dl

   c = mcsi.cB;
    2fb6:	0f b6 55 de             	movzx  edx,BYTE PTR [ebp-0x22]
    2fba:	88 55 ef                	mov    BYTE PTR [ebp-0x11],dl
   c = mcsi.cC;
    2fbd:	0f b6 55 dd             	movzx  edx,BYTE PTR [ebp-0x23]
    2fc1:	88 55 ef                	mov    BYTE PTR [ebp-0x11],dl
   c = mcsi.cD;
    2fc4:	0f b6 55 dc             	movzx  edx,BYTE PTR [ebp-0x24]
    2fc8:	88 55 ef                	mov    BYTE PTR [ebp-0x11],dl

   int s =  mcsi.sL;
    2fcb:	0f b7 55 dc             	movzx  edx,WORD PTR [ebp-0x24]
    2fcf:	0f bf d2                	movsx  edx,dx
    2fd2:	89 55 e8                	mov    DWORD PTR [ebp-0x18],edx
   s =  mcsi.sH;
    2fd5:	0f b7 55 de             	movzx  edx,WORD PTR [ebp-0x22]
    2fd9:	0f bf d2                	movsx  edx,dx
    2fdc:	89 55 e8                	mov    DWORD PTR [ebp-0x18],edx

   int i = mcsi.iValue;
    2fdf:	8b 55 dc                	mov    edx,DWORD PTR [ebp-0x24]
    2fe2:	89 55 e4                	mov    DWORD PTR [ebp-0x1c],edx

   mcsi.cD = 0xFF;
    2fe5:	c6 45 dc ff             	mov    BYTE PTR [ebp-0x24],0xff

   mcsi.sH = 0xF1F2;
    2fe9:	66 c7 45 de f2 f1       	mov    WORD PTR [ebp-0x22],0xf1f2

   int loop = 4;
    2fef:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [ebp-0x8],0x4
   while ( loop-- )
    2ff6:	eb 18                   	jmp    3010 <unions+0xa8>
	  mcsi.car[ loop ] = 68 - loop;
    2ff8:	8b 55 f8                	mov    edx,DWORD PTR [ebp-0x8]
    2ffb:	89 d1                   	mov    ecx,edx
    2ffd:	ba 44 00 00 00          	mov    edx,0x44
    3002:	29 ca                   	sub    edx,ecx
    3004:	89 d1                   	mov    ecx,edx
    3006:	8d 5d dc                	lea    ebx,[ebp-0x24]
    3009:	8b 55 f8                	mov    edx,DWORD PTR [ebp-0x8]
    300c:	01 da                   	add    edx,ebx
    300e:	88 0a                   	mov    BYTE PTR [edx],cl
   while ( loop-- )
    3010:	8b 55 f8                	mov    edx,DWORD PTR [ebp-0x8]
    3013:	8d 4a ff                	lea    ecx,[edx-0x1]
    3016:	89 4d f8                	mov    DWORD PTR [ebp-0x8],ecx
    3019:	85 d2                   	test   edx,edx
    301b:	75 db                   	jne    2ff8 <unions+0x90>

   // initialize with zeros
   Mix mix = {};
    301d:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [ebp-0x30],0x0
    3024:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x0
    302b:	c7 45 d8 00 00 00 00    	mov    DWORD PTR [ebp-0x28],0x0
   size = sizeof( Mix );
    3032:	c7 45 f0 0c 00 00 00    	mov    DWORD PTR [ebp-0x10],0xc

   mix.decimal = -3.14L;
    3039:	db a8 30 05 00 00       	fld    TBYTE PTR [eax+0x530]
    303f:	db 7d d0                	fstp   TBYTE PTR [ebp-0x30]
   mix.decimal = LDBL_MAX;
    3042:	db a8 40 05 00 00       	fld    TBYTE PTR [eax+0x540]
    3048:	db 7d d0                	fstp   TBYTE PTR [ebp-0x30]

   loop = 12;
    304b:	c7 45 f8 0c 00 00 00    	mov    DWORD PTR [ebp-0x8],0xc
   while ( loop-- )
    3052:	eb 18                   	jmp    306c <unions+0x104>
	  mix.text[ loop ] = 80 - loop;
    3054:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    3057:	89 c2                   	mov    edx,eax
    3059:	b8 50 00 00 00          	mov    eax,0x50
    305e:	29 d0                   	sub    eax,edx
    3060:	89 c2                   	mov    edx,eax
    3062:	8d 4d d0                	lea    ecx,[ebp-0x30]
    3065:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    3068:	01 c8                   	add    eax,ecx
    306a:	88 10                   	mov    BYTE PTR [eax],dl
   while ( loop-- )
    306c:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    306f:	8d 50 ff                	lea    edx,[eax-0x1]
    3072:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx
    3075:	85 c0                   	test   eax,eax
    3077:	75 db                   	jne    3054 <unions+0xec>


   // initialize with zeros
   VeryMix vmx = {};
    3079:	c7 45 c4 00 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x0
    3080:	c7 45 c8 00 00 00 00    	mov    DWORD PTR [ebp-0x38],0x0
    3087:	c7 45 cc 00 00 00 00    	mov    DWORD PTR [ebp-0x34],0x0
   char* pc = (char*) &vmx;
    308e:	8d 45 c4                	lea    eax,[ebp-0x3c]
    3091:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   loop = sizeof( VeryMix );
    3094:	c7 45 f8 0c 00 00 00    	mov    DWORD PTR [ebp-0x8],0xc
   while ( loop-- )
    309b:	eb 0c                   	jmp    30a9 <unions+0x141>
	   *pc++ = 0;
    309d:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    30a0:	8d 50 01                	lea    edx,[eax+0x1]
    30a3:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
    30a6:	c6 00 00                	mov    BYTE PTR [eax],0x0
   while ( loop-- )
    30a9:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    30ac:	8d 50 ff                	lea    edx,[eax-0x1]
    30af:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx
    30b2:	85 c0                   	test   eax,eax
    30b4:	75 e7                   	jne    309d <unions+0x135>

   vmx.mixCSI.cD = 65;
    30b6:	c6 45 c4 41             	mov    BYTE PTR [ebp-0x3c],0x41

}//unions
    30ba:	90                      	nop
    30bb:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    30be:	c9                      	leave  
    30bf:	c3                      	ret    

000030c0 <typePromotion>:

//-----------------------------------------------------------------------------

void typePromotion( void ) {
    30c0:	55                      	push   ebp
    30c1:	89 e5                   	mov    ebp,esp
    30c3:	83 ec 20                	sub    esp,0x20
    30c6:	e8 fc ff ff ff          	call   30c7 <typePromotion+0x7>
    30cb:	05 01 00 00 00          	add    eax,0x1

	int   i =  1;
    30d0:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1
	float f =  0.10F;
    30d7:	d9 80 e0 03 00 00       	fld    DWORD PTR [eax+0x3e0]
    30dd:	d9 5d f8                	fstp   DWORD PTR [ebp-0x8]
	float r =  0.00F;
    30e0:	d9 ee                   	fldz   
    30e2:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

	r = f + i;
    30e5:	db 45 fc                	fild   DWORD PTR [ebp-0x4]
    30e8:	d9 45 f8                	fld    DWORD PTR [ebp-0x8]
    30eb:	de c1                   	faddp  st(1),st
    30ed:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

	char  c  = 2;
    30f0:	c6 45 f3 02             	mov    BYTE PTR [ebp-0xd],0x2
	short s  = 3;
    30f4:	66 c7 45 f0 03 00       	mov    WORD PTR [ebp-0x10],0x3
	unsigned int u = 6;
    30fa:	c7 45 ec 06 00 00 00    	mov    DWORD PTR [ebp-0x14],0x6

	i = i + c;
    3101:	0f be 45 f3             	movsx  eax,BYTE PTR [ebp-0xd]
    3105:	01 45 fc                	add    DWORD PTR [ebp-0x4],eax

	i = i + s;
    3108:	0f bf 45 f0             	movsx  eax,WORD PTR [ebp-0x10]
    310c:	01 45 fc                	add    DWORD PTR [ebp-0x4],eax

	i = i + u;
    310f:	8b 55 fc                	mov    edx,DWORD PTR [ebp-0x4]
    3112:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    3115:	01 d0                   	add    eax,edx
    3117:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax

	long long l = 1L + c;
    311a:	0f be 45 f3             	movsx  eax,BYTE PTR [ebp-0xd]
    311e:	83 c0 01                	add    eax,0x1
    3121:	99                      	cdq    
    3122:	89 45 e0                	mov    DWORD PTR [ebp-0x20],eax
    3125:	89 55 e4                	mov    DWORD PTR [ebp-0x1c],edx

}//typePromotion
    3128:	90                      	nop
    3129:	c9                      	leave  
    312a:	c3                      	ret    

0000312b <typePromotionPromoteToInt>:

//-----------------------------------------------------------------------------

void typePromotionPromoteToInt( void ) {
    312b:	55                      	push   ebp
    312c:	89 e5                   	mov    ebp,esp
    312e:	83 ec 10                	sub    esp,0x10
    3131:	e8 fc ff ff ff          	call   3132 <typePromotionPromoteToInt+0x7>
    3136:	05 01 00 00 00          	add    eax,0x1

	// see disassembly ( sign extend instructions )
	// all ranks lower than int (signed or unsigned), promote to int
	_Bool b =  false;
    313b:	c6 45 ff 00             	mov    BYTE PTR [ebp-0x1],0x0
	char  c =  'a';
    313f:	c6 45 fe 61             	mov    BYTE PTR [ebp-0x2],0x61
	short s =  -8;
    3143:	66 c7 45 fc f8 ff       	mov    WORD PTR [ebp-0x4],0xfff8

	int r = 0;
    3149:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
	int d = 1;
    3150:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1
	d = b + b + b;
    3157:	0f b6 55 ff             	movzx  edx,BYTE PTR [ebp-0x1]
    315b:	89 d0                   	mov    eax,edx
    315d:	01 c0                   	add    eax,eax
    315f:	01 d0                   	add    eax,edx
    3161:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

	r = b + c + s;
    3164:	0f b6 55 ff             	movzx  edx,BYTE PTR [ebp-0x1]
    3168:	0f be 45 fe             	movsx  eax,BYTE PTR [ebp-0x2]
    316c:	01 c2                   	add    edx,eax
    316e:	0f bf 45 fc             	movsx  eax,WORD PTR [ebp-0x4]
    3172:	01 d0                   	add    eax,edx
    3174:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax

}//typePromotionPromoteToInt
    3177:	90                      	nop
    3178:	c9                      	leave  
    3179:	c3                      	ret    

0000317a <typePromotionPromoteToInt2>:

//-----------------------------------------------------------------------------

void typePromotionPromoteToInt2( void ) {
    317a:	55                      	push   ebp
    317b:	89 e5                   	mov    ebp,esp
    317d:	83 ec 10                	sub    esp,0x10
    3180:	e8 fc ff ff ff          	call   3181 <typePromotionPromoteToInt2+0x7>
    3185:	05 01 00 00 00          	add    eax,0x1

	// see disassembly ( sign extend instructions )
	// all ranks lower than int (signed or unsigned), promote to int

	short s1 = -5;
    318a:	66 c7 45 fe fb ff       	mov    WORD PTR [ebp-0x2],0xfffb
	short s2 = 3;
    3190:	66 c7 45 fc 03 00       	mov    WORD PTR [ebp-0x4],0x3

	s2 = -s2;
    3196:	0f b7 45 fc             	movzx  eax,WORD PTR [ebp-0x4]
    319a:	f7 d8                   	neg    eax
    319c:	66 89 45 fc             	mov    WORD PTR [ebp-0x4],ax
	s1 = s1 + s2;
    31a0:	0f b7 55 fe             	movzx  edx,WORD PTR [ebp-0x2]
    31a4:	0f b7 45 fc             	movzx  eax,WORD PTR [ebp-0x4]
    31a8:	01 d0                   	add    eax,edx
    31aa:	66 89 45 fe             	mov    WORD PTR [ebp-0x2],ax

	int r = s1 + s1;
    31ae:	0f bf 45 fe             	movsx  eax,WORD PTR [ebp-0x2]
    31b2:	01 c0                   	add    eax,eax
    31b4:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax

	r = s1 + s2;
    31b7:	0f bf 55 fe             	movsx  edx,WORD PTR [ebp-0x2]
    31bb:	0f bf 45 fc             	movsx  eax,WORD PTR [ebp-0x4]
    31bf:	01 d0                   	add    eax,edx
    31c1:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax

}//typePromotionPromoteToInt2
    31c4:	90                      	nop
    31c5:	c9                      	leave  
    31c6:	c3                      	ret    

000031c7 <typePromotionSameWidth>:

//-----------------------------------------------------------------------------

void typePromotionSameWidth( void ) {
    31c7:	55                      	push   ebp
    31c8:	89 e5                   	mov    ebp,esp
    31ca:	83 ec 10                	sub    esp,0x10
    31cd:	e8 fc ff ff ff          	call   31ce <typePromotionSameWidth+0x7>
    31d2:	05 01 00 00 00          	add    eax,0x1

	// see disassembly
	// same size (representation) different rank
	signed   int negativeOne =  -1;
    31d7:	c7 45 fc ff ff ff ff    	mov    DWORD PTR [ebp-0x4],0xffffffff
	unsigned int positiveOne =  +1;
    31de:	c7 45 f8 01 00 00 00    	mov    DWORD PTR [ebp-0x8],0x1

	_Bool result = false;
    31e5:	c6 45 f7 00             	mov    BYTE PTR [ebp-0x9],0x0

	result = positiveOne < negativeOne;
    31e9:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    31ec:	39 45 f8                	cmp    DWORD PTR [ebp-0x8],eax
    31ef:	0f 92 c0                	setb   al
    31f2:	88 45 f7                	mov    BYTE PTR [ebp-0x9],al

}//typePromotionSameWidth
    31f5:	90                      	nop
    31f6:	c9                      	leave  
    31f7:	c3                      	ret    

000031f8 <evaluationOrderA>:

//-----------------------------------------------------------------------------

void evaluationOrderA( void ) {
    31f8:	55                      	push   ebp
    31f9:	89 e5                   	mov    ebp,esp
    31fb:	83 ec 10                	sub    esp,0x10
    31fe:	e8 fc ff ff ff          	call   31ff <evaluationOrderA+0x7>
    3203:	05 01 00 00 00          	add    eax,0x1

	// see disassembly
   int a = 1;
    3208:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1
   int b = 2;
    320f:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
   int c = 3;
    3216:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [ebp-0xc],0x3
   int d = 4;
    321d:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

   d = a + b - c + 3;
    3224:	8b 55 fc                	mov    edx,DWORD PTR [ebp-0x4]
    3227:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    322a:	01 d0                   	add    eax,edx
    322c:	2b 45 f4                	sub    eax,DWORD PTR [ebp-0xc]
    322f:	83 c0 03                	add    eax,0x3
    3232:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

}//evaluationOrderA
    3235:	90                      	nop
    3236:	c9                      	leave  
    3237:	c3                      	ret    

00003238 <evaluationOrderB>:

//-----------------------------------------------------------------------------

void evaluationOrderB( void ) {
    3238:	55                      	push   ebp
    3239:	89 e5                   	mov    ebp,esp
    323b:	83 ec 10                	sub    esp,0x10
    323e:	e8 fc ff ff ff          	call   323f <evaluationOrderB+0x7>
    3243:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int a = 1;
    3248:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1
   int b = 2;
    324f:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
   int c = 3;
    3256:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [ebp-0xc],0x3
   int d = 4;
    325d:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

   d = a + b * c + 3;
    3264:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    3267:	0f af 45 f4             	imul   eax,DWORD PTR [ebp-0xc]
    326b:	89 c2                   	mov    edx,eax
    326d:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    3270:	01 d0                   	add    eax,edx
    3272:	83 c0 03                	add    eax,0x3
    3275:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

}//evaluationOrderB
    3278:	90                      	nop
    3279:	c9                      	leave  
    327a:	c3                      	ret    

0000327b <evaluationOrderC>:

//-----------------------------------------------------------------------------

void evaluationOrderC( void ) {
    327b:	55                      	push   ebp
    327c:	89 e5                   	mov    ebp,esp
    327e:	83 ec 10                	sub    esp,0x10
    3281:	e8 fc ff ff ff          	call   3282 <evaluationOrderC+0x7>
    3286:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int a = 1;
    328b:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1
   int b = 2;
    3292:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
   int c = 3;
    3299:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [ebp-0xc],0x3
   int d = 4;
    32a0:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

   d = a = b = c = 5;
    32a7:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [ebp-0xc],0x5
    32ae:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    32b1:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax
    32b4:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    32b7:	89 45 fc                	mov    DWORD PTR [ebp-0x4],eax
    32ba:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    32bd:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax

}//evaluationOrderC
    32c0:	90                      	nop
    32c1:	c9                      	leave  
    32c2:	c3                      	ret    

000032c3 <division>:

//-----------------------------------------------------------------------------

void division( void ) {
    32c3:	55                      	push   ebp
    32c4:	89 e5                   	mov    ebp,esp
    32c6:	83 ec 30                	sub    esp,0x30
    32c9:	e8 fc ff ff ff          	call   32ca <division+0x7>
    32ce:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int a = 5;
    32d3:	c7 45 fc 05 00 00 00    	mov    DWORD PTR [ebp-0x4],0x5
   int b = 2;
    32da:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2

   unsigned int ua = 5;
    32e1:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [ebp-0xc],0x5
   unsigned int ub = 2;
    32e8:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [ebp-0x10],0x2

   int          ir = 0;
    32ef:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   unsigned int ur = 0;
    32f6:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0
   float        fr = 0.0F;
    32fd:	d9 ee                   	fldz   
    32ff:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]

   ir = a / b;
    3302:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    3305:	99                      	cdq    
    3306:	f7 7d f8                	idiv   DWORD PTR [ebp-0x8]
    3309:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax

   fr = a / b;
    330c:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    330f:	99                      	cdq    
    3310:	f7 7d f8                	idiv   DWORD PTR [ebp-0x8]
    3313:	89 45 d0                	mov    DWORD PTR [ebp-0x30],eax
    3316:	db 45 d0                	fild   DWORD PTR [ebp-0x30]
    3319:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]

   fr = (float)( a / b );
    331c:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    331f:	99                      	cdq    
    3320:	f7 7d f8                	idiv   DWORD PTR [ebp-0x8]
    3323:	89 45 d0                	mov    DWORD PTR [ebp-0x30],eax
    3326:	db 45 d0                	fild   DWORD PTR [ebp-0x30]
    3329:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]

   fr = (float)a / b;
    332c:	db 45 fc                	fild   DWORD PTR [ebp-0x4]
    332f:	db 45 f8                	fild   DWORD PTR [ebp-0x8]
    3332:	de f9                   	fdivp  st(1),st
    3334:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]

   fr = a / (float)b;
    3337:	db 45 fc                	fild   DWORD PTR [ebp-0x4]
    333a:	db 45 f8                	fild   DWORD PTR [ebp-0x8]
    333d:	de f9                   	fdivp  st(1),st
    333f:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]

   ur = ua / ub;
    3342:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3345:	ba 00 00 00 00          	mov    edx,0x0
    334a:	f7 75 f0                	div    DWORD PTR [ebp-0x10]
    334d:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

   ur = (float)ua / ub;
    3350:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3353:	ba 00 00 00 00          	mov    edx,0x0
    3358:	89 45 d0                	mov    DWORD PTR [ebp-0x30],eax
    335b:	89 55 d4                	mov    DWORD PTR [ebp-0x2c],edx
    335e:	df 6d d0                	fild   QWORD PTR [ebp-0x30]
    3361:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    3364:	ba 00 00 00 00          	mov    edx,0x0
    3369:	89 45 d0                	mov    DWORD PTR [ebp-0x30],eax
    336c:	89 55 d4                	mov    DWORD PTR [ebp-0x2c],edx
    336f:	df 6d d0                	fild   QWORD PTR [ebp-0x30]
    3372:	de f9                   	fdivp  st(1),st
    3374:	d9 7d de                	fnstcw WORD PTR [ebp-0x22]
    3377:	0f b7 45 de             	movzx  eax,WORD PTR [ebp-0x22]
    337b:	80 cc 0c                	or     ah,0xc
    337e:	66 89 45 dc             	mov    WORD PTR [ebp-0x24],ax
    3382:	d9 6d dc                	fldcw  WORD PTR [ebp-0x24]
    3385:	df 7d d0                	fistp  QWORD PTR [ebp-0x30]
    3388:	d9 6d de                	fldcw  WORD PTR [ebp-0x22]
    338b:	8b 45 d0                	mov    eax,DWORD PTR [ebp-0x30]
    338e:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

}//division
    3391:	90                      	nop
    3392:	c9                      	leave  
    3393:	c3                      	ret    

00003394 <modulus>:

//-----------------------------------------------------------------------------

void modulus( void ) {
    3394:	55                      	push   ebp
    3395:	89 e5                   	mov    ebp,esp
    3397:	53                      	push   ebx
    3398:	83 ec 10                	sub    esp,0x10
    339b:	e8 fc ff ff ff          	call   339c <modulus+0x8>
    33a0:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   int r = 0;
    33a5:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0

   r = +5 % 3;
    33ac:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2
   r = -5 % 3;
    33b3:	c7 45 f8 fe ff ff ff    	mov    DWORD PTR [ebp-0x8],0xfffffffe
   r = +5 % -3;
    33ba:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2

   r = +3 % 5;
    33c1:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3
   r = +3 % -5;
    33c8:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [ebp-0x8],0x3

   r = (int)7.99F % 5;
    33cf:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [ebp-0x8],0x2

   int a = 5;
    33d6:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [ebp-0xc],0x5
   int b = 3;
    33dd:	c7 45 f0 03 00 00 00    	mov    DWORD PTR [ebp-0x10],0x3

   r = +a % 3;
    33e4:	8b 4d f4                	mov    ecx,DWORD PTR [ebp-0xc]
    33e7:	ba 56 55 55 55          	mov    edx,0x55555556
    33ec:	89 c8                   	mov    eax,ecx
    33ee:	f7 ea                   	imul   edx
    33f0:	89 c8                   	mov    eax,ecx
    33f2:	c1 f8 1f                	sar    eax,0x1f
    33f5:	29 c2                   	sub    edx,eax
    33f7:	89 d0                   	mov    eax,edx
    33f9:	01 c0                   	add    eax,eax
    33fb:	01 d0                   	add    eax,edx
    33fd:	29 c1                   	sub    ecx,eax
    33ff:	89 ca                   	mov    edx,ecx
    3401:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx
   r = -a % 3;
    3404:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3407:	f7 d8                   	neg    eax
    3409:	89 c1                   	mov    ecx,eax
    340b:	ba 56 55 55 55          	mov    edx,0x55555556
    3410:	89 c8                   	mov    eax,ecx
    3412:	f7 ea                   	imul   edx
    3414:	89 cb                   	mov    ebx,ecx
    3416:	c1 fb 1f                	sar    ebx,0x1f
    3419:	89 d0                   	mov    eax,edx
    341b:	29 d8                   	sub    eax,ebx
    341d:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax
    3420:	8b 55 f8                	mov    edx,DWORD PTR [ebp-0x8]
    3423:	89 d0                   	mov    eax,edx
    3425:	01 c0                   	add    eax,eax
    3427:	01 d0                   	add    eax,edx
    3429:	29 c1                   	sub    ecx,eax
    342b:	89 ca                   	mov    edx,ecx
    342d:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx

   r = +a % -3;
    3430:	8b 4d f4                	mov    ecx,DWORD PTR [ebp-0xc]
    3433:	ba 56 55 55 55          	mov    edx,0x55555556
    3438:	89 c8                   	mov    eax,ecx
    343a:	f7 ea                   	imul   edx
    343c:	89 c8                   	mov    eax,ecx
    343e:	c1 f8 1f                	sar    eax,0x1f
    3441:	29 c2                   	sub    edx,eax
    3443:	89 d0                   	mov    eax,edx
    3445:	01 c0                   	add    eax,eax
    3447:	01 d0                   	add    eax,edx
    3449:	29 c1                   	sub    ecx,eax
    344b:	89 ca                   	mov    edx,ecx
    344d:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx
   r = -a % -3;
    3450:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3453:	f7 d8                   	neg    eax
    3455:	89 c1                   	mov    ecx,eax
    3457:	ba 56 55 55 55          	mov    edx,0x55555556
    345c:	89 c8                   	mov    eax,ecx
    345e:	f7 ea                   	imul   edx
    3460:	89 cb                   	mov    ebx,ecx
    3462:	c1 fb 1f                	sar    ebx,0x1f
    3465:	89 d0                   	mov    eax,edx
    3467:	29 d8                   	sub    eax,ebx
    3469:	89 45 f8                	mov    DWORD PTR [ebp-0x8],eax
    346c:	8b 55 f8                	mov    edx,DWORD PTR [ebp-0x8]
    346f:	89 d0                   	mov    eax,edx
    3471:	01 c0                   	add    eax,eax
    3473:	01 d0                   	add    eax,edx
    3475:	29 c1                   	sub    ecx,eax
    3477:	89 ca                   	mov    edx,ecx
    3479:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx

}//modulus
    347c:	90                      	nop
    347d:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    3480:	c9                      	leave  
    3481:	c3                      	ret    

00003482 <initializationOfVariables>:

//-----------------------------------------------------------------------------

void initializationOfVariables( void ) {
    3482:	55                      	push   ebp
    3483:	89 e5                   	mov    ebp,esp
    3485:	83 ec 40                	sub    esp,0x40
    3488:	e8 fc ff ff ff          	call   3489 <initializationOfVariables+0x7>
    348d:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   char           c = 'A';
    3492:	c6 45 ff 41             	mov    BYTE PTR [ebp-0x1],0x41
   unsigned char uc = 'B';
    3496:	c6 45 fe 42             	mov    BYTE PTR [ebp-0x2],0x42

   short          s  = 1;
    349a:	66 c7 45 fc 01 00       	mov    WORD PTR [ebp-0x4],0x1
   unsigned short us = 1;
    34a0:	66 c7 45 fa 01 00       	mov    WORD PTR [ebp-0x6],0x1

   int          i  = 3;
    34a6:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [ebp-0xc],0x3
   unsigned int ui = 4;
    34ad:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [ebp-0x10],0x4

   long long          ll  = 5LL;
    34b4:	c7 45 e8 05 00 00 00    	mov    DWORD PTR [ebp-0x18],0x5
    34bb:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
   unsigned long long ull = 6ULL;
    34c2:	c7 45 e0 06 00 00 00    	mov    DWORD PTR [ebp-0x20],0x6
    34c9:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x0

   float       fA = 1.99F;
    34d0:	d9 80 20 05 00 00       	fld    DWORD PTR [eax+0x520]
    34d6:	d9 5d dc                	fstp   DWORD PTR [ebp-0x24]
   double      dB = 2.99;
    34d9:	dd 80 50 05 00 00       	fld    QWORD PTR [eax+0x550]
    34df:	dd 5d d0                	fstp   QWORD PTR [ebp-0x30]
   long double lC = 3.99L;
    34e2:	db a8 60 05 00 00       	fld    TBYTE PTR [eax+0x560]
    34e8:	db 7d c4                	fstp   TBYTE PTR [ebp-0x3c]


   i = c + 1;
    34eb:	0f be 55 ff             	movsx  edx,BYTE PTR [ebp-0x1]
    34ef:	83 c2 01                	add    edx,0x1
    34f2:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
   i = s + 1;
    34f5:	0f bf 55 fc             	movsx  edx,WORD PTR [ebp-0x4]
    34f9:	83 c2 01                	add    edx,0x1
    34fc:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
   i = i + 1;
    34ff:	83 45 f4 01             	add    DWORD PTR [ebp-0xc],0x1

   i = uc + 1;
    3503:	0f b6 55 fe             	movzx  edx,BYTE PTR [ebp-0x2]
    3507:	83 c2 01                	add    edx,0x1
    350a:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
   i = us + 1;
    350d:	0f b7 55 fa             	movzx  edx,WORD PTR [ebp-0x6]
    3511:	83 c2 01                	add    edx,0x1
    3514:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
   i = ui + 1;
    3517:	8b 55 f0                	mov    edx,DWORD PTR [ebp-0x10]
    351a:	83 c2 01                	add    edx,0x1
    351d:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx

   fA = fA + i;
    3520:	db 45 f4                	fild   DWORD PTR [ebp-0xc]
    3523:	d9 45 dc                	fld    DWORD PTR [ebp-0x24]
    3526:	de c1                   	faddp  st(1),st
    3528:	d9 5d dc                	fstp   DWORD PTR [ebp-0x24]
   dB = dB + 1.99;
    352b:	dd 45 d0                	fld    QWORD PTR [ebp-0x30]
    352e:	dd 80 70 05 00 00       	fld    QWORD PTR [eax+0x570]
    3534:	de c1                   	faddp  st(1),st
    3536:	dd 5d d0                	fstp   QWORD PTR [ebp-0x30]
   lC = fA + dB;
    3539:	d9 45 dc                	fld    DWORD PTR [ebp-0x24]
    353c:	dc 45 d0                	fadd   QWORD PTR [ebp-0x30]
    353f:	db 7d c4                	fstp   TBYTE PTR [ebp-0x3c]

}//initializationOfVariables
    3542:	90                      	nop
    3543:	c9                      	leave  
    3544:	c3                      	ret    

00003545 <initializationOfArrays>:

//-----------------------------------------------------------------------------

void initializationOfArrays( void ) {
    3545:	55                      	push   ebp
    3546:	89 e5                   	mov    ebp,esp
    3548:	81 ec c0 00 00 00       	sub    esp,0xc0
    354e:	e8 fc ff ff ff          	call   354f <initializationOfArrays+0xa>
    3553:	05 01 00 00 00          	add    eax,0x1

   // see disassembly
   char carA[ 5 ] = "ABCD";
    3558:	c7 45 d7 41 42 43 44    	mov    DWORD PTR [ebp-0x29],0x44434241
    355f:	c6 45 db 00             	mov    BYTE PTR [ebp-0x25],0x0
   char carB[ 5 ] = {'A','B','C','D', 0 };
    3563:	c7 45 d2 41 42 43 44    	mov    DWORD PTR [ebp-0x2e],0x44434241
    356a:	c6 45 d6 00             	mov    BYTE PTR [ebp-0x2a],0x0
   char c         = '\0';
    356e:	c6 45 ff 00             	mov    BYTE PTR [ebp-0x1],0x0

   int iar[ 5 ] = { 65, 66, 67, 68, 69 };
    3572:	c7 45 bc 41 00 00 00    	mov    DWORD PTR [ebp-0x44],0x41
    3579:	c7 45 c0 42 00 00 00    	mov    DWORD PTR [ebp-0x40],0x42
    3580:	c7 45 c4 43 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x43
    3587:	c7 45 c8 44 00 00 00    	mov    DWORD PTR [ebp-0x38],0x44
    358e:	c7 45 cc 45 00 00 00    	mov    DWORD PTR [ebp-0x34],0x45
   int i        = 0;
    3595:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0

   float far[ 5 ] = { .1F, .2F, .3F, .4F, .5F };
    359c:	d9 80 e0 03 00 00       	fld    DWORD PTR [eax+0x3e0]
    35a2:	d9 5d a8                	fstp   DWORD PTR [ebp-0x58]
    35a5:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
    35ab:	d9 5d ac                	fstp   DWORD PTR [ebp-0x54]
    35ae:	d9 80 18 04 00 00       	fld    DWORD PTR [eax+0x418]
    35b4:	d9 5d b0                	fstp   DWORD PTR [ebp-0x50]
    35b7:	d9 80 78 05 00 00       	fld    DWORD PTR [eax+0x578]
    35bd:	d9 5d b4                	fstp   DWORD PTR [ebp-0x4c]
    35c0:	d9 80 f0 03 00 00       	fld    DWORD PTR [eax+0x3f0]
    35c6:	d9 5d b8                	fstp   DWORD PTR [ebp-0x48]
   float f        = .0F;
    35c9:	d9 ee                   	fldz   
    35cb:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

   double dar[ 5 ] = { .1, .2, .3, .4, .5 };
    35ce:	dd 80 a0 03 00 00       	fld    QWORD PTR [eax+0x3a0]
    35d4:	dd 5d 80                	fstp   QWORD PTR [ebp-0x80]
    35d7:	dd 80 80 05 00 00       	fld    QWORD PTR [eax+0x580]
    35dd:	dd 5d 88                	fstp   QWORD PTR [ebp-0x78]
    35e0:	dd 80 10 04 00 00       	fld    QWORD PTR [eax+0x410]
    35e6:	dd 5d 90                	fstp   QWORD PTR [ebp-0x70]
    35e9:	dd 80 88 05 00 00       	fld    QWORD PTR [eax+0x588]
    35ef:	dd 5d 98                	fstp   QWORD PTR [ebp-0x68]
    35f2:	dd 80 b0 03 00 00       	fld    QWORD PTR [eax+0x3b0]
    35f8:	dd 5d a0                	fstp   QWORD PTR [ebp-0x60]
   double d        = .0;
    35fb:	d9 ee                   	fldz   
    35fd:	dd 5d e8                	fstp   QWORD PTR [ebp-0x18]

   long double ldar[ 5 ] = { .1L, .2L, .3L, .4, .5L };
    3600:	db a8 20 04 00 00       	fld    TBYTE PTR [eax+0x420]
    3606:	db bd 40 ff ff ff       	fstp   TBYTE PTR [ebp-0xc0]
    360c:	db a8 30 04 00 00       	fld    TBYTE PTR [eax+0x430]
    3612:	db bd 4c ff ff ff       	fstp   TBYTE PTR [ebp-0xb4]
    3618:	db a8 40 04 00 00       	fld    TBYTE PTR [eax+0x440]
    361e:	db bd 58 ff ff ff       	fstp   TBYTE PTR [ebp-0xa8]
    3624:	db a8 90 05 00 00       	fld    TBYTE PTR [eax+0x590]
    362a:	db bd 64 ff ff ff       	fstp   TBYTE PTR [ebp-0x9c]
    3630:	db a8 60 04 00 00       	fld    TBYTE PTR [eax+0x460]
    3636:	db bd 70 ff ff ff       	fstp   TBYTE PTR [ebp-0x90]
   long double ld        = .0L;
    363c:	d9 ee                   	fldz   
    363e:	db 7d dc                	fstp   TBYTE PTR [ebp-0x24]

   iar[ 0 ] = 66;
    3641:	c7 45 bc 42 00 00 00    	mov    DWORD PTR [ebp-0x44],0x42
   i = iar[ 0 ];
    3648:	8b 55 bc                	mov    edx,DWORD PTR [ebp-0x44]
    364b:	89 55 f8                	mov    DWORD PTR [ebp-0x8],edx

   carA[ 0 ] = 97;
    364e:	c6 45 d7 61             	mov    BYTE PTR [ebp-0x29],0x61
   c = carA[0];
    3652:	0f b6 55 d7             	movzx  edx,BYTE PTR [ebp-0x29]
    3656:	88 55 ff                	mov    BYTE PTR [ebp-0x1],dl

   far[ 0 ] = .2F;
    3659:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
    365f:	d9 5d a8                	fstp   DWORD PTR [ebp-0x58]
   f = far[ 0 ];
    3662:	d9 45 a8                	fld    DWORD PTR [ebp-0x58]
    3665:	d9 5d f4                	fstp   DWORD PTR [ebp-0xc]

   dar[ 0 ] = .2;
    3668:	dd 80 80 05 00 00       	fld    QWORD PTR [eax+0x580]
    366e:	dd 5d 80                	fstp   QWORD PTR [ebp-0x80]
   d = dar[ 0 ];
    3671:	dd 45 80                	fld    QWORD PTR [ebp-0x80]
    3674:	dd 5d e8                	fstp   QWORD PTR [ebp-0x18]

   ldar[ 0 ] = .2L;
    3677:	db a8 30 04 00 00       	fld    TBYTE PTR [eax+0x430]
    367d:	db bd 40 ff ff ff       	fstp   TBYTE PTR [ebp-0xc0]
   ld = dar[ 0 ];
    3683:	dd 45 80                	fld    QWORD PTR [ebp-0x80]
    3686:	db 7d dc                	fstp   TBYTE PTR [ebp-0x24]

}//initializationOfArrays
    3689:	90                      	nop
    368a:	c9                      	leave  
    368b:	c3                      	ret    

0000368c <f>:

//-----------------------------------------------------------------------------

int f( void ) { return 3; }
    368c:	55                      	push   ebp
    368d:	89 e5                   	mov    ebp,esp
    368f:	e8 fc ff ff ff          	call   3690 <f+0x4>
    3694:	05 01 00 00 00          	add    eax,0x1
    3699:	b8 03 00 00 00          	mov    eax,0x3
    369e:	5d                      	pop    ebp
    369f:	c3                      	ret    

000036a0 <expressionEvaluationOrder>:

void expressionEvaluationOrder( void ) {
    36a0:	55                      	push   ebp
    36a1:	89 e5                   	mov    ebp,esp
    36a3:	83 ec 10                	sub    esp,0x10
    36a6:	e8 fc ff ff ff          	call   36a7 <expressionEvaluationOrder+0x7>
    36ab:	05 01 00 00 00          	add    eax,0x1

	// see disassembly
	int a = 0;
    36b0:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [ebp-0x4],0x0
	int b = 0;
    36b7:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
	int c = 1;
    36be:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [ebp-0xc],0x1

	// ! : not a 1.99 double
	float fA = 0.0F;
    36c5:	d9 ee                   	fldz   
    36c7:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]
	fA = 1,99;
    36ca:	d9 e8                   	fld1   
    36cc:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]
	(fA = 1) , 99;
    36cf:	d9 e8                   	fld1   
    36d1:	d9 5d f0                	fstp   DWORD PTR [ebp-0x10]

	a & b || c;
    36d4:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    36d7:	23 45 f8                	and    eax,DWORD PTR [ebp-0x8]
    36da:	85 c0                   	test   eax,eax
    36dc:	75 04                   	jne    36e2 <expressionEvaluationOrder+0x42>
    36de:	83 7d f4 00             	cmp    DWORD PTR [ebp-0xc],0x0

	a && b || c--;
    36e2:	83 7d fc 00             	cmp    DWORD PTR [ebp-0x4],0x0
    36e6:	74 06                   	je     36ee <expressionEvaluationOrder+0x4e>
    36e8:	83 7d f8 00             	cmp    DWORD PTR [ebp-0x8],0x0
    36ec:	75 0b                   	jne    36f9 <expressionEvaluationOrder+0x59>
    36ee:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    36f1:	8d 50 ff                	lea    edx,[eax-0x1]
    36f4:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
    36f7:	85 c0                   	test   eax,eax
    36f9:	90                      	nop
	1 + ( (2 * 2) * 4 );

	( 1 + 2 ) * 2 * 4;
	( (1 + 2) * 2 ) * 4;

	1 + 4, c = 2 | 3 + 5;
    36fa:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [ebp-0xc],0xa
	( 1 + 4 ), ( c = ( 2 | ( 3 + 5 ) ) );
    3701:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [ebp-0xc],0xa
	(1 + 5) & (4 == 3);

	// series of constant expressions
	3 , 4 , 5;

	!a++ + ~f();
    3708:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    370b:	8d 50 01                	lea    edx,[eax+0x1]
    370e:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
    3711:	85 c0                   	test   eax,eax
    3713:	e8 fc ff ff ff          	call   3714 <expressionEvaluationOrder+0x74>
	( !(a++) ) + ( ~(f()) );
    3718:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    371b:	8d 50 01                	lea    edx,[eax+0x1]
    371e:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
    3721:	85 c0                   	test   eax,eax
    3723:	e8 fc ff ff ff          	call   3724 <expressionEvaluationOrder+0x84>


}//expressionEvaluationOrder
    3728:	90                      	nop
    3729:	c9                      	leave  
    372a:	c3                      	ret    

0000372b <sequentialEvaluation>:

int sequentialEvaluation( void ) {
    372b:	55                      	push   ebp
    372c:	89 e5                   	mov    ebp,esp
    372e:	83 ec 30                	sub    esp,0x30
    3731:	e8 fc ff ff ff          	call   3732 <sequentialEvaluation+0x7>
    3736:	05 01 00 00 00          	add    eax,0x1
	// , comma / sequence operator
    // binary operator.
	// Left associative
	// eval first operand than discard it

	int values[2][3] = {
    373b:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [ebp-0x30],0x0
    3742:	c7 45 d4 0a 00 00 00    	mov    DWORD PTR [ebp-0x2c],0xa
    3749:	c7 45 d8 16 00 00 00    	mov    DWORD PTR [ebp-0x28],0x16
    3750:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
    3757:	c7 45 e0 0b 00 00 00    	mov    DWORD PTR [ebp-0x20],0xb
    375e:	c7 45 e4 16 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x16
		{0,10,22} , {0,11,22}
	} ;


	int a=1, b=2, c=3, i=0; // commas act as separators in this line, not as an operator
    3765:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [ebp-0x4],0x1
    376c:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [ebp-0x10],0x2
    3773:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [ebp-0x14],0x3
    377a:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [ebp-0x18],0x0

	i = (a, b);             // stores b into i
    3781:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    3784:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	i = a, b;               // stores a into i. Equivalent to (i = a), b;
    3787:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    378a:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
	                        // ... a=1, b=2, c=3, i=1
	i = (a += 2, a + b);    // increases a by 2, then stores a+b = 3+2 into i
    378d:	83 45 fc 02             	add    DWORD PTR [ebp-0x4],0x2
    3791:	8b 55 fc                	mov    edx,DWORD PTR [ebp-0x4]
    3794:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    3797:	01 d0                   	add    eax,edx
    3799:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	i = a += 2, a + b;      // increases a by 2, then stores a to i, and discards unused
    379c:	83 45 fc 02             	add    DWORD PTR [ebp-0x4],0x2
    37a0:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    37a3:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	i = a, b, c;            // stores a into i, discarding the unused b and c rvalues
    37a6:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    37a9:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	i = (a, b, c);          // stores c into i, discarding the unused a and b rvalues
    37ac:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    37af:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax


	values[0,1];             // ! not the same thing as values[0][1] : discards 0, use 1 as index
    values[1,1];             // ! not the same thing as values[1][1] : discards left 1, use riht 1 as index

	while ( a > 0, a-- );
    37b2:	90                      	nop
    37b3:	8b 45 fc                	mov    eax,DWORD PTR [ebp-0x4]
    37b6:	8d 50 ff                	lea    edx,[eax-0x1]
    37b9:	89 55 fc                	mov    DWORD PTR [ebp-0x4],edx
    37bc:	85 c0                   	test   eax,eax
    37be:	75 f3                   	jne    37b3 <sequentialEvaluation+0x88>

	for ( int j = 0, k = 10; j < k; j++, k-- );
    37c0:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
    37c7:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [ebp-0xc],0xa
    37ce:	eb 08                   	jmp    37d8 <sequentialEvaluation+0xad>
    37d0:	83 45 f8 01             	add    DWORD PTR [ebp-0x8],0x1
    37d4:	83 6d f4 01             	sub    DWORD PTR [ebp-0xc],0x1
    37d8:	8b 45 f8                	mov    eax,DWORD PTR [ebp-0x8]
    37db:	3b 45 f4                	cmp    eax,DWORD PTR [ebp-0xc]
    37de:	7c f0                   	jl     37d0 <sequentialEvaluation+0xa5>


	return a=4, b=5, c=6;   // returns 6, not 4,
    37e0:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [ebp-0x4],0x4
    37e7:	c7 45 f0 05 00 00 00    	mov    DWORD PTR [ebp-0x10],0x5
    37ee:	c7 45 ec 06 00 00 00    	mov    DWORD PTR [ebp-0x14],0x6
    37f5:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]

	return 1, 2, 3;         // returns 3, not 1,

	return (1), 2, 3;        // returns 3, not 1,

}//sequentialEvaluation
    37f8:	c9                      	leave  
    37f9:	c3                      	ret    

000037fa <structs_asParameterAndReturnValue>:
	int heigthAsCm;
	float weigthAsKg;
};


struct PointX structs_asParameterAndReturnValue( struct PointX point ) {
    37fa:	55                      	push   ebp
    37fb:	89 e5                   	mov    ebp,esp
    37fd:	e8 fc ff ff ff          	call   37fe <structs_asParameterAndReturnValue+0x4>
    3802:	05 01 00 00 00          	add    eax,0x1

	return *(point.pNext);
    3807:	8b 55 24                	mov    edx,DWORD PTR [ebp+0x24]
    380a:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    380d:	8b 0a                   	mov    ecx,DWORD PTR [edx]
    380f:	89 08                   	mov    DWORD PTR [eax],ecx
    3811:	8b 4a 04                	mov    ecx,DWORD PTR [edx+0x4]
    3814:	89 48 04                	mov    DWORD PTR [eax+0x4],ecx
    3817:	8b 4a 08                	mov    ecx,DWORD PTR [edx+0x8]
    381a:	89 48 08                	mov    DWORD PTR [eax+0x8],ecx
    381d:	8b 4a 0c                	mov    ecx,DWORD PTR [edx+0xc]
    3820:	89 48 0c                	mov    DWORD PTR [eax+0xc],ecx
    3823:	8b 4a 10                	mov    ecx,DWORD PTR [edx+0x10]
    3826:	89 48 10                	mov    DWORD PTR [eax+0x10],ecx
    3829:	8b 4a 14                	mov    ecx,DWORD PTR [edx+0x14]
    382c:	89 48 14                	mov    DWORD PTR [eax+0x14],ecx
    382f:	8b 52 18                	mov    edx,DWORD PTR [edx+0x18]
    3832:	89 50 18                	mov    DWORD PTR [eax+0x18],edx

}//structs_asParameterAndReturnValue
    3835:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    3838:	5d                      	pop    ebp
    3839:	c2 04 00                	ret    0x4

0000383c <structs>:

// TODO : struct flexible array member C99

void structs( void ) {
    383c:	55                      	push   ebp
    383d:	89 e5                   	mov    ebp,esp
    383f:	53                      	push   ebx
    3840:	83 ec 70                	sub    esp,0x70
    3843:	e8 fc ff ff ff          	call   3844 <structs+0x8>
    3848:	05 01 00 00 00          	add    eax,0x1

	struct { char C; int I; double D; } mixA;
	mixA.C = 'a';
    384d:	c6 45 e8 61             	mov    BYTE PTR [ebp-0x18],0x61
	mixA.I = 3;
    3851:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [ebp-0x14],0x3
	mixA.D = 1.618;
    3858:	dd 80 a0 05 00 00       	fld    QWORD PTR [eax+0x5a0]
    385e:	dd 5d f0                	fstp   QWORD PTR [ebp-0x10]

	// mixB's type is different than mixA's type although they are looking the same
	struct { char C; int I; double D; } mixB = { 'a', 3, 1.618 };
    3861:	c6 45 d8 61             	mov    BYTE PTR [ebp-0x28],0x61
    3865:	c7 45 dc 03 00 00 00    	mov    DWORD PTR [ebp-0x24],0x3
    386c:	dd 80 a0 05 00 00       	fld    QWORD PTR [eax+0x5a0]
    3872:	dd 5d e0                	fstp   QWORD PTR [ebp-0x20]


	// mixA = mixB; // error : incompatible types struct<anonymous>

	PointF.fX = .01F;
    3875:	d9 80 a8 05 00 00       	fld    DWORD PTR [eax+0x5a8]
    387b:	d9 98 00 00 00 00       	fstp   DWORD PTR [eax+0x0]
	PointF.fX = .02F;
    3881:	d9 80 ac 05 00 00       	fld    DWORD PTR [eax+0x5ac]
    3887:	d9 98 00 00 00 00       	fstp   DWORD PTR [eax+0x0]

	Point pointA = { 2, 3 };
    388d:	c7 45 d0 02 00 00 00    	mov    DWORD PTR [ebp-0x30],0x2
    3894:	c7 45 d4 03 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x3
	Point pointB = { .X = 2, .Y = 3 };
    389b:	c7 45 c8 02 00 00 00    	mov    DWORD PTR [ebp-0x38],0x2
    38a2:	c7 45 cc 03 00 00 00    	mov    DWORD PTR [ebp-0x34],0x3
	Point pointC = { .Y = 4 }; // initializes .X with zero
    38a9:	c7 45 c0 00 00 00 00    	mov    DWORD PTR [ebp-0x40],0x0
    38b0:	c7 45 c4 00 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x0
    38b7:	c7 45 c4 04 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x4

	// pointA = { 4,5 }         // error
	pointA = (Point){ 4, 5 };  // ok : "compound literal" assignment
    38be:	c7 45 d0 04 00 00 00    	mov    DWORD PTR [ebp-0x30],0x4
    38c5:	c7 45 d4 05 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x5

	// !!
	pointA = (Point){ .Y = 6 }; // !! overrides .X with zero
    38cc:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [ebp-0x30],0x0
    38d3:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x0
    38da:	c7 45 d4 06 00 00 00    	mov    DWORD PTR [ebp-0x2c],0x6

	//
	pointA = pointB;
    38e1:	8b 4d c8                	mov    ecx,DWORD PTR [ebp-0x38]
    38e4:	8b 5d cc                	mov    ebx,DWORD PTR [ebp-0x34]
    38e7:	89 4d d0                	mov    DWORD PTR [ebp-0x30],ecx
    38ea:	89 5d d4                	mov    DWORD PTR [ebp-0x2c],ebx

	// PointF
    PointF.fY = .1F;
    38ed:	d9 80 e0 03 00 00       	fld    DWORD PTR [eax+0x3e0]
    38f3:	d9 98 04 00 00 00       	fstp   DWORD PTR [eax+0x4]
    PointF.fY = .2F;
    38f9:	d9 80 e4 03 00 00       	fld    DWORD PTR [eax+0x3e4]
    38ff:	d9 98 04 00 00 00       	fstp   DWORD PTR [eax+0x4]

    //global points
    g_pointA.X = 1;
    3905:	c7 80 00 00 00 00 01 00 	mov    DWORD PTR [eax+0x0],0x1
    390d:	00 00 
    g_pointA.Y = 2;
    390f:	c7 80 04 00 00 00 02 00 	mov    DWORD PTR [eax+0x4],0x2
    3917:	00 00 

    g_pointB.X = 10;
    3919:	c7 80 00 00 00 00 0a 00 	mov    DWORD PTR [eax+0x0],0xa
    3921:	00 00 
    g_pointB.Y = 20;
    3923:	c7 80 04 00 00 00 14 00 	mov    DWORD PTR [eax+0x4],0x14
    392b:	00 00 

    g_pointC.X = 100;
    392d:	c7 80 00 00 00 00 64 00 	mov    DWORD PTR [eax+0x0],0x64
    3935:	00 00 
    g_pointC.Y = 200;
    3937:	c7 80 04 00 00 00 c8 00 	mov    DWORD PTR [eax+0x4],0xc8
    393f:	00 00 

    // assigment (copy)
    g_pointA = g_pointB;
    3941:	8b 88 00 00 00 00       	mov    ecx,DWORD PTR [eax+0x0]
    3947:	8b 98 04 00 00 00       	mov    ebx,DWORD PTR [eax+0x4]
    394d:	89 88 00 00 00 00       	mov    DWORD PTR [eax+0x0],ecx
    3953:	89 98 04 00 00 00       	mov    DWORD PTR [eax+0x4],ebx

    // struct member referencing
    g_pointer = &g_pointC;
    3959:	8d 90 00 00 00 00       	lea    edx,[eax+0x0]
    395f:	89 90 00 00 00 00       	mov    DWORD PTR [eax+0x0],edx
    (*g_pointer).X = 22;
    3965:	8b 90 00 00 00 00       	mov    edx,DWORD PTR [eax+0x0]
    396b:	c7 02 16 00 00 00       	mov    DWORD PTR [edx],0x16
    (*g_pointer).Y = 33;
    3971:	8b 90 00 00 00 00       	mov    edx,DWORD PTR [eax+0x0]
    3977:	c7 42 04 21 00 00 00    	mov    DWORD PTR [edx+0x4],0x21

    // member dereferencing operator
    g_pointer->X = 44;
    397e:	8b 90 00 00 00 00       	mov    edx,DWORD PTR [eax+0x0]
    3984:	c7 02 2c 00 00 00       	mov    DWORD PTR [edx],0x2c
    g_pointer->Y = 55;
    398a:	8b 90 00 00 00 00       	mov    edx,DWORD PTR [eax+0x0]
    3990:	c7 42 04 37 00 00 00    	mov    DWORD PTR [edx+0x4],0x37

    struct PointD pointD1;
    struct PointD pointD2 = { .1, .2 };
    3997:	dd 80 a0 03 00 00       	fld    QWORD PTR [eax+0x3a0]
    399d:	dd 5d 9c                	fstp   QWORD PTR [ebp-0x64]
    39a0:	dd 80 80 05 00 00       	fld    QWORD PTR [eax+0x580]
    39a6:	dd 5d a4                	fstp   QWORD PTR [ebp-0x5c]

    //pointD1 = { .1, .2 };              // error
    //pointD1 = (PointD){ .1, .2 };      // error
    pointD1 = (struct PointD){ .1, .2 }; // ok : "compound literal" assignment
    39a9:	dd 80 a0 03 00 00       	fld    QWORD PTR [eax+0x3a0]
    39af:	dd 5d ac                	fstp   QWORD PTR [ebp-0x54]
    39b2:	dd 80 80 05 00 00       	fld    QWORD PTR [eax+0x580]
    39b8:	dd 5d b4                	fstp   QWORD PTR [ebp-0x4c]

	size_t position = 0;
    39bb:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [ebp-0x8],0x0
	position = offsetof(  Point, Y );
    39c2:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [ebp-0x8],0x4

}//structs
    39c9:	90                      	nop
    39ca:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    39cd:	c9                      	leave  
    39ce:	c3                      	ret    

000039cf <structs_structArrays>:

//-----------------------------------------------------------------------------

void structs_structArrays( void ) {
    39cf:	55                      	push   ebp
    39d0:	89 e5                   	mov    ebp,esp
    39d2:	57                      	push   edi
    39d3:	56                      	push   esi
    39d4:	53                      	push   ebx
    39d5:	81 ec d0 00 00 00       	sub    esp,0xd0
    39db:	e8 fc ff ff ff          	call   39dc <structs_structArrays+0xd>
    39e0:	05 01 00 00 00          	add    eax,0x1

	// see disassembly
	struct TPerson people[ 3 ] = {
    39e5:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    39eb:	8d 98 80 02 00 00       	lea    ebx,[eax+0x280]
    39f1:	b9 30 00 00 00          	mov    ecx,0x30
    39f6:	89 d7                   	mov    edi,edx
    39f8:	89 de                   	mov    esi,ebx
    39fa:	f3 a5                   	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi]
		{ "ayhan", 160, 65.5F  },
		{ "beyhan", 150, 55.5F },
		{ "ceyhan", 170, 70.5F }
	};

	char *pc = NULL;
    39fc:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
	int  i   = 0;
    3a03:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [ebp-0x14],0x0
	float f  = .0F;
    3a0a:	d9 ee                   	fldz   
    3a0c:	d9 5d e8                	fstp   DWORD PTR [ebp-0x18]

	pc = people[ 0 ].name;
    3a0f:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    3a15:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
    i  = people[ 0 ].heigthAsCm;
    3a18:	8b 95 60 ff ff ff       	mov    edx,DWORD PTR [ebp-0xa0]
    3a1e:	89 55 ec                	mov    DWORD PTR [ebp-0x14],edx
	f  = people[ 0 ].weigthAsKg;
    3a21:	d9 85 64 ff ff ff       	fld    DWORD PTR [ebp-0x9c]
    3a27:	d9 5d e8                	fstp   DWORD PTR [ebp-0x18]

	pc = people[ 1 ].name;
    3a2a:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    3a30:	83 c2 40                	add    edx,0x40
    3a33:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
    i  = people[ 1 ].heigthAsCm;
    3a36:	8b 55 a0                	mov    edx,DWORD PTR [ebp-0x60]
    3a39:	89 55 ec                	mov    DWORD PTR [ebp-0x14],edx
	f  = people[ 1 ].weigthAsKg;
    3a3c:	d9 45 a4                	fld    DWORD PTR [ebp-0x5c]
    3a3f:	d9 5d e8                	fstp   DWORD PTR [ebp-0x18]

	pc = people[ 2 ].name;
    3a42:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    3a48:	83 ea 80                	sub    edx,0xffffff80
    3a4b:	89 55 f0                	mov    DWORD PTR [ebp-0x10],edx
    i  = people[ 2 ].heigthAsCm;
    3a4e:	8b 55 e0                	mov    edx,DWORD PTR [ebp-0x20]
    3a51:	89 55 ec                	mov    DWORD PTR [ebp-0x14],edx
	f  = people[ 2 ].weigthAsKg;
    3a54:	d9 45 e4                	fld    DWORD PTR [ebp-0x1c]
    3a57:	d9 5d e8                	fstp   DWORD PTR [ebp-0x18]

	strcpy( people[ 0 ].name, "ayda" );
    3a5a:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    3a60:	c7 02 61 79 64 61       	mov    DWORD PTR [edx],0x61647961
    3a66:	c6 42 04 00             	mov    BYTE PTR [edx+0x4],0x0
	people[ 0 ].heigthAsCm = 152;
    3a6a:	c7 85 60 ff ff ff 98 00 	mov    DWORD PTR [ebp-0xa0],0x98
    3a72:	00 00 
	people[ 0 ].weigthAsKg = 67.5F;
    3a74:	d9 80 b0 05 00 00       	fld    DWORD PTR [eax+0x5b0]
    3a7a:	d9 9d 64 ff ff ff       	fstp   DWORD PTR [ebp-0x9c]

	strcpy( people[ 1 ].name, "beyda" );
    3a80:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    3a86:	83 c2 40                	add    edx,0x40
    3a89:	c7 02 62 65 79 64       	mov    DWORD PTR [edx],0x64796562
    3a8f:	66 c7 42 04 61 00       	mov    WORD PTR [edx+0x4],0x61
	people[ 1 ].heigthAsCm = 162;
    3a95:	c7 45 a0 a2 00 00 00    	mov    DWORD PTR [ebp-0x60],0xa2
	people[ 1 ].weigthAsKg = 57.5F;
    3a9c:	d9 80 b4 05 00 00       	fld    DWORD PTR [eax+0x5b4]
    3aa2:	d9 5d a4                	fstp   DWORD PTR [ebp-0x5c]

	strcpy( people[ 2 ].name, "ceyda" );
    3aa5:	8d 95 28 ff ff ff       	lea    edx,[ebp-0xd8]
    3aab:	83 ea 80                	sub    edx,0xffffff80
    3aae:	c7 02 63 65 79 64       	mov    DWORD PTR [edx],0x64796563
    3ab4:	66 c7 42 04 61 00       	mov    WORD PTR [edx+0x4],0x61
	people[ 2 ].heigthAsCm = 162;
    3aba:	c7 45 e0 a2 00 00 00    	mov    DWORD PTR [ebp-0x20],0xa2
	people[ 2 ].weigthAsKg = 72.5F;
    3ac1:	d9 80 b8 05 00 00       	fld    DWORD PTR [eax+0x5b8]
    3ac7:	d9 5d e4                	fstp   DWORD PTR [ebp-0x1c]

}//structs_structArrays
    3aca:	90                      	nop
    3acb:	81 c4 d0 00 00 00       	add    esp,0xd0
    3ad1:	5b                      	pop    ebx
    3ad2:	5e                      	pop    esi
    3ad3:	5f                      	pop    edi
    3ad4:	5d                      	pop    ebp
    3ad5:	c3                      	ret    

00003ad6 <structs_flexibleArrayMember>:
	unsigned int length;
	long double values[];

};

void structs_flexibleArrayMember( int measurementCount ) {
    3ad6:	55                      	push   ebp
    3ad7:	89 e5                   	mov    ebp,esp
    3ad9:	53                      	push   ebx
    3ada:	83 ec 24                	sub    esp,0x24
    3add:	e8 fc ff ff ff          	call   3ade <structs_flexibleArrayMember+0x8>
    3ae2:	81 c3 02 00 00 00       	add    ebx,0x2

   // refer: https://en.wikipedia.org/wiki/Flexible_array_member

   struct TMeasurements* pMsr;

   size_t bytesAllocated = sizeof(struct TMeasurements) + measurementCount * sizeof(long double);
    3ae8:	8b 55 08                	mov    edx,DWORD PTR [ebp+0x8]
    3aeb:	89 d0                   	mov    eax,edx
    3aed:	01 c0                   	add    eax,eax
    3aef:	01 d0                   	add    eax,edx
    3af1:	c1 e0 02                	shl    eax,0x2
    3af4:	83 c0 04                	add    eax,0x4
    3af7:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
   pMsr = (struct TMeasurements*) malloc( bytesAllocated );
    3afa:	83 ec 0c                	sub    esp,0xc
    3afd:	ff 75 f0                	push   DWORD PTR [ebp-0x10]
    3b00:	e8 fc ff ff ff          	call   3b01 <structs_flexibleArrayMember+0x2b>
    3b05:	83 c4 10                	add    esp,0x10
    3b08:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax
   pMsr->length = measurementCount;
    3b0b:	8b 55 08                	mov    edx,DWORD PTR [ebp+0x8]
    3b0e:	8b 45 ec                	mov    eax,DWORD PTR [ebp-0x14]
    3b11:	89 10                   	mov    DWORD PTR [eax],edx

   const int upperLimit = 10;
    3b13:	c7 45 e8 0a 00 00 00    	mov    DWORD PTR [ebp-0x18],0xa
   int loop = measurementCount;
    3b1a:	8b 45 08                	mov    eax,DWORD PTR [ebp+0x8]
    3b1d:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax

   while ( loop-- )
    3b20:	eb 1f                   	jmp    3b41 <structs_flexibleArrayMember+0x6b>
	   pMsr->values[ loop ] = (long double)rand();
    3b22:	e8 fc ff ff ff          	call   3b23 <structs_flexibleArrayMember+0x4d>
    3b27:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax
    3b2a:	db 45 e4                	fild   DWORD PTR [ebp-0x1c]
    3b2d:	8b 4d ec                	mov    ecx,DWORD PTR [ebp-0x14]
    3b30:	8b 55 f4                	mov    edx,DWORD PTR [ebp-0xc]
    3b33:	89 d0                   	mov    eax,edx
    3b35:	01 c0                   	add    eax,eax
    3b37:	01 d0                   	add    eax,edx
    3b39:	c1 e0 02                	shl    eax,0x2
    3b3c:	01 c8                   	add    eax,ecx
    3b3e:	db 78 04                	fstp   TBYTE PTR [eax+0x4]
   while ( loop-- )
    3b41:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3b44:	8d 50 ff                	lea    edx,[eax-0x1]
    3b47:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
    3b4a:	85 c0                   	test   eax,eax
    3b4c:	75 d4                   	jne    3b22 <structs_flexibleArrayMember+0x4c>

}//structs_flexibleArrayMember
    3b4e:	90                      	nop
    3b4f:	90                      	nop
    3b50:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    3b53:	c9                      	leave  
    3b54:	c3                      	ret    

00003b55 <memoryManagement_alloc_calloc_realloc_free>:

//-----------------------------------------------------------------------------

void memoryManagement_alloc_calloc_realloc_free( void ) {
    3b55:	55                      	push   ebp
    3b56:	89 e5                   	mov    ebp,esp
    3b58:	53                      	push   ebx
    3b59:	83 ec 24                	sub    esp,0x24
    3b5c:	e8 fc ff ff ff          	call   3b5d <memoryManagement_alloc_calloc_realloc_free+0x8>
    3b61:	81 c3 02 00 00 00       	add    ebx,0x2

	char *textA = NULL;
    3b67:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0

	//textA = "lorem ipsum";// !! DON'T it's risky

	// returned memory block contains "garbage" values.
	textA = (char *) malloc( 12 );
    3b6e:	83 ec 0c                	sub    esp,0xc
    3b71:	6a 0c                   	push   0xc
    3b73:	e8 fc ff ff ff          	call   3b74 <memoryManagement_alloc_calloc_realloc_free+0x1f>
    3b78:	83 c4 10                	add    esp,0x10
    3b7b:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
	if ( NULL == textA )
    3b7e:	83 7d f4 00             	cmp    DWORD PTR [ebp-0xc],0x0
    3b82:	0f 84 a6 00 00 00       	je     3c2e <memoryManagement_alloc_calloc_realloc_free+0xd9>
	   goto EXIT;

   strcpy( textA, "lorem ipsum" );
    3b88:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3b8b:	c7 00 6c 6f 72 65       	mov    DWORD PTR [eax],0x65726f6c
    3b91:	c7 40 04 6d 20 69 70    	mov    DWORD PTR [eax+0x4],0x7069206d
    3b98:	c7 40 08 73 75 6d 00    	mov    DWORD PTR [eax+0x8],0x6d7573

	char *textB = NULL;
    3b9f:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0

	// returned memory block contains "zeroed" values.
	textB = (char *) calloc( 16, 1 );
    3ba6:	83 ec 08                	sub    esp,0x8
    3ba9:	6a 01                   	push   0x1
    3bab:	6a 10                   	push   0x10
    3bad:	e8 fc ff ff ff          	call   3bae <memoryManagement_alloc_calloc_realloc_free+0x59>
    3bb2:	83 c4 10                	add    esp,0x10
    3bb5:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
	if ( NULL == textB )
    3bb8:	83 7d f0 00             	cmp    DWORD PTR [ebp-0x10],0x0
    3bbc:	74 73                   	je     3c31 <memoryManagement_alloc_calloc_realloc_free+0xdc>
	   goto EXIT;

    strcpy( textB, " dolor sit amet" );
    3bbe:	8b 45 f0                	mov    eax,DWORD PTR [ebp-0x10]
    3bc1:	c7 00 20 64 6f 6c       	mov    DWORD PTR [eax],0x6c6f6420
    3bc7:	c7 40 04 6f 72 20 73    	mov    DWORD PTR [eax+0x4],0x7320726f
    3bce:	c7 40 08 69 74 20 61    	mov    DWORD PTR [eax+0x8],0x61207469
    3bd5:	c7 40 0c 6d 65 74 00    	mov    DWORD PTR [eax+0xc],0x74656d

	size_t sizeA = strlen( textA );
    3bdc:	83 ec 0c                	sub    esp,0xc
    3bdf:	ff 75 f4                	push   DWORD PTR [ebp-0xc]
    3be2:	e8 fc ff ff ff          	call   3be3 <memoryManagement_alloc_calloc_realloc_free+0x8e>
    3be7:	83 c4 10                	add    esp,0x10
    3bea:	89 45 ec                	mov    DWORD PTR [ebp-0x14],eax
	size_t sizeB = strlen( textB );
    3bed:	83 ec 0c                	sub    esp,0xc
    3bf0:	ff 75 f0                	push   DWORD PTR [ebp-0x10]
    3bf3:	e8 fc ff ff ff          	call   3bf4 <memoryManagement_alloc_calloc_realloc_free+0x9f>
    3bf8:	83 c4 10                	add    esp,0x10
    3bfb:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax

	// after successful realloc, previously malloced-buffer passed as first argument
	// is no longer valid and should not be "freed()".
	void* newBlock = realloc( textA, sizeA + sizeB + 1 );
    3bfe:	8b 55 ec                	mov    edx,DWORD PTR [ebp-0x14]
    3c01:	8b 45 e8                	mov    eax,DWORD PTR [ebp-0x18]
    3c04:	01 d0                   	add    eax,edx
    3c06:	83 c0 01                	add    eax,0x1
    3c09:	83 ec 08                	sub    esp,0x8
    3c0c:	50                      	push   eax
    3c0d:	ff 75 f4                	push   DWORD PTR [ebp-0xc]
    3c10:	e8 fc ff ff ff          	call   3c11 <memoryManagement_alloc_calloc_realloc_free+0xbc>
    3c15:	83 c4 10                	add    esp,0x10
    3c18:	89 45 e4                	mov    DWORD PTR [ebp-0x1c],eax
   textA = newBlock ? (char*) newBlock : textA;
    3c1b:	83 7d e4 00             	cmp    DWORD PTR [ebp-0x1c],0x0
    3c1f:	74 05                   	je     3c26 <memoryManagement_alloc_calloc_realloc_free+0xd1>
    3c21:	8b 45 e4                	mov    eax,DWORD PTR [ebp-0x1c]
    3c24:	eb 03                   	jmp    3c29 <memoryManagement_alloc_calloc_realloc_free+0xd4>
    3c26:	8b 45 f4                	mov    eax,DWORD PTR [ebp-0xc]
    3c29:	89 45 f4                	mov    DWORD PTR [ebp-0xc],eax
    3c2c:	eb 04                   	jmp    3c32 <memoryManagement_alloc_calloc_realloc_free+0xdd>
	   goto EXIT;
    3c2e:	90                      	nop
    3c2f:	eb 01                   	jmp    3c32 <memoryManagement_alloc_calloc_realloc_free+0xdd>
	   goto EXIT;
    3c31:	90                      	nop

EXIT:
	textA ? 0 : free( textA );
    3c32:	83 7d f4 00             	cmp    DWORD PTR [ebp-0xc],0x0
    3c36:	75 0e                   	jne    3c46 <memoryManagement_alloc_calloc_realloc_free+0xf1>
    3c38:	83 ec 0c                	sub    esp,0xc
    3c3b:	ff 75 f4                	push   DWORD PTR [ebp-0xc]
    3c3e:	e8 fc ff ff ff          	call   3c3f <memoryManagement_alloc_calloc_realloc_free+0xea>
    3c43:	83 c4 10                	add    esp,0x10
	textB ? 0 : free( textB );
    3c46:	83 7d f0 00             	cmp    DWORD PTR [ebp-0x10],0x0
    3c4a:	75 0e                   	jne    3c5a <memoryManagement_alloc_calloc_realloc_free+0x105>
    3c4c:	83 ec 0c                	sub    esp,0xc
    3c4f:	ff 75 f0                	push   DWORD PTR [ebp-0x10]
    3c52:	e8 fc ff ff ff          	call   3c53 <memoryManagement_alloc_calloc_realloc_free+0xfe>
    3c57:	83 c4 10                	add    esp,0x10

}//memoryManagement_alloc_calloc_realloc_free
    3c5a:	90                      	nop
    3c5b:	8b 5d fc                	mov    ebx,DWORD PTR [ebp-0x4]
    3c5e:	c9                      	leave  
    3c5f:	c3                      	ret    

00003c60 <implicitFunDec>:
//-----------------------------------------------------------------------------

implicitlyTypedVariableA;
impTVB = 2;

implicitFunDec( value ) {
    3c60:	55                      	push   ebp
    3c61:	89 e5                   	mov    ebp,esp
    3c63:	83 ec 10                	sub    esp,0x10
    3c66:	e8 fc ff ff ff          	call   3c67 <implicitFunDec+0x7>
    3c6b:	05 01 00 00 00          	add    eax,0x1

   unsigned impTVC = 3;
    3c70:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [ebp-0x4],0x3

}//implicitFunDec
    3c77:	90                      	nop
    3c78:	c9                      	leave  
    3c79:	c3                      	ret    

00003c7a <main>:

//-----------------------------------------------------------------------------

int main( int argc, char** argv ) {
    3c7a:	8d 4c 24 04             	lea    ecx,[esp+0x4]
    3c7e:	83 e4 f0                	and    esp,0xfffffff0
    3c81:	ff 71 fc                	push   DWORD PTR [ecx-0x4]
    3c84:	55                      	push   ebp
    3c85:	89 e5                   	mov    ebp,esp
    3c87:	51                      	push   ecx
    3c88:	83 ec 44                	sub    esp,0x44
    3c8b:	e8 fc ff ff ff          	call   3c8c <main+0x12>
    3c90:	05 01 00 00 00          	add    eax,0x1
   
   //pathCombineTester();

   implicitFunDec( 2 );
    3c95:	6a 02                   	push   0x2
    3c97:	e8 fc ff ff ff          	call   3c98 <main+0x1e>
    3c9c:	83 c4 04                	add    esp,0x4

	pointers6();
    3c9f:	e8 fc ff ff ff          	call   3ca0 <main+0x26>

	initializationOfArrays();
    3ca4:	e8 fc ff ff ff          	call   3ca5 <main+0x2b>

	pointers5();
    3ca9:	e8 fc ff ff ff          	call   3caa <main+0x30>

	memoryManagement_alloc_calloc_realloc_free();
    3cae:	e8 fc ff ff ff          	call   3caf <main+0x35>

	structs_flexibleArrayMember( 4 );
    3cb3:	83 ec 0c                	sub    esp,0xc
    3cb6:	6a 04                   	push   0x4
    3cb8:	e8 fc ff ff ff          	call   3cb9 <main+0x3f>
    3cbd:	83 c4 10                	add    esp,0x10

	arrays_variableSize( 3 );
    3cc0:	83 ec 0c                	sub    esp,0xc
    3cc3:	6a 03                   	push   0x3
    3cc5:	e8 fc ff ff ff          	call   3cc6 <main+0x4c>
    3cca:	83 c4 10                	add    esp,0x10

	unions();
    3ccd:	e8 fc ff ff ff          	call   3cce <main+0x54>

	arrays_multiDimensionalJaggedvsFlat();
    3cd2:	e8 fc ff ff ff          	call   3cd3 <main+0x59>
	arrays_multiDimensionalJagged();
    3cd7:	e8 fc ff ff ff          	call   3cd8 <main+0x5e>
	arrays_multiDimensional();
    3cdc:	e8 fc ff ff ff          	call   3cdd <main+0x63>

	long long int sum = 0;
    3ce1:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [ebp-0x10],0x0
    3ce8:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [ebp-0xc],0x0
	sum = functions_sum( 3 , 2, 4, 6 );
    3cef:	6a 06                   	push   0x6
    3cf1:	6a 04                   	push   0x4
    3cf3:	6a 02                   	push   0x2
    3cf5:	6a 03                   	push   0x3
    3cf7:	e8 fc ff ff ff          	call   3cf8 <main+0x7e>
    3cfc:	83 c4 10                	add    esp,0x10
    3cff:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    3d02:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx
	sum = functions_sum( 4 , 1, 3, 5, 7 );
    3d05:	83 ec 0c                	sub    esp,0xc
    3d08:	6a 07                   	push   0x7
    3d0a:	6a 05                   	push   0x5
    3d0c:	6a 03                   	push   0x3
    3d0e:	6a 01                   	push   0x1
    3d10:	6a 04                   	push   0x4
    3d12:	e8 fc ff ff ff          	call   3d13 <main+0x99>
    3d17:	83 c4 20                	add    esp,0x20
    3d1a:	89 45 f0                	mov    DWORD PTR [ebp-0x10],eax
    3d1d:	89 55 f4                	mov    DWORD PTR [ebp-0xc],edx


	long long int factorial = functions_recursiveFactorial( 5 );
    3d20:	83 ec 08                	sub    esp,0x8
    3d23:	6a 00                   	push   0x0
    3d25:	6a 05                   	push   0x5
    3d27:	e8 fc ff ff ff          	call   3d28 <main+0xae>
    3d2c:	83 c4 10                	add    esp,0x10
    3d2f:	89 45 e8                	mov    DWORD PTR [ebp-0x18],eax
    3d32:	89 55 ec                	mov    DWORD PTR [ebp-0x14],edx

	functions_recursiveFunction();
    3d35:	e8 fc ff ff ff          	call   3d36 <main+0xbc>

	sinus( 120 );
    3d3a:	83 ec 0c                	sub    esp,0xc
    3d3d:	6a 78                   	push   0x78
    3d3f:	e8 fc ff ff ff          	call   3d40 <main+0xc6>
    3d44:	dd d8                   	fstp   st(0)
    3d46:	83 c4 10                	add    esp,0x10

	arrays();
    3d49:	e8 fc ff ff ff          	call   3d4a <main+0xd0>

	structs();
    3d4e:	e8 fc ff ff ff          	call   3d4f <main+0xd5>

	literals();
    3d53:	e8 fc ff ff ff          	call   3d54 <main+0xda>

	operators_conditionalExpression();
    3d58:	e8 fc ff ff ff          	call   3d59 <main+0xdf>
	operators_additive();
    3d5d:	e8 fc ff ff ff          	call   3d5e <main+0xe4>
	operators_multiplicative();
    3d62:	e8 fc ff ff ff          	call   3d63 <main+0xe9>

	functionPointers();
    3d67:	e8 fc ff ff ff          	call   3d68 <main+0xee>

   everyIdentifierHasAnAddress();
    3d6c:	e8 fc ff ff ff          	call   3d6d <main+0xf3>

   arrays();
    3d71:	e8 fc ff ff ff          	call   3d72 <main+0xf8>
   arrays_multiDimensional();
    3d76:	e8 fc ff ff ff          	call   3d77 <main+0xfd>
	initializationOfVariables();
    3d7b:	e8 fc ff ff ff          	call   3d7c <main+0x102>
	sequentialEvaluation();
    3d80:	e8 fc ff ff ff          	call   3d81 <main+0x107>
	bitManipulation();
    3d85:	e8 fc ff ff ff          	call   3d86 <main+0x10c>

    int a = 1;
    3d8a:	c7 45 d0 01 00 00 00    	mov    DWORD PTR [ebp-0x30],0x1

    int x = 1;
    3d91:	c7 45 e4 01 00 00 00    	mov    DWORD PTR [ebp-0x1c],0x1
    int y = 1;
    3d98:	c7 45 e0 01 00 00 00    	mov    DWORD PTR [ebp-0x20],0x1
	 int z = 0;
    3d9f:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0


    // conditional evaluation of y
    x && y++;
    3da6:	83 7d e4 00             	cmp    DWORD PTR [ebp-0x1c],0x0
    3daa:	74 0b                   	je     3db7 <main+0x13d>
    3dac:	8b 45 e0                	mov    eax,DWORD PTR [ebp-0x20]
    3daf:	8d 50 01                	lea    edx,[eax+0x1]
    3db2:	89 55 e0                	mov    DWORD PTR [ebp-0x20],edx
    3db5:	85 c0                   	test   eax,eax

    //x == 0 ? x += 1: x += 2;
    (x == 0) ? (x += 1) : (x += 2);
    3db7:	83 7d e4 00             	cmp    DWORD PTR [ebp-0x1c],0x0
    3dbb:	75 06                   	jne    3dc3 <main+0x149>
    3dbd:	83 45 e4 01             	add    DWORD PTR [ebp-0x1c],0x1
    3dc1:	eb 04                   	jmp    3dc7 <main+0x14d>
    3dc3:	83 45 e4 02             	add    DWORD PTR [ebp-0x1c],0x2

	z = !a++;
    3dc7:	8b 45 d0                	mov    eax,DWORD PTR [ebp-0x30]
    3dca:	8d 50 01                	lea    edx,[eax+0x1]
    3dcd:	89 55 d0                	mov    DWORD PTR [ebp-0x30],edx
    3dd0:	85 c0                   	test   eax,eax
    3dd2:	0f 94 c0                	sete   al
    3dd5:	0f b6 c0                	movzx  eax,al
    3dd8:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax


	z = ( 0, 1, 2, 3 + 4 );
    3ddb:	c7 45 dc 07 00 00 00    	mov    DWORD PTR [ebp-0x24],0x7

	z = 0;
    3de2:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [ebp-0x24],0x0
	a = 0;
    3de9:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [ebp-0x30],0x0

	z = !(a++);
    3df0:	8b 45 d0                	mov    eax,DWORD PTR [ebp-0x30]
    3df3:	8d 50 01                	lea    edx,[eax+0x1]
    3df6:	89 55 d0                	mov    DWORD PTR [ebp-0x30],edx
    3df9:	85 c0                   	test   eax,eax
    3dfb:	0f 94 c0                	sete   al
    3dfe:	0f b6 c0                	movzx  eax,al
    3e01:	89 45 dc                	mov    DWORD PTR [ebp-0x24],eax

	division();
    3e04:	e8 fc ff ff ff          	call   3e05 <main+0x18b>

	typePromotionPromoteToInt();
    3e09:	e8 fc ff ff ff          	call   3e0a <main+0x190>

	// precedence of post increment
   int i[] = {3, 5};
    3e0e:	c7 45 c8 03 00 00 00    	mov    DWORD PTR [ebp-0x38],0x3
    3e15:	c7 45 cc 05 00 00 00    	mov    DWORD PTR [ebp-0x34],0x5
   int *p = i;
    3e1c:	8d 45 c8                	lea    eax,[ebp-0x38]
    3e1f:	89 45 d8                	mov    DWORD PTR [ebp-0x28],eax
   int j = --*p++;
    3e22:	8b 45 d8                	mov    eax,DWORD PTR [ebp-0x28]
    3e25:	8d 50 04                	lea    edx,[eax+0x4]
    3e28:	89 55 d8                	mov    DWORD PTR [ebp-0x28],edx
    3e2b:	8b 10                   	mov    edx,DWORD PTR [eax]
    3e2d:	83 ea 01                	sub    edx,0x1
    3e30:	89 10                   	mov    DWORD PTR [eax],edx
    3e32:	8b 00                   	mov    eax,DWORD PTR [eax]
    3e34:	89 45 d4                	mov    DWORD PTR [ebp-0x2c],eax

	typePromotion();
    3e37:	e8 fc ff ff ff          	call   3e38 <main+0x1be>
	modulus();
    3e3c:	e8 fc ff ff ff          	call   3e3d <main+0x1c3>
	//SameWidthTypePromotion();


	expressionEvaluationOrder();
    3e41:	e8 fc ff ff ff          	call   3e42 <main+0x1c8>

	literals();
    3e46:	e8 fc ff ff ff          	call   3e47 <main+0x1cd>

   bitFields();
    3e4b:	e8 fc ff ff ff          	call   3e4c <main+0x1d2>


	int b = 5;
    3e50:	c7 45 c4 05 00 00 00    	mov    DWORD PTR [ebp-0x3c],0x5
	swap( &a, &b );
    3e57:	83 ec 08                	sub    esp,0x8
    3e5a:	8d 45 c4                	lea    eax,[ebp-0x3c]
    3e5d:	50                      	push   eax
    3e5e:	8d 45 d0                	lea    eax,[ebp-0x30]
    3e61:	50                      	push   eax
    3e62:	e8 80 ee ff ff          	call   2ce7 <swap>
    3e67:	83 c4 10                	add    esp,0x10

	return EXIT_SUCCESS;
    3e6a:	b8 00 00 00 00          	mov    eax,0x0

}//main
    3e6f:	8b 4d fc                	mov    ecx,DWORD PTR [ebp-0x4]
    3e72:	c9                      	leave  
    3e73:	8d 61 fc                	lea    esp,[ecx-0x4]
    3e76:	c3                      	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

00000000 <__x86.get_pc_thunk.ax>:
   0:	8b 04 24                	mov    eax,DWORD PTR [esp]
   3:	c3                      	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

00000000 <__x86.get_pc_thunk.cx>:
   0:	8b 0c 24                	mov    ecx,DWORD PTR [esp]
   3:	c3                      	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

00000000 <__x86.get_pc_thunk.bx>:
   0:	8b 1c 24                	mov    ebx,DWORD PTR [esp]
   3:	c3                      	ret    
