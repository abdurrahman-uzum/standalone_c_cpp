gcc (Debian 10.2.1-6) 10.2.1 20210110
Using: -std=gnu99 -g3 -O0 -c

main64.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <literals>:

#include <time.h>

//-----------------------------------------------------------------------------

void literals( void ) {
       0:	55                      	push   rbp
       1:	48 89 e5                	mov    rbp,rsp
       4:	48 81 ec d8 00 00 00    	sub    rsp,0xd8

   // size as multiples of char
   size_t size = 0;
       b:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0

   // GCC -std=c99 komut satırı parametresi ve #include<stdbool.h> gerekli
   _Bool result = false;
      13:	c6 45 f7 00             	mov    BYTE PTR [rbp-0x9],0x0
   Decimal: 97
   Hex    : 0x61
   Binary : 0b01100001
   Octal  : 0141
   */
   char c = 0;
      17:	c6 45 f6 00             	mov    BYTE PTR [rbp-0xa],0x0

   c = 97;   // decimal (base 10) literal
      1b:	c6 45 f6 61             	mov    BYTE PTR [rbp-0xa],0x61
   c = 0x61; // hexadecimal (base 16) literal
      1f:	c6 45 f6 61             	mov    BYTE PTR [rbp-0xa],0x61
   c = 0141; // octal (base 8) literal
      23:	c6 45 f6 61             	mov    BYTE PTR [rbp-0xa],0x61
   c = 'a';  // character literal
      27:	c6 45 f6 61             	mov    BYTE PTR [rbp-0xa],0x61

   // binary literal, gcc specific
   c = 0b01100001;
      2b:	c6 45 f6 61             	mov    BYTE PTR [rbp-0xa],0x61

   // single char literals (ASCII)
   char c01 = 'a';
      2f:	c6 45 f5 61             	mov    BYTE PTR [rbp-0xb],0x61
   char c02 = -67;
      33:	c6 45 f4 bd             	mov    BYTE PTR [rbp-0xc],0xbd
   char c03 = '\0';
      37:	c6 45 f3 00             	mov    BYTE PTR [rbp-0xd],0x0
   char c04 = 0;
      3b:	c6 45 f2 00             	mov    BYTE PTR [rbp-0xe],0x0

   char c05 = ' ';
      3f:	c6 45 f1 20             	mov    BYTE PTR [rbp-0xf],0x20
   char c06 = '\\';
      43:	c6 45 f0 5c             	mov    BYTE PTR [rbp-0x10],0x5c
   //char c07 = ''';

   // non printable chars (escape sequence)
   char c08 = '"';
      47:	c6 45 ef 22             	mov    BYTE PTR [rbp-0x11],0x22
   char c09 = '\a';
      4b:	c6 45 ee 07             	mov    BYTE PTR [rbp-0x12],0x7
   char c10 = '\b';
      4f:	c6 45 ed 08             	mov    BYTE PTR [rbp-0x13],0x8
   char c11 = '\f';
      53:	c6 45 ec 0c             	mov    BYTE PTR [rbp-0x14],0xc
   char c12 = '\n';
      57:	c6 45 eb 0a             	mov    BYTE PTR [rbp-0x15],0xa
   char c13 = '\r';
      5b:	c6 45 ea 0d             	mov    BYTE PTR [rbp-0x16],0xd
   char c14 = '\t';
      5f:	c6 45 e9 09             	mov    BYTE PTR [rbp-0x17],0x9
   char c15 = '\v';
      63:	c6 45 e8 0b             	mov    BYTE PTR [rbp-0x18],0xb

   char c16 = '\456'; // octal
      67:	c6 45 e7 2e             	mov    BYTE PTR [rbp-0x19],0x2e
   char c17 = '\xAF'; // hex
      6b:	c6 45 e6 af             	mov    BYTE PTR [rbp-0x1a],0xaf

   //unsigned short     c18 = '\u20AC';
   //unsigned short int c19 = '\u20AC';
   //unsigned int       c20 = '\U40FFAA11';

   signed int si1 = -3;
      6f:	c7 45 e0 fd ff ff ff    	mov    DWORD PTR [rbp-0x20],0xfffffffd
   int        si2 = -3;
      76:	c7 45 dc fd ff ff ff    	mov    DWORD PTR [rbp-0x24],0xfffffffd

   long int liA = 10L;
      7d:	48 c7 45 d0 0a 00 00 00 	mov    QWORD PTR [rbp-0x30],0xa
   long     liB = 10L;
      85:	48 c7 45 c8 0a 00 00 00 	mov    QWORD PTR [rbp-0x38],0xa

   long long int  lliA = 10LL;
      8d:	48 c7 45 c0 0a 00 00 00 	mov    QWORD PTR [rbp-0x40],0xa
   long long      lliB = 10LL;
      95:	48 c7 45 b8 0a 00 00 00 	mov    QWORD PTR [rbp-0x48],0xa

   unsigned long long int ulliA = 10ULL;
      9d:	48 c7 45 b0 0a 00 00 00 	mov    QWORD PTR [rbp-0x50],0xa
   unsigned long long     ulliB = 10ULL;
      a5:	48 c7 45 a8 0a 00 00 00 	mov    QWORD PTR [rbp-0x58],0xa

   char text01[] = "hello";
      ad:	c7 85 fa fe ff ff 68 65 	mov    DWORD PTR [rbp-0x106],0x6c6c6568
      b5:	6c 6c 
      b7:	66 c7 85 fe fe ff ff 6f 	mov    WORD PTR [rbp-0x102],0x6f
      bf:	00 
   //char text03[] = "C:\Windows\System32\drivers\";
   //char text04[] = "he said "hello"";
   //char text05[] = "he said "hello"";

   // UNICODE char literal
   wchar_t wc01 = L'ç';
      c0:	c7 45 a4 e7 00 00 00    	mov    DWORD PTR [rbp-0x5c],0xe7
   size = sizeof( wc01 );
      c7:	48 c7 45 f8 04 00 00 00 	mov    QWORD PTR [rbp-0x8],0x4

   // UNICODE string literal
   wchar_t text06[] = L"ĞÜŞİÖÇ ğüşiöç Iı";
      cf:	48 b8 1e 01 00 00 dc 00 	movabs rax,0xdc0000011e
      d7:	00 00 
      d9:	48 ba 5e 01 00 00 30 01 	movabs rdx,0x1300000015e
      e1:	00 00 
      e3:	48 89 85 b0 fe ff ff    	mov    QWORD PTR [rbp-0x150],rax
      ea:	48 89 95 b8 fe ff ff    	mov    QWORD PTR [rbp-0x148],rdx
      f1:	48 b8 d6 00 00 00 c7 00 	movabs rax,0xc7000000d6
      f9:	00 00 
      fb:	48 ba 20 00 00 00 1f 01 	movabs rdx,0x11f00000020
     103:	00 00 
     105:	48 89 85 c0 fe ff ff    	mov    QWORD PTR [rbp-0x140],rax
     10c:	48 89 95 c8 fe ff ff    	mov    QWORD PTR [rbp-0x138],rdx
     113:	48 b8 fc 00 00 00 5f 01 	movabs rax,0x15f000000fc
     11b:	00 00 
     11d:	48 ba 69 00 00 00 f6 00 	movabs rdx,0xf600000069
     125:	00 00 
     127:	48 89 85 d0 fe ff ff    	mov    QWORD PTR [rbp-0x130],rax
     12e:	48 89 95 d8 fe ff ff    	mov    QWORD PTR [rbp-0x128],rdx
     135:	48 b8 e7 00 00 00 20 00 	movabs rax,0x20000000e7
     13d:	00 00 
     13f:	48 ba 49 00 00 00 31 01 	movabs rdx,0x13100000049
     147:	00 00 
     149:	48 89 85 e0 fe ff ff    	mov    QWORD PTR [rbp-0x120],rax
     150:	48 89 95 e8 fe ff ff    	mov    QWORD PTR [rbp-0x118],rdx
     157:	c7 85 f0 fe ff ff 00 00 	mov    DWORD PTR [rbp-0x110],0x0
     15f:	00 00 
   size = sizeof( text06 );
     161:	48 c7 45 f8 44 00 00 00 	mov    QWORD PTR [rbp-0x8],0x44

   // IEEE 754 single precision floating point number (4 Byte)
   float f01 = 0;
     169:	66 0f ef c0             	pxor   xmm0,xmm0
     16d:	f3 0f 11 45 a0          	movss  DWORD PTR [rbp-0x60],xmm0
   float f02 = .0;
     172:	66 0f ef c0             	pxor   xmm0,xmm0
     176:	f3 0f 11 45 9c          	movss  DWORD PTR [rbp-0x64],xmm0
   float f03 = .0F;
     17b:	66 0f ef c0             	pxor   xmm0,xmm0
     17f:	f3 0f 11 45 98          	movss  DWORD PTR [rbp-0x68],xmm0
   float f04 = 3.14F;
     184:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 18c <literals+0x18c>
     18c:	f3 0f 11 45 94          	movss  DWORD PTR [rbp-0x6c],xmm0
   float f05 = FLT_EPSILON;
     191:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 199 <literals+0x199>
     199:	f3 0f 11 45 90          	movss  DWORD PTR [rbp-0x70],xmm0

   float pi          = 3.14159;
     19e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1a6 <literals+0x1a6>
     1a6:	f3 0f 11 45 8c          	movss  DWORD PTR [rbp-0x74],xmm0
   float aMole       = 6.02E23;
     1ab:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1b3 <literals+0x1b3>
     1b3:	f3 0f 11 45 88          	movss  DWORD PTR [rbp-0x78],xmm0
   float anotherMole = 6.022e23;
     1b8:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1c0 <literals+0x1c0>
     1c0:	f3 0f 11 45 84          	movss  DWORD PTR [rbp-0x7c],xmm0

   float electronCharge = 1.60217657e-19;
     1c5:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1cd <literals+0x1cd>
     1cd:	f3 0f 11 45 80          	movss  DWORD PTR [rbp-0x80],xmm0
   float protonMass     = 1.67262178e-27;
     1d2:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1da <literals+0x1da>
     1da:	f3 0f 11 85 7c ff ff ff 	movss  DWORD PTR [rbp-0x84],xmm0

   // IEEE 754 double precision floating point number (8 Byte)
   double d01 = .0;
     1e2:	66 0f ef c0             	pxor   xmm0,xmm0
     1e6:	f2 0f 11 85 70 ff ff ff 	movsd  QWORD PTR [rbp-0x90],xmm0
   double d02 = .456;
     1ee:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 1f6 <literals+0x1f6>
     1f6:	f2 0f 11 85 68 ff ff ff 	movsd  QWORD PTR [rbp-0x98],xmm0
   double d03 = DBL_EPSILON;
     1fe:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 206 <literals+0x206>
     206:	f2 0f 11 85 60 ff ff ff 	movsd  QWORD PTR [rbp-0xa0],xmm0

   // intel specific extended 80bit (10 Byte)
   long double ldGR = 1.618L;
     20e:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 214 <literals+0x214>
     214:	db bd 50 ff ff ff       	fstp   TBYTE PTR [rbp-0xb0]
   long double ldPI = 3.14159265358979323846264338328L;
     21a:	d9 eb                   	fldpi  
     21c:	db bd 40 ff ff ff       	fstp   TBYTE PTR [rbp-0xc0]
   long double ld01 = LDBL_EPSILON;
     222:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 228 <literals+0x228>
     228:	db bd 30 ff ff ff       	fstp   TBYTE PTR [rbp-0xd0]
            13 hexadecimal digits       (P - decimal)
   (0x1) . (999999999999A)              P(-4)
   */
   // C99 specific IEEE 754 double precision floating point HEXADECIMAL (base 16) literal
   // 1.100110011001100110011001100110011001100110011001101 x 2^(-4).
   double d04 = 0x1.999999999999Ap-4;
     22e:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 236 <literals+0x236>
     236:	f2 0f 11 85 28 ff ff ff 	movsd  QWORD PTR [rbp-0xd8],xmm0

   double d05 = 0xF.999999999999aP-4;
     23e:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 246 <literals+0x246>
     246:	f2 0f 11 85 20 ff ff ff 	movsd  QWORD PTR [rbp-0xe0],xmm0
   double d06 = 0xF.FFFFFFFFFFFFFP-4;
     24e:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 256 <literals+0x256>
     256:	f2 0f 11 85 18 ff ff ff 	movsd  QWORD PTR [rbp-0xe8],xmm0
   double d07 = 0x1p-1;
     25e:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 266 <literals+0x266>
     266:	f2 0f 11 85 10 ff ff ff 	movsd  QWORD PTR [rbp-0xf0],xmm0
   double d08 = 0x2p-1;
     26e:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 276 <literals+0x276>
     276:	f2 0f 11 85 08 ff ff ff 	movsd  QWORD PTR [rbp-0xf8],xmm0
   double d09 = 0x3p-1;
     27e:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 286 <literals+0x286>
     286:	f2 0f 11 85 00 ff ff ff 	movsd  QWORD PTR [rbp-0x100],xmm0

}//literals
     28e:	90                      	nop
     28f:	c9                      	leave  
     290:	c3                      	ret    

0000000000000291 <integers>:

//-----------------------------------------------------------------------------

itX;     // implicitly typed int
itY = 0; // implicitly typed int
void integers( void ) {
     291:	55                      	push   rbp
     292:	48 89 e5                	mov    rbp,rsp
     295:	48 83 ec 08             	sub    rsp,0x8
    
	// char's signedness is implementation specific
	char          c  = 0;
     299:	c6 45 ff 00             	mov    BYTE PTR [rbp-0x1],0x0
	signed char   sc = 0;
     29d:	c6 45 fe 00             	mov    BYTE PTR [rbp-0x2],0x0
	unsigned char uc = 0;
     2a1:	c6 45 fd 00             	mov    BYTE PTR [rbp-0x3],0x0

	short          s  = 0;
     2a5:	66 c7 45 fa 00 00       	mov    WORD PTR [rbp-0x6],0x0
	signed short   ss = 0;
     2ab:	66 c7 45 f8 00 00       	mov    WORD PTR [rbp-0x8],0x0
	unsigned short us = 0;
     2b1:	66 c7 45 f6 00 00       	mov    WORD PTR [rbp-0xa],0x0

	int          i  = 0;
     2b7:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [rbp-0x10],0x0
	signed int   si = 0;
     2be:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
	unsigned int ui = 0;
     2c5:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [rbp-0x18],0x0

	signed   sn = 0; // int
     2cc:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0
	unsigned un = 0; // int
     2d3:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [rbp-0x20],0x0

	long          l  = 0;
     2da:	48 c7 45 d8 00 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
	signed long   sl = 1;
     2e2:	48 c7 45 d0 01 00 00 00 	mov    QWORD PTR [rbp-0x30],0x1
	unsigned long ul = 1;
     2ea:	48 c7 45 c8 01 00 00 00 	mov    QWORD PTR [rbp-0x38],0x1

	long long          ll  = 0;
     2f2:	48 c7 45 c0 00 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
	signed long long  sll  = 1;
     2fa:	48 c7 45 b8 01 00 00 00 	mov    QWORD PTR [rbp-0x48],0x1
	unsigned long long ull = 1;
     302:	48 c7 45 b0 01 00 00 00 	mov    QWORD PTR [rbp-0x50],0x1

	// fixed length across platforms (  stdint.h or inttypes.h )
	int16_t  i16  = 0;
     30a:	66 c7 45 ae 00 00       	mov    WORD PTR [rbp-0x52],0x0
	uint16_t ui16 = 0;
     310:	66 c7 45 ac 00 00       	mov    WORD PTR [rbp-0x54],0x0

	int32_t  i32  = 0;
     316:	c7 45 a8 00 00 00 00    	mov    DWORD PTR [rbp-0x58],0x0
	uint32_t ui32 = 0;
     31d:	c7 45 a4 00 00 00 00    	mov    DWORD PTR [rbp-0x5c],0x0

	size_t size = 0;
     324:	48 c7 45 98 00 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0

   // platform dependant and may vary platform to platform ( limits.h )
	int bitCount = CHAR_BIT;
     32c:	c7 45 94 08 00 00 00    	mov    DWORD PTR [rbp-0x6c],0x8
	int value = CHAR_MIN;
     333:	c7 45 90 80 ff ff ff    	mov    DWORD PTR [rbp-0x70],0xffffff80
	value     = CHAR_MAX;
     33a:	c7 45 90 7f 00 00 00    	mov    DWORD PTR [rbp-0x70],0x7f

	size = sizeof( char );
     341:	48 c7 45 98 01 00 00 00 	mov    QWORD PTR [rbp-0x68],0x1
    //size = sizeof int;  //syntax error
    size = sizeof value;  // ok
     349:	48 c7 45 98 04 00 00 00 	mov    QWORD PTR [rbp-0x68],0x4

    size = sizeof( c );
     351:	48 c7 45 98 01 00 00 00 	mov    QWORD PTR [rbp-0x68],0x1
    size = sizeof( 0 );
     359:	48 c7 45 98 04 00 00 00 	mov    QWORD PTR [rbp-0x68],0x4
	size = sizeof( 0L );
     361:	48 c7 45 98 08 00 00 00 	mov    QWORD PTR [rbp-0x68],0x8
    size = sizeof( 0LL );
     369:	48 c7 45 98 08 00 00 00 	mov    QWORD PTR [rbp-0x68],0x8

	size = sizeof( int );
     371:	48 c7 45 98 04 00 00 00 	mov    QWORD PTR [rbp-0x68],0x4
	size = sizeof( unsigned int );
     379:	48 c7 45 98 04 00 00 00 	mov    QWORD PTR [rbp-0x68],0x4
	bitCount = CHAR_BIT * sizeof( unsigned int );
     381:	c7 45 94 20 00 00 00    	mov    DWORD PTR [rbp-0x6c],0x20

	size = sizeof( i );
     388:	48 c7 45 98 04 00 00 00 	mov    QWORD PTR [rbp-0x68],0x4
	size = sizeof( ui );
     390:	48 c7 45 98 04 00 00 00 	mov    QWORD PTR [rbp-0x68],0x4

	ui = (unsigned) 0xFFFFFFFF;
     398:	c7 45 e8 ff ff ff ff    	mov    DWORD PTR [rbp-0x18],0xffffffff
	i  = (signed) ui;
     39f:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
     3a2:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax
    ui = 0xFFFFFFFF;
     3a5:	c7 45 e8 ff ff ff ff    	mov    DWORD PTR [rbp-0x18],0xffffffff

    // !
    // i = ui / ( i + 1 );

    int x = -1;
     3ac:	c7 45 8c ff ff ff ff    	mov    DWORD PTR [rbp-0x74],0xffffffff
    int y = 4294967295;
     3b3:	c7 45 88 ff ff ff ff    	mov    DWORD PTR [rbp-0x78],0xffffffff
    _Bool result = x == y;
     3ba:	8b 45 8c                	mov    eax,DWORD PTR [rbp-0x74]
     3bd:	3b 45 88                	cmp    eax,DWORD PTR [rbp-0x78]
     3c0:	0f 94 c0                	sete   al
     3c3:	88 45 87                	mov    BYTE PTR [rbp-0x79],al
	
}//integers
     3c6:	90                      	nop
     3c7:	c9                      	leave  
     3c8:	c3                      	ret    

00000000000003c9 <decimals_Float>:


// refer: www.stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number
// refer: www.en.wikipedia.org/wiki/Subnormal_number
// https://observablehq.com/@rreusser/half-precision-floating-point-visualized
void decimals_Float( void ) {
     3c9:	55                      	push   rbp
     3ca:	48 89 e5                	mov    rbp,rsp
     3cd:	48 83 ec 30             	sub    rsp,0x30

   float fA = .0F;
     3d1:	66 0f ef c0             	pxor   xmm0,xmm0
     3d5:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   float fB = .0F;
     3da:	66 0f ef c0             	pxor   xmm0,xmm0
     3de:	f3 0f 11 45 f8          	movss  DWORD PTR [rbp-0x8],xmm0

   unsigned int count = 0;
     3e3:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
   int value = 0;
     3ea:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [rbp-0x10],0x0
   size_t size = 0;
     3f1:	48 c7 45 e8 00 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0

   // size in memory as bytes
   size = sizeof( float );
     3f9:	48 c7 45 e8 04 00 00 00 	mov    QWORD PTR [rbp-0x18],0x4
   size = sizeof( fA );
     401:	48 c7 45 e8 04 00 00 00 	mov    QWORD PTR [rbp-0x18],0x4

   // bit count
   size = CHAR_BIT * sizeof( float );
     409:	48 c7 45 e8 20 00 00 00 	mov    QWORD PTR [rbp-0x18],0x20

   // include float.h
   fA = FLT_MIN;
     411:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 419 <decimals_Float+0x50>
     419:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   fA = FLT_MAX;
     41e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 426 <decimals_Float+0x5d>
     426:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   // mantissa, precision  0.000000
   count = FLT_DIG;
     42b:	c7 45 f4 06 00 00 00    	mov    DWORD PTR [rbp-0xc],0x6

   // base 10 of the exponent part of a float.
   value = FLT_MIN_10_EXP;
     432:	c7 45 f0 db ff ff ff    	mov    DWORD PTR [rbp-0x10],0xffffffdb
   value = FLT_MAX_10_EXP;
     439:	c7 45 f0 26 00 00 00    	mov    DWORD PTR [rbp-0x10],0x26

   float epsilon = FLT_EPSILON;
     440:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 448 <decimals_Float+0x7f>
     448:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0

   fA = .0F / .0F;
     44d:	66 0f ef c0             	pxor   xmm0,xmm0
     451:	f3 0f 5e c0             	divss  xmm0,xmm0
     455:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   fB = sqrtf( -1.00F ); // math.h
     45a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 462 <decimals_Float+0x99>
     462:	e8 00 00 00 00          	call   467 <decimals_Float+0x9e>
     467:	66 0f 7e c0             	movd   eax,xmm0
     46b:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
   fB = 1.0F / .00F;
     46e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 476 <decimals_Float+0xad>
     476:	66 0f ef c9             	pxor   xmm1,xmm1
     47a:	f3 0f 5e c1             	divss  xmm0,xmm1
     47e:	f3 0f 11 45 f8          	movss  DWORD PTR [rbp-0x8],xmm0
   fB = INFINITY;
     483:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 48b <decimals_Float+0xc2>
     48b:	f3 0f 11 45 f8          	movss  DWORD PTR [rbp-0x8],xmm0

   float posInf =  1.0F / 0.0F;
     490:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 498 <decimals_Float+0xcf>
     498:	66 0f ef c9             	pxor   xmm1,xmm1
     49c:	f3 0f 5e c1             	divss  xmm0,xmm1
     4a0:	f3 0f 11 45 e0          	movss  DWORD PTR [rbp-0x20],xmm0
   float negInf = -1.0F / 0.0F;
     4a5:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 4ad <decimals_Float+0xe4>
     4ad:	66 0f ef c9             	pxor   xmm1,xmm1
     4b1:	f3 0f 5e c1             	divss  xmm0,xmm1
     4b5:	f3 0f 11 45 dc          	movss  DWORD PTR [rbp-0x24],xmm0

   _Bool result = true;
     4ba:	c6 45 db 01             	mov    BYTE PTR [rbp-0x25],0x1

   fA = NAN;
     4be:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 4c6 <decimals_Float+0xfd>
     4c6:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   result = fA == NAN;
     4cb:	c6 45 db 00             	mov    BYTE PTR [rbp-0x25],0x0
   result = fA == fA;
     4cf:	b8 01 00 00 00          	mov    eax,0x1
     4d4:	f3 0f 10 45 fc          	movss  xmm0,DWORD PTR [rbp-0x4]
     4d9:	0f 2e 45 fc             	ucomiss xmm0,DWORD PTR [rbp-0x4]
     4dd:	7a 0b                   	jp     4ea <decimals_Float+0x121>
     4df:	f3 0f 10 45 fc          	movss  xmm0,DWORD PTR [rbp-0x4]
     4e4:	0f 2e 45 fc             	ucomiss xmm0,DWORD PTR [rbp-0x4]
     4e8:	74 05                   	je     4ef <decimals_Float+0x126>
     4ea:	b8 00 00 00 00          	mov    eax,0x0
     4ef:	88 45 db                	mov    BYTE PTR [rbp-0x25],al

   result = NAN == NAN;
     4f2:	c6 45 db 00             	mov    BYTE PTR [rbp-0x25],0x0
   result = NAN != NAN;
     4f6:	c6 45 db 01             	mov    BYTE PTR [rbp-0x25],0x1

   // include math.h
   result = isnan( fA );
     4fa:	f3 0f 10 45 fc          	movss  xmm0,DWORD PTR [rbp-0x4]
     4ff:	0f 2e 45 fc             	ucomiss xmm0,DWORD PTR [rbp-0x4]
     503:	0f 9a c0                	setp   al
     506:	88 45 db                	mov    BYTE PTR [rbp-0x25],al

}//decimals_Float
     509:	90                      	nop
     50a:	c9                      	leave  
     50b:	c3                      	ret    

000000000000050c <decimals_Double>:

//-----------------------------------------------------------------------------

void decimals_Double( void ) {
     50c:	55                      	push   rbp
     50d:	48 89 e5                	mov    rbp,rsp

   // TODO : implement the same aspects of floats as in decimals_Float() for the "double" type   

}//decimals_Double
     510:	90                      	nop
     511:	5d                      	pop    rbp
     512:	c3                      	ret    

0000000000000513 <floatQuirks>:

//-----------------------------------------------------------------------------

void floatQuirks( void ) {
     513:	55                      	push   rbp
     514:	48 89 e5                	mov    rbp,rsp

	float x = 1.1;
     517:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 51f <floatQuirks+0xc>
     51f:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0
	_Bool result = x != 1.1;
     524:	66 0f ef c0             	pxor   xmm0,xmm0
     528:	f3 0f 5a 45 e4          	cvtss2sd xmm0,DWORD PTR [rbp-0x1c]
     52d:	66 0f 2e 05 00 00 00 00 	ucomisd xmm0,QWORD PTR [rip+0x0]        # 535 <floatQuirks+0x22>
     535:	0f 9a c0                	setp   al
     538:	ba 01 00 00 00          	mov    edx,0x1
     53d:	66 0f 2e 05 00 00 00 00 	ucomisd xmm0,QWORD PTR [rip+0x0]        # 545 <floatQuirks+0x32>
     545:	0f 45 c2                	cmovne eax,edx
     548:	88 45 e3                	mov    BYTE PTR [rbp-0x1d],al

    result = (float)x != (double)1.1;
     54b:	66 0f ef c0             	pxor   xmm0,xmm0
     54f:	f3 0f 5a 45 e4          	cvtss2sd xmm0,DWORD PTR [rbp-0x1c]
     554:	66 0f 2e 05 00 00 00 00 	ucomisd xmm0,QWORD PTR [rip+0x0]        # 55c <floatQuirks+0x49>
     55c:	0f 9a c0                	setp   al
     55f:	ba 01 00 00 00          	mov    edx,0x1
     564:	66 0f 2e 05 00 00 00 00 	ucomisd xmm0,QWORD PTR [rip+0x0]        # 56c <floatQuirks+0x59>
     56c:	0f 45 c2                	cmovne eax,edx
     56f:	88 45 e3                	mov    BYTE PTR [rbp-0x1d],al
    result = x != 1.1F;
     572:	f3 0f 10 45 e4          	movss  xmm0,DWORD PTR [rbp-0x1c]
     577:	0f 2e 05 00 00 00 00    	ucomiss xmm0,DWORD PTR [rip+0x0]        # 57e <floatQuirks+0x6b>
     57e:	0f 9a c0                	setp   al
     581:	ba 01 00 00 00          	mov    edx,0x1
     586:	f3 0f 10 45 e4          	movss  xmm0,DWORD PTR [rbp-0x1c]
     58b:	0f 2e 05 00 00 00 00    	ucomiss xmm0,DWORD PTR [rip+0x0]        # 592 <floatQuirks+0x7f>
     592:	0f 45 c2                	cmovne eax,edx
     595:	88 45 e3                	mov    BYTE PTR [rbp-0x1d],al

   float f = 0.1F;
     598:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 5a0 <floatQuirks+0x8d>
     5a0:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   // runtime calculations of values
   f = 0.0F;
     5a5:	66 0f ef c0             	pxor   xmm0,xmm0
     5a9:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     5ae:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     5b3:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 5bb <floatQuirks+0xa8>
     5bb:	f3 0f 58 c1             	addss  xmm0,xmm1
     5bf:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     5c4:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     5c9:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 5d1 <floatQuirks+0xbe>
     5d1:	f3 0f 58 c1             	addss  xmm0,xmm1
     5d5:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   f += 0.2F;
     5da:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     5df:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 5e7 <floatQuirks+0xd4>
     5e7:	f3 0f 58 c1             	addss  xmm0,xmm1
     5eb:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     5f0:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     5f5:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 5fd <floatQuirks+0xea>
     5fd:	f3 0f 58 c1             	addss  xmm0,xmm1
     601:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     606:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     60b:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 613 <floatQuirks+0x100>
     613:	f3 0f 58 c1             	addss  xmm0,xmm1
     617:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   f += 0.2F;
     61c:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     621:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 629 <floatQuirks+0x116>
     629:	f3 0f 58 c1             	addss  xmm0,xmm1
     62d:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     632:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     637:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 63f <floatQuirks+0x12c>
     63f:	f3 0f 58 c1             	addss  xmm0,xmm1
     643:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   f += 0.2F;
     648:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     64d:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 655 <floatQuirks+0x142>
     655:	f3 0f 58 c1             	addss  xmm0,xmm1
     659:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     65e:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     663:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 66b <floatQuirks+0x158>
     66b:	f3 0f 58 c1             	addss  xmm0,xmm1
     66f:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   f += 0.2F;
     674:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     679:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 681 <floatQuirks+0x16e>
     681:	f3 0f 58 c1             	addss  xmm0,xmm1
     685:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   // compile time calculations of values
   float ft = 0.2F * 10;
     68a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 692 <floatQuirks+0x17f>
     692:	f3 0f 11 45 dc          	movss  DWORD PTR [rbp-0x24],xmm0
   float fs = 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F;
     697:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 69f <floatQuirks+0x18c>
     69f:	f3 0f 11 45 d8          	movss  DWORD PTR [rbp-0x28],xmm0

   float fk = 0.5F;
     6a4:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 6ac <floatQuirks+0x199>
     6ac:	f3 0f 11 45 d4          	movss  DWORD PTR [rbp-0x2c],xmm0
   fk = 2.5F;
     6b1:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 6b9 <floatQuirks+0x1a6>
     6b9:	f3 0f 11 45 d4          	movss  DWORD PTR [rbp-0x2c],xmm0
   float fk1 = 0;
     6be:	66 0f ef c0             	pxor   xmm0,xmm0
     6c2:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0

   // runtime calculations of values
   fk1 += 2.6F;
     6c7:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     6cc:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 6d4 <floatQuirks+0x1c1>
     6d4:	f3 0f 58 c1             	addss  xmm0,xmm1
     6d8:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     6dd:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     6e2:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 6ea <floatQuirks+0x1d7>
     6ea:	f3 0f 58 c1             	addss  xmm0,xmm1
     6ee:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     6f3:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     6f8:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 700 <floatQuirks+0x1ed>
     700:	f3 0f 58 c1             	addss  xmm0,xmm1
     704:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     709:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     70e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 716 <floatQuirks+0x203>
     716:	f3 0f 58 c1             	addss  xmm0,xmm1
     71a:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     71f:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     724:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 72c <floatQuirks+0x219>
     72c:	f3 0f 58 c1             	addss  xmm0,xmm1
     730:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0

   fk1 += 2.6F;
     735:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     73a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 742 <floatQuirks+0x22f>
     742:	f3 0f 58 c1             	addss  xmm0,xmm1
     746:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     74b:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     750:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 758 <floatQuirks+0x245>
     758:	f3 0f 58 c1             	addss  xmm0,xmm1
     75c:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     761:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     766:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 76e <floatQuirks+0x25b>
     76e:	f3 0f 58 c1             	addss  xmm0,xmm1
     772:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     777:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     77c:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 784 <floatQuirks+0x271>
     784:	f3 0f 58 c1             	addss  xmm0,xmm1
     788:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fk1 += 2.6F;
     78d:	f3 0f 10 4d d0          	movss  xmm1,DWORD PTR [rbp-0x30]
     792:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 79a <floatQuirks+0x287>
     79a:	f3 0f 58 c1             	addss  xmm0,xmm1
     79e:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0

   float fk2 = 2.6F * 10;
     7a3:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 7ab <floatQuirks+0x298>
     7ab:	f3 0f 11 45 cc          	movss  DWORD PTR [rbp-0x34],xmm0

   result = fk1 == fk2;
     7b0:	f3 0f 10 45 d0          	movss  xmm0,DWORD PTR [rbp-0x30]
     7b5:	0f 2e 45 cc             	ucomiss xmm0,DWORD PTR [rbp-0x34]
     7b9:	0f 9b c0                	setnp  al
     7bc:	ba 00 00 00 00          	mov    edx,0x0
     7c1:	f3 0f 10 45 d0          	movss  xmm0,DWORD PTR [rbp-0x30]
     7c6:	0f 2e 45 cc             	ucomiss xmm0,DWORD PTR [rbp-0x34]
     7ca:	0f 45 c2                	cmovne eax,edx
     7cd:	88 45 e3                	mov    BYTE PTR [rbp-0x1d],al

   int loop = 10;
     7d0:	c7 45 f8 0a 00 00 00    	mov    DWORD PTR [rbp-0x8],0xa
   f = 0.0F;
     7d7:	66 0f ef c0             	pxor   xmm0,xmm0
     7db:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0

   double value = .02;
     7e0:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 7e8 <floatQuirks+0x2d5>
     7e8:	f2 0f 11 45 c0          	movsd  QWORD PTR [rbp-0x40],xmm0
   double diff = value - value;
     7ed:	f2 0f 10 45 c0          	movsd  xmm0,QWORD PTR [rbp-0x40]
     7f2:	f2 0f 5c c0             	subsd  xmm0,xmm0
     7f6:	f2 0f 11 45 b8          	movsd  QWORD PTR [rbp-0x48],xmm0
   result = diff == NAN;
     7fb:	c6 45 e3 00             	mov    BYTE PTR [rbp-0x1d],0x0


   while ( loop-- ) {
     7ff:	eb 16                   	jmp    817 <floatQuirks+0x304>
      f += 0.1F;
     801:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     806:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 80e <floatQuirks+0x2fb>
     80e:	f3 0f 58 c1             	addss  xmm0,xmm1
     812:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   while ( loop-- ) {
     817:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     81a:	8d 50 ff                	lea    edx,[rax-0x1]
     81d:	89 55 f8                	mov    DWORD PTR [rbp-0x8],edx
     820:	85 c0                   	test   eax,eax
     822:	75 dd                   	jne    801 <floatQuirks+0x2ee>
   }


   f = 0.0F;
     824:	66 0f ef c0             	pxor   xmm0,xmm0
     828:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   for ( int j = 0 ; j < 10; j++ ){
     82d:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
     834:	eb 1a                   	jmp    850 <floatQuirks+0x33d>
      f += 0.1F;
     836:	f3 0f 10 4d fc          	movss  xmm1,DWORD PTR [rbp-0x4]
     83b:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 843 <floatQuirks+0x330>
     843:	f3 0f 58 c1             	addss  xmm0,xmm1
     847:	f3 0f 11 45 fc          	movss  DWORD PTR [rbp-0x4],xmm0
   for ( int j = 0 ; j < 10; j++ ){
     84c:	83 45 f4 01             	add    DWORD PTR [rbp-0xc],0x1
     850:	83 7d f4 09             	cmp    DWORD PTR [rbp-0xc],0x9
     854:	7e e0                   	jle    836 <floatQuirks+0x323>
   }

   result = f == ( 10 * 0.1F );
     856:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 85e <floatQuirks+0x34b>
     85e:	0f 2e 45 fc             	ucomiss xmm0,DWORD PTR [rbp-0x4]
     862:	0f 9b c0                	setnp  al
     865:	ba 00 00 00 00          	mov    edx,0x0
     86a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 872 <floatQuirks+0x35f>
     872:	0f 2e 45 fc             	ucomiss xmm0,DWORD PTR [rbp-0x4]
     876:	0f 45 c2                	cmovne eax,edx
     879:	88 45 e3                	mov    BYTE PTR [rbp-0x1d],al

   float secondFromStart = nextafterf( FLT_EPSILON, INFINITY );
     87c:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 884 <floatQuirks+0x371>
     884:	f3 0f 11 45 b4          	movss  DWORD PTR [rbp-0x4c],xmm0

   // round(256.49999) == 256;
   // roundf(256.49999) == 257;

   // for(ever) : http://www.youtube.com/watch?v=IJNR2EpS0jw
   for( double d = 0; d != 0.3; d += 0.1 );
     889:	66 0f ef c0             	pxor   xmm0,xmm0
     88d:	f2 0f 11 45 e8          	movsd  QWORD PTR [rbp-0x18],xmm0
     892:	eb 16                   	jmp    8aa <floatQuirks+0x397>
     894:	f2 0f 10 4d e8          	movsd  xmm1,QWORD PTR [rbp-0x18]
     899:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 8a1 <floatQuirks+0x38e>
     8a1:	f2 0f 58 c1             	addsd  xmm0,xmm1
     8a5:	f2 0f 11 45 e8          	movsd  QWORD PTR [rbp-0x18],xmm0
     8aa:	f2 0f 10 45 e8          	movsd  xmm0,QWORD PTR [rbp-0x18]
     8af:	66 0f 2e 05 00 00 00 00 	ucomisd xmm0,QWORD PTR [rip+0x0]        # 8b7 <floatQuirks+0x3a4>
     8b7:	7a db                   	jp     894 <floatQuirks+0x381>
     8b9:	f2 0f 10 45 e8          	movsd  xmm0,QWORD PTR [rbp-0x18]
     8be:	66 0f 2f 05 00 00 00 00 	comisd xmm0,QWORD PTR [rip+0x0]        # 8c6 <floatQuirks+0x3b3>
     8c6:	75 cc                   	jne    894 <floatQuirks+0x381>

}//floatQuirks
     8c8:	90                      	nop
     8c9:	90                      	nop
     8ca:	5d                      	pop    rbp
     8cb:	c3                      	ret    

00000000000008cc <operators_equality>:

//-----------------------------------------------------------------------------


void operators_equality(void){
     8cc:	55                      	push   rbp
     8cd:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int a = 2;
     8d0:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
   int b = 3;
     8d7:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [rbp-0x8],0x3
   int c = 2;
     8de:	c7 45 f4 02 00 00 00    	mov    DWORD PTR [rbp-0xc],0x2

   _Bool result = 0;
     8e5:	c6 45 f3 00             	mov    BYTE PTR [rbp-0xd],0x0

   // equality
   result = a == a;
     8e9:	c6 45 f3 01             	mov    BYTE PTR [rbp-0xd],0x1

   result = a == b;
     8ed:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     8f0:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     8f3:	0f 94 c0                	sete   al
     8f6:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

   result = a == c;
     8f9:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     8fc:	3b 45 f4                	cmp    eax,DWORD PTR [rbp-0xc]
     8ff:	0f 94 c0                	sete   al
     902:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

   result = c == b;
     905:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     908:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     90b:	0f 94 c0                	sete   al
     90e:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al


   // inequality
   result = a != a;
     911:	c6 45 f3 00             	mov    BYTE PTR [rbp-0xd],0x0

   result = a != b;
     915:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     918:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     91b:	0f 95 c0                	setne  al
     91e:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

   result = a != c;
     921:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     924:	3b 45 f4                	cmp    eax,DWORD PTR [rbp-0xc]
     927:	0f 95 c0                	setne  al
     92a:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

   result = c != b;
     92d:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     930:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     933:	0f 95 c0                	setne  al
     936:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

}//operators_equality
     939:	90                      	nop
     93a:	5d                      	pop    rbp
     93b:	c3                      	ret    

000000000000093c <operators_relational>:

//-----------------------------------------------------------------------------

void operators_relational( void ) {
     93c:	55                      	push   rbp
     93d:	48 89 e5                	mov    rbp,rsp

  // see disassembly
  int a = 2;
     940:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
  int b = 3;
     947:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [rbp-0x8],0x3
  int c = 0;
     94e:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

  _Bool result = 0;
     955:	c6 45 f3 00             	mov    BYTE PTR [rbp-0xd],0x0

  result = a > b;
     959:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     95c:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     95f:	0f 9f c0                	setg   al
     962:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  result = a >= b;
     965:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     968:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     96b:	0f 9d c0                	setge  al
     96e:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  result = a < b;
     971:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     974:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     977:	0f 9c c0                	setl   al
     97a:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  result = a <= b;
     97d:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     980:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     983:	0f 9e c0                	setle  al
     986:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

}//operators_relational
     989:	90                      	nop
     98a:	5d                      	pop    rbp
     98b:	c3                      	ret    

000000000000098c <operators_logical>:

//-----------------------------------------------------------------------------

void operators_logical( void ) {
     98c:	55                      	push   rbp
     98d:	48 89 e5                	mov    rbp,rsp

  // see disassembly
  int a = 2;
     990:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
  int b = 3;
     997:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [rbp-0x8],0x3
  int c = 0;
     99e:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

  _Bool result = 0;
     9a5:	c6 45 f3 00             	mov    BYTE PTR [rbp-0xd],0x0

  // equality
  result = a == a;
     9a9:	c6 45 f3 01             	mov    BYTE PTR [rbp-0xd],0x1
  result = !( a != b );
     9ad:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     9b0:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     9b3:	0f 94 c0                	sete   al
     9b6:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  // inequality
  result = a != b;
     9b9:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     9bc:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     9bf:	0f 95 c0                	setne  al
     9c2:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
  result = !( a == b );
     9c5:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     9c8:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     9cb:	0f 95 c0                	setne  al
     9ce:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  // logical and
  result = ( a > b ) && ( b > c );
     9d1:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     9d4:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     9d7:	7e 0f                   	jle    9e8 <operators_logical+0x5c>
     9d9:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     9dc:	3b 45 f4                	cmp    eax,DWORD PTR [rbp-0xc]
     9df:	7e 07                   	jle    9e8 <operators_logical+0x5c>
     9e1:	b8 01 00 00 00          	mov    eax,0x1
     9e6:	eb 05                   	jmp    9ed <operators_logical+0x61>
     9e8:	b8 00 00 00 00          	mov    eax,0x0
     9ed:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
     9f0:	80 65 f3 01             	and    BYTE PTR [rbp-0xd],0x1

  // logical inclusive or
  result = ( a > b ) || ( b > c );
     9f4:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     9f7:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     9fa:	7f 08                   	jg     a04 <operators_logical+0x78>
     9fc:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     9ff:	3b 45 f4                	cmp    eax,DWORD PTR [rbp-0xc]
     a02:	7e 07                   	jle    a0b <operators_logical+0x7f>
     a04:	b8 01 00 00 00          	mov    eax,0x1
     a09:	eb 05                   	jmp    a10 <operators_logical+0x84>
     a0b:	b8 00 00 00 00          	mov    eax,0x0
     a10:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
     a13:	80 65 f3 01             	and    BYTE PTR [rbp-0xd],0x1

  // logical exclusive or (equivalent)
  result = ( a > b ) != ( b > c );
     a17:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     a1a:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     a1d:	0f 9f c2                	setg   dl
     a20:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     a23:	3b 45 f4                	cmp    eax,DWORD PTR [rbp-0xc]
     a26:	0f 9f c0                	setg   al
     a29:	31 d0                   	xor    eax,edx
     a2b:	0f b6 c0                	movzx  eax,al
     a2e:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
     a31:	80 65 f3 01             	and    BYTE PTR [rbp-0xd],0x1

  // bool normalized exclusive or (equivalent)
  result = !a != !c;
     a35:	83 7d fc 00             	cmp    DWORD PTR [rbp-0x4],0x0
     a39:	0f 94 c2                	sete   dl
     a3c:	83 7d f4 00             	cmp    DWORD PTR [rbp-0xc],0x0
     a40:	0f 94 c0                	sete   al
     a43:	31 d0                   	xor    eax,edx
     a45:	0f b6 c0                	movzx  eax,al
     a48:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
     a4b:	80 65 f3 01             	and    BYTE PTR [rbp-0xd],0x1
  result = (_Bool)a != (_Bool)c;
     a4f:	83 7d fc 00             	cmp    DWORD PTR [rbp-0x4],0x0
     a53:	0f 95 c2                	setne  dl
     a56:	83 7d f4 00             	cmp    DWORD PTR [rbp-0xc],0x0
     a5a:	0f 95 c0                	setne  al
     a5d:	31 d0                   	xor    eax,edx
     a5f:	0f b6 c0                	movzx  eax,al
     a62:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
     a65:	80 65 f3 01             	and    BYTE PTR [rbp-0xd],0x1

  result = a >= b;
     a69:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     a6c:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     a6f:	0f 9d c0                	setge  al
     a72:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
  result = !( a < b );
     a75:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     a78:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     a7b:	0f 9d c0                	setge  al
     a7e:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  result = a < b;
     a81:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     a84:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     a87:	0f 9c c0                	setl   al
     a8a:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
  result = !( a >= b );
     a8d:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     a90:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     a93:	0f 9c c0                	setl   al
     a96:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

  result = a <= b;
     a99:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     a9c:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     a9f:	0f 9e c0                	setle  al
     aa2:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al
  result = !( a > b );
     aa5:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     aa8:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     aab:	0f 9e c0                	setle  al
     aae:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

}//operators_logical
     ab1:	90                      	nop
     ab2:	5d                      	pop    rbp
     ab3:	c3                      	ret    

0000000000000ab4 <operators_assignment>:

//-----------------------------------------------------------------------------

void operators_assignment( void ) {
     ab4:	55                      	push   rbp
     ab5:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int a = 2;
     ab8:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
   int b = 3;
     abf:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [rbp-0x8],0x3
   int r = 0;
     ac6:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   r = r + 1;
     acd:	83 45 f4 01             	add    DWORD PTR [rbp-0xc],0x1
   r += 1;
     ad1:	83 45 f4 01             	add    DWORD PTR [rbp-0xc],0x1

   r = r - 1;
     ad5:	83 6d f4 01             	sub    DWORD PTR [rbp-0xc],0x1
   r -= 1;
     ad9:	83 6d f4 01             	sub    DWORD PTR [rbp-0xc],0x1

   r = 1;
     add:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1
   r = r * a;
     ae4:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     ae7:	0f af 45 fc             	imul   eax,DWORD PTR [rbp-0x4]
     aeb:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   r *= a;
     aee:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     af1:	0f af 45 fc             	imul   eax,DWORD PTR [rbp-0x4]
     af5:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

   r = r / 2;
     af8:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     afb:	89 c2                   	mov    edx,eax
     afd:	c1 ea 1f                	shr    edx,0x1f
     b00:	01 d0                   	add    eax,edx
     b02:	d1 f8                   	sar    eax,1
     b04:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   r /= 2;
     b07:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     b0a:	89 c2                   	mov    edx,eax
     b0c:	c1 ea 1f                	shr    edx,0x1f
     b0f:	01 d0                   	add    eax,edx
     b11:	d1 f8                   	sar    eax,1
     b13:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

   r = 5;
     b16:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [rbp-0xc],0x5
   r = r % 2;
     b1d:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     b20:	99                      	cdq    
     b21:	c1 ea 1f                	shr    edx,0x1f
     b24:	01 d0                   	add    eax,edx
     b26:	83 e0 01                	and    eax,0x1
     b29:	29 d0                   	sub    eax,edx
     b2b:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

   r = 5;
     b2e:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [rbp-0xc],0x5
   r %=  2;
     b35:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     b38:	99                      	cdq    
     b39:	c1 ea 1f                	shr    edx,0x1f
     b3c:	01 d0                   	add    eax,edx
     b3e:	83 e0 01                	and    eax,0x1
     b41:	29 d0                   	sub    eax,edx
     b43:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

   // TODO : diğer "compound assignment" operatörleri

}//operators_assignment
     b46:	90                      	nop
     b47:	5d                      	pop    rbp
     b48:	c3                      	ret    

0000000000000b49 <operators_conditionalExpression>:

//-----------------------------------------------------------------------------

void operators_conditionalExpression( void ) {
     b49:	55                      	push   rbp
     b4a:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int a = 2;
     b4d:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
   int b = 3;
     b54:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [rbp-0x8],0x3

   int min = 0;
     b5b:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
   int max = 0;
     b62:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [rbp-0x10],0x0

   min =  a < b ? a : b;
     b69:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     b6c:	39 45 f8                	cmp    DWORD PTR [rbp-0x8],eax
     b6f:	0f 4e 45 f8             	cmovle eax,DWORD PTR [rbp-0x8]
     b73:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   max =  a > b ? a : b;
     b76:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     b79:	39 45 f8                	cmp    DWORD PTR [rbp-0x8],eax
     b7c:	0f 4d 45 f8             	cmovge eax,DWORD PTR [rbp-0x8]
     b80:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax

   if ( a < b ) {
     b83:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     b86:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     b89:	7d 08                   	jge    b93 <operators_conditionalExpression+0x4a>
      min = a;
     b8b:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     b8e:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
     b91:	eb 06                   	jmp    b99 <operators_conditionalExpression+0x50>
   } else {
      min = b;
     b93:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     b96:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   };

   if ( a > b ) {
     b99:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     b9c:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
     b9f:	7e 08                   	jle    ba9 <operators_conditionalExpression+0x60>
      max = a;
     ba1:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     ba4:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax
     ba7:	eb 06                   	jmp    baf <operators_conditionalExpression+0x66>
   } else {
      max = b;
     ba9:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     bac:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax
   };

   int  x    = 0;
     baf:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
   char sign = '.';
     bb6:	c6 45 eb 2e             	mov    BYTE PTR [rbp-0x15],0x2e

   x = 0;
     bba:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
   sign = x < 0 ? '-' :
     bc1:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
     bc5:	78 14                   	js     bdb <operators_conditionalExpression+0x92>
     bc7:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
     bcb:	7e 07                   	jle    bd4 <operators_conditionalExpression+0x8b>
     bcd:	b8 2b 00 00 00          	mov    eax,0x2b
     bd2:	eb 0c                   	jmp    be0 <operators_conditionalExpression+0x97>
     bd4:	b8 2e 00 00 00          	mov    eax,0x2e
     bd9:	eb 05                   	jmp    be0 <operators_conditionalExpression+0x97>
     bdb:	b8 2d 00 00 00          	mov    eax,0x2d
     be0:	88 45 eb                	mov    BYTE PTR [rbp-0x15],al
          x > 0 ? '+' :
          '.';

   x = -5;
     be3:	c7 45 ec fb ff ff ff    	mov    DWORD PTR [rbp-0x14],0xfffffffb
   sign = x < 0 ? '-' :
     bea:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
     bee:	78 14                   	js     c04 <operators_conditionalExpression+0xbb>
     bf0:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
     bf4:	7e 07                   	jle    bfd <operators_conditionalExpression+0xb4>
     bf6:	b8 2b 00 00 00          	mov    eax,0x2b
     bfb:	eb 0c                   	jmp    c09 <operators_conditionalExpression+0xc0>
     bfd:	b8 2e 00 00 00          	mov    eax,0x2e
     c02:	eb 05                   	jmp    c09 <operators_conditionalExpression+0xc0>
     c04:	b8 2d 00 00 00          	mov    eax,0x2d
     c09:	88 45 eb                	mov    BYTE PTR [rbp-0x15],al
          x > 0 ? '+' :
          '.';

   x = +5;
     c0c:	c7 45 ec 05 00 00 00    	mov    DWORD PTR [rbp-0x14],0x5
   sign = x < 0 ? '-' :
     c13:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
     c17:	78 14                   	js     c2d <operators_conditionalExpression+0xe4>
     c19:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
     c1d:	7e 07                   	jle    c26 <operators_conditionalExpression+0xdd>
     c1f:	b8 2b 00 00 00          	mov    eax,0x2b
     c24:	eb 0c                   	jmp    c32 <operators_conditionalExpression+0xe9>
     c26:	b8 2e 00 00 00          	mov    eax,0x2e
     c2b:	eb 05                   	jmp    c32 <operators_conditionalExpression+0xe9>
     c2d:	b8 2d 00 00 00          	mov    eax,0x2d
     c32:	88 45 eb                	mov    BYTE PTR [rbp-0x15],al
          x > 0 ? '+' :
          '.';

   enum { colder, cold, warm, hot, hotter } climate = colder;
     c35:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0

   int c = 18;
     c3c:	c7 45 e0 12 00 00 00    	mov    DWORD PTR [rbp-0x20],0x12
   climate = ( c <= -10 ) ? colder :
     c43:	83 7d e0 f7             	cmp    DWORD PTR [rbp-0x20],0xfffffff7
     c47:	7c 40                   	jl     c89 <operators_conditionalExpression+0x140>
     c49:	83 7d e0 f7             	cmp    DWORD PTR [rbp-0x20],0xfffffff7
     c4d:	7c 06                   	jl     c55 <operators_conditionalExpression+0x10c>
             ( c > -10 ) && ( c <= 10 ) ? cold :
     c4f:	83 7d e0 0a             	cmp    DWORD PTR [rbp-0x20],0xa
     c53:	7e 2d                   	jle    c82 <operators_conditionalExpression+0x139>
   climate = ( c <= -10 ) ? colder :
     c55:	83 7d e0 0a             	cmp    DWORD PTR [rbp-0x20],0xa
     c59:	7e 06                   	jle    c61 <operators_conditionalExpression+0x118>
             ( c >  10 ) && ( c <= 25 ) ? warm :
     c5b:	83 7d e0 19             	cmp    DWORD PTR [rbp-0x20],0x19
     c5f:	7e 1a                   	jle    c7b <operators_conditionalExpression+0x132>
   climate = ( c <= -10 ) ? colder :
     c61:	83 7d e0 19             	cmp    DWORD PTR [rbp-0x20],0x19
     c65:	7e 0d                   	jle    c74 <operators_conditionalExpression+0x12b>
             ( c >  25 ) && ( c <= 35 ) ? hot  :
     c67:	83 7d e0 23             	cmp    DWORD PTR [rbp-0x20],0x23
     c6b:	7f 07                   	jg     c74 <operators_conditionalExpression+0x12b>
   climate = ( c <= -10 ) ? colder :
     c6d:	b8 03 00 00 00          	mov    eax,0x3
     c72:	eb 1a                   	jmp    c8e <operators_conditionalExpression+0x145>
     c74:	b8 04 00 00 00          	mov    eax,0x4
     c79:	eb 13                   	jmp    c8e <operators_conditionalExpression+0x145>
     c7b:	b8 02 00 00 00          	mov    eax,0x2
     c80:	eb 0c                   	jmp    c8e <operators_conditionalExpression+0x145>
     c82:	b8 01 00 00 00          	mov    eax,0x1
     c87:	eb 05                   	jmp    c8e <operators_conditionalExpression+0x145>
     c89:	b8 00 00 00 00          	mov    eax,0x0
     c8e:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax
             hotter;

}//operators_conditionalExpression
     c91:	90                      	nop
     c92:	5d                      	pop    rbp
     c93:	c3                      	ret    

0000000000000c94 <operators_multiplicative>:

//-----------------------------------------------------------------------------

void operators_multiplicative( void ) {
     c94:	55                      	push   rbp
     c95:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   char ca = 2;
     c98:	c6 45 ff 02             	mov    BYTE PTR [rbp-0x1],0x2
   char cb = 3;
     c9c:	c6 45 fe 03             	mov    BYTE PTR [rbp-0x2],0x3
   char cc = 0;
     ca0:	c6 45 fd 00             	mov    BYTE PTR [rbp-0x3],0x0

   int ia = 2;
     ca4:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [rbp-0x8],0x2
   int ib = 3;
     cab:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
   int ic = 0;
     cb2:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [rbp-0x10],0x0

   unsigned int ua = 2;
     cb9:	c7 45 ec 02 00 00 00    	mov    DWORD PTR [rbp-0x14],0x2
   unsigned int ub = 3;
     cc0:	c7 45 e8 03 00 00 00    	mov    DWORD PTR [rbp-0x18],0x3
   unsigned int uc = 0;
     cc7:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0

   float fa = .2F;
     cce:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # cd6 <operators_multiplicative+0x42>
     cd6:	f3 0f 11 45 e0          	movss  DWORD PTR [rbp-0x20],xmm0
   float fb = .3F;
     cdb:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # ce3 <operators_multiplicative+0x4f>
     ce3:	f3 0f 11 45 dc          	movss  DWORD PTR [rbp-0x24],xmm0
   float fc = .0F;
     ce8:	66 0f ef c0             	pxor   xmm0,xmm0
     cec:	f3 0f 11 45 d8          	movss  DWORD PTR [rbp-0x28],xmm0

   cc = ca * cb;
     cf1:	0f b6 45 ff             	movzx  eax,BYTE PTR [rbp-0x1]
     cf5:	0f b6 55 fe             	movzx  edx,BYTE PTR [rbp-0x2]
     cf9:	0f af c2                	imul   eax,edx
     cfc:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = cc / ca;
     cff:	0f be 45 fd             	movsx  eax,BYTE PTR [rbp-0x3]
     d03:	0f be 75 ff             	movsx  esi,BYTE PTR [rbp-0x1]
     d07:	99                      	cdq    
     d08:	f7 fe                   	idiv   esi
     d0a:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = cb % ca;
     d0d:	0f be 45 fe             	movsx  eax,BYTE PTR [rbp-0x2]
     d11:	0f be 4d ff             	movsx  ecx,BYTE PTR [rbp-0x1]
     d15:	99                      	cdq    
     d16:	f7 f9                   	idiv   ecx
     d18:	89 d0                   	mov    eax,edx
     d1a:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al

   ic = ia * ib;
     d1d:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
     d20:	0f af 45 f4             	imul   eax,DWORD PTR [rbp-0xc]
     d24:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax
   ic = ic / ia;
     d27:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
     d2a:	99                      	cdq    
     d2b:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
     d2e:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax
   ic = ib % ia;
     d31:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
     d34:	99                      	cdq    
     d35:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
     d38:	89 55 f0                	mov    DWORD PTR [rbp-0x10],edx

   uc = ua * ub;
     d3b:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
     d3e:	0f af 45 e8             	imul   eax,DWORD PTR [rbp-0x18]
     d42:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax
   uc = uc / ua;
     d45:	8b 45 e4                	mov    eax,DWORD PTR [rbp-0x1c]
     d48:	ba 00 00 00 00          	mov    edx,0x0
     d4d:	f7 75 ec                	div    DWORD PTR [rbp-0x14]
     d50:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax
   uc = ub % ua; // remainder
     d53:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
     d56:	ba 00 00 00 00          	mov    edx,0x0
     d5b:	f7 75 ec                	div    DWORD PTR [rbp-0x14]
     d5e:	89 55 e4                	mov    DWORD PTR [rbp-0x1c],edx

   fc = fa * fb;
     d61:	f3 0f 10 45 e0          	movss  xmm0,DWORD PTR [rbp-0x20]
     d66:	f3 0f 59 45 dc          	mulss  xmm0,DWORD PTR [rbp-0x24]
     d6b:	f3 0f 11 45 d8          	movss  DWORD PTR [rbp-0x28],xmm0
   fc = fc / fa;
     d70:	f3 0f 10 45 d8          	movss  xmm0,DWORD PTR [rbp-0x28]
     d75:	f3 0f 5e 45 e0          	divss  xmm0,DWORD PTR [rbp-0x20]
     d7a:	f3 0f 11 45 d8          	movss  DWORD PTR [rbp-0x28],xmm0

   //fc = fc % fa; // ?
   //fc = fc % ia; // ?

   // remainder
   int a =  3 % -2;
     d7f:	c7 45 d4 01 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x1
   int b = -3 %  2;
     d86:	c7 45 d0 ff ff ff ff    	mov    DWORD PTR [rbp-0x30],0xffffffff
   int c = -3 % -2;
     d8d:	c7 45 cc ff ff ff ff    	mov    DWORD PTR [rbp-0x34],0xffffffff
	
}//operators_multiplicative
     d94:	90                      	nop
     d95:	5d                      	pop    rbp
     d96:	c3                      	ret    

0000000000000d97 <Remainder>:

//-----------------------------------------------------------------------------

// remainder: causes conflict 
int Remainder( int a, int b ) {
     d97:	55                      	push   rbp
     d98:	48 89 e5                	mov    rbp,rsp
     d9b:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi
     d9e:	89 75 f8                	mov    DWORD PTR [rbp-0x8],esi

   return a - (a / b) * b;
     da1:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
     da4:	99                      	cdq    
     da5:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
     da8:	89 d0                   	mov    eax,edx

}
     daa:	5d                      	pop    rbp
     dab:	c3                      	ret    

0000000000000dac <modulo>:

//-----------------------------------------------------------------------------

int modulo( int a, int b ) {
     dac:	55                      	push   rbp
     dad:	48 89 e5                	mov    rbp,rsp
     db0:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi
     db3:	89 75 e8                	mov    DWORD PTR [rbp-0x18],esi

   int r = a % b;
     db6:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
     db9:	99                      	cdq    
     dba:	f7 7d e8                	idiv   DWORD PTR [rbp-0x18]
     dbd:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
   return r < 0 ? r + b : r;
     dc0:	83 7d fc 00             	cmp    DWORD PTR [rbp-0x4],0x0
     dc4:	79 0a                   	jns    dd0 <modulo+0x24>
     dc6:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
     dc9:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
     dcc:	01 d0                   	add    eax,edx
     dce:	eb 03                   	jmp    dd3 <modulo+0x27>
     dd0:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]

}
     dd3:	5d                      	pop    rbp
     dd4:	c3                      	ret    

0000000000000dd5 <operators_additive>:

//-----------------------------------------------------------------------------

void operators_additive( void ) {
     dd5:	55                      	push   rbp
     dd6:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   char ca = 2;
     dd9:	c6 45 ff 02             	mov    BYTE PTR [rbp-0x1],0x2
   char cb = 3;
     ddd:	c6 45 fe 03             	mov    BYTE PTR [rbp-0x2],0x3
   char cc = 0;
     de1:	c6 45 fd 00             	mov    BYTE PTR [rbp-0x3],0x0

   short sa = 2;
     de5:	66 c7 45 fa 02 00       	mov    WORD PTR [rbp-0x6],0x2
   short sb = 3;
     deb:	66 c7 45 f8 03 00       	mov    WORD PTR [rbp-0x8],0x3
   short sc = 0;
     df1:	66 c7 45 f6 00 00       	mov    WORD PTR [rbp-0xa],0x0

   int ia = 2;
     df7:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [rbp-0x10],0x2
   int ib = 3;
     dfe:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
   int ic = 0;
     e05:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [rbp-0x18],0x0

   unsigned int ua = 2;
     e0c:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x2
   unsigned int ub = 3;
     e13:	c7 45 e0 03 00 00 00    	mov    DWORD PTR [rbp-0x20],0x3
   unsigned int uc = 0;
     e1a:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [rbp-0x24],0x0

   float fa = .2F;
     e21:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # e29 <operators_additive+0x54>
     e29:	f3 0f 11 45 d8          	movss  DWORD PTR [rbp-0x28],xmm0
   float fb = .3F;
     e2e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # e36 <operators_additive+0x61>
     e36:	f3 0f 11 45 d4          	movss  DWORD PTR [rbp-0x2c],xmm0
   float fc = .0F;
     e3b:	66 0f ef c0             	pxor   xmm0,xmm0
     e3f:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0

   cc = ca + cb;
     e44:	0f b6 55 ff             	movzx  edx,BYTE PTR [rbp-0x1]
     e48:	0f b6 45 fe             	movzx  eax,BYTE PTR [rbp-0x2]
     e4c:	01 d0                   	add    eax,edx
     e4e:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = cb - ca;
     e51:	0f b6 45 fe             	movzx  eax,BYTE PTR [rbp-0x2]
     e55:	0f b6 55 ff             	movzx  edx,BYTE PTR [rbp-0x1]
     e59:	29 d0                   	sub    eax,edx
     e5b:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = ca - cb;
     e5e:	0f b6 45 ff             	movzx  eax,BYTE PTR [rbp-0x1]
     e62:	0f b6 55 fe             	movzx  edx,BYTE PTR [rbp-0x2]
     e66:	29 d0                   	sub    eax,edx
     e68:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al

   sc = sa + sb;
     e6b:	0f b7 55 fa             	movzx  edx,WORD PTR [rbp-0x6]
     e6f:	0f b7 45 f8             	movzx  eax,WORD PTR [rbp-0x8]
     e73:	01 d0                   	add    eax,edx
     e75:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = sb - sa;
     e79:	0f b7 45 f8             	movzx  eax,WORD PTR [rbp-0x8]
     e7d:	0f b7 55 fa             	movzx  edx,WORD PTR [rbp-0x6]
     e81:	29 d0                   	sub    eax,edx
     e83:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = sa - sb;
     e87:	0f b7 45 fa             	movzx  eax,WORD PTR [rbp-0x6]
     e8b:	0f b7 55 f8             	movzx  edx,WORD PTR [rbp-0x8]
     e8f:	29 d0                   	sub    eax,edx
     e91:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax

   ic = ia + ib;
     e95:	8b 55 f0                	mov    edx,DWORD PTR [rbp-0x10]
     e98:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
     e9b:	01 d0                   	add    eax,edx
     e9d:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax
   ic = ib - ia;
     ea0:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
     ea3:	2b 45 f0                	sub    eax,DWORD PTR [rbp-0x10]
     ea6:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax
   ic = ia - ib;
     ea9:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
     eac:	2b 45 ec                	sub    eax,DWORD PTR [rbp-0x14]
     eaf:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

   uc = ua + ub;
     eb2:	8b 55 e4                	mov    edx,DWORD PTR [rbp-0x1c]
     eb5:	8b 45 e0                	mov    eax,DWORD PTR [rbp-0x20]
     eb8:	01 d0                   	add    eax,edx
     eba:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
   uc = ub - ua;
     ebd:	8b 45 e0                	mov    eax,DWORD PTR [rbp-0x20]
     ec0:	2b 45 e4                	sub    eax,DWORD PTR [rbp-0x1c]
     ec3:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
   uc = ua - ub;
     ec6:	8b 45 e4                	mov    eax,DWORD PTR [rbp-0x1c]
     ec9:	2b 45 e0                	sub    eax,DWORD PTR [rbp-0x20]
     ecc:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax

   fc = fa + fb;
     ecf:	f3 0f 10 45 d8          	movss  xmm0,DWORD PTR [rbp-0x28]
     ed4:	f3 0f 58 45 d4          	addss  xmm0,DWORD PTR [rbp-0x2c]
     ed9:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fc = fb - fa;
     ede:	f3 0f 10 45 d4          	movss  xmm0,DWORD PTR [rbp-0x2c]
     ee3:	f3 0f 5c 45 d8          	subss  xmm0,DWORD PTR [rbp-0x28]
     ee8:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0
   fc = fa - fb;
     eed:	f3 0f 10 45 d8          	movss  xmm0,DWORD PTR [rbp-0x28]
     ef2:	f3 0f 5c 45 d4          	subss  xmm0,DWORD PTR [rbp-0x2c]
     ef7:	f3 0f 11 45 d0          	movss  DWORD PTR [rbp-0x30],xmm0

}//operators_additive
     efc:	90                      	nop
     efd:	5d                      	pop    rbp
     efe:	c3                      	ret    

0000000000000eff <operators_binary>:

//-----------------------------------------------------------------------------

void operators_binary( void ) {
     eff:	55                      	push   rbp
     f00:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   char ca = 2;
     f03:	c6 45 ff 02             	mov    BYTE PTR [rbp-0x1],0x2
   char cb = 3;
     f07:	c6 45 fe 03             	mov    BYTE PTR [rbp-0x2],0x3
   char cc = 0;
     f0b:	c6 45 fd 00             	mov    BYTE PTR [rbp-0x3],0x0

   short sa = 2;
     f0f:	66 c7 45 fa 02 00       	mov    WORD PTR [rbp-0x6],0x2
   short sb = 3;
     f15:	66 c7 45 f8 03 00       	mov    WORD PTR [rbp-0x8],0x3
   short sc = 0;
     f1b:	66 c7 45 f6 00 00       	mov    WORD PTR [rbp-0xa],0x0

   int ia = 2;
     f21:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [rbp-0x10],0x2
   int ib = 3;
     f28:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
   int ic = 0;
     f2f:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [rbp-0x18],0x0

   unsigned int ua = 2;
     f36:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x2
   unsigned int ub = 3;
     f3d:	c7 45 e0 03 00 00 00    	mov    DWORD PTR [rbp-0x20],0x3
   unsigned int uc = 0;
     f44:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [rbp-0x24],0x0

   cc = ca & cb;
     f4b:	0f b6 45 ff             	movzx  eax,BYTE PTR [rbp-0x1]
     f4f:	22 45 fe                	and    al,BYTE PTR [rbp-0x2]
     f52:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = ca | cb;
     f55:	0f b6 45 ff             	movzx  eax,BYTE PTR [rbp-0x1]
     f59:	0a 45 fe                	or     al,BYTE PTR [rbp-0x2]
     f5c:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = ca ^ cb;
     f5f:	0f b6 45 ff             	movzx  eax,BYTE PTR [rbp-0x1]
     f63:	32 45 fe                	xor    al,BYTE PTR [rbp-0x2]
     f66:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = ~ca;
     f69:	0f b6 45 ff             	movzx  eax,BYTE PTR [rbp-0x1]
     f6d:	f7 d0                   	not    eax
     f6f:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al

   cc = ca << 1;
     f72:	0f be 45 ff             	movsx  eax,BYTE PTR [rbp-0x1]
     f76:	01 c0                   	add    eax,eax
     f78:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al
   cc = ca << 2;
     f7b:	0f be 45 ff             	movsx  eax,BYTE PTR [rbp-0x1]
     f7f:	c1 e0 02                	shl    eax,0x2
     f82:	88 45 fd                	mov    BYTE PTR [rbp-0x3],al

   sc = sa & sb;
     f85:	0f b7 45 fa             	movzx  eax,WORD PTR [rbp-0x6]
     f89:	66 23 45 f8             	and    ax,WORD PTR [rbp-0x8]
     f8d:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = sa | sb;
     f91:	0f b7 45 fa             	movzx  eax,WORD PTR [rbp-0x6]
     f95:	66 0b 45 f8             	or     ax,WORD PTR [rbp-0x8]
     f99:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = sa ^ sb;
     f9d:	0f b7 45 fa             	movzx  eax,WORD PTR [rbp-0x6]
     fa1:	66 33 45 f8             	xor    ax,WORD PTR [rbp-0x8]
     fa5:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = ~sa;
     fa9:	0f b7 45 fa             	movzx  eax,WORD PTR [rbp-0x6]
     fad:	f7 d0                   	not    eax
     faf:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax

   sc = sa << 1;
     fb3:	0f bf 45 fa             	movsx  eax,WORD PTR [rbp-0x6]
     fb7:	01 c0                   	add    eax,eax
     fb9:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = sa << 2;
     fbd:	0f bf 45 fa             	movsx  eax,WORD PTR [rbp-0x6]
     fc1:	c1 e0 02                	shl    eax,0x2
     fc4:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax

   sc = -3;
     fc8:	66 c7 45 f6 fd ff       	mov    WORD PTR [rbp-0xa],0xfffd
   sc = sc << 1;
     fce:	0f bf 45 f6             	movsx  eax,WORD PTR [rbp-0xa]
     fd2:	01 c0                   	add    eax,eax
     fd4:	66 89 45 f6             	mov    WORD PTR [rbp-0xa],ax
   sc = -3;
     fd8:	66 c7 45 f6 fd ff       	mov    WORD PTR [rbp-0xa],0xfffd
   sc = sc >> 1;
     fde:	66 d1 7d f6             	sar    WORD PTR [rbp-0xa],1

   ic = ia & ib;
     fe2:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
     fe5:	23 45 ec                	and    eax,DWORD PTR [rbp-0x14]
     fe8:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax
   ic = ia | ib;
     feb:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
     fee:	0b 45 ec                	or     eax,DWORD PTR [rbp-0x14]
     ff1:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax
   ic = ia ^ ib;
     ff4:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
     ff7:	33 45 ec                	xor    eax,DWORD PTR [rbp-0x14]
     ffa:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax
   ic = ~ia;
     ffd:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    1000:	f7 d0                   	not    eax
    1002:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

   ic = -3;
    1005:	c7 45 e8 fd ff ff ff    	mov    DWORD PTR [rbp-0x18],0xfffffffd
   ic = ic << 1;
    100c:	d1 65 e8                	shl    DWORD PTR [rbp-0x18],1
   ic = -3;
    100f:	c7 45 e8 fd ff ff ff    	mov    DWORD PTR [rbp-0x18],0xfffffffd
   ic = ic >> 1;
    1016:	d1 7d e8                	sar    DWORD PTR [rbp-0x18],1

   uc = ua & ub;
    1019:	8b 45 e4                	mov    eax,DWORD PTR [rbp-0x1c]
    101c:	23 45 e0                	and    eax,DWORD PTR [rbp-0x20]
    101f:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
   uc = ua | ub;
    1022:	8b 45 e4                	mov    eax,DWORD PTR [rbp-0x1c]
    1025:	0b 45 e0                	or     eax,DWORD PTR [rbp-0x20]
    1028:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
   uc = ua ^ ub;
    102b:	8b 45 e4                	mov    eax,DWORD PTR [rbp-0x1c]
    102e:	33 45 e0                	xor    eax,DWORD PTR [rbp-0x20]
    1031:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
   uc = ~ua;
    1034:	8b 45 e4                	mov    eax,DWORD PTR [rbp-0x1c]
    1037:	f7 d0                   	not    eax
    1039:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax

   uc = 8;
    103c:	c7 45 dc 08 00 00 00    	mov    DWORD PTR [rbp-0x24],0x8
   uc = uc << 1;
    1043:	d1 65 dc                	shl    DWORD PTR [rbp-0x24],1
   uc = 8;
    1046:	c7 45 dc 08 00 00 00    	mov    DWORD PTR [rbp-0x24],0x8
   uc = uc >> 1;
    104d:	d1 6d dc                	shr    DWORD PTR [rbp-0x24],1

}//operators_binary
    1050:	90                      	nop
    1051:	5d                      	pop    rbp
    1052:	c3                      	ret    

0000000000001053 <pointers1>:

//-----------------------------------------------------------------------------

void pointers1( void ) {
    1053:	55                      	push   rbp
    1054:	48 89 e5                	mov    rbp,rsp

   int a = 0;
    1057:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0
   int b = 0;
    105e:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0


   unsigned int addressX = 0;
    1065:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
   unsigned int addressY = 0;
    106c:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   char ar[] = "vwxyz";
    1073:	c7 45 ca 76 77 78 79    	mov    DWORD PTR [rbp-0x36],0x79787776
    107a:	66 c7 45 ce 7a 00       	mov    WORD PTR [rbp-0x32],0x7a
   int  *pi;
   int* piA = NULL;
    1080:	48 c7 45 e8 00 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
   int* piB = NULL;
    1088:	48 c7 45 e0 00 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0

   pi = 0;
    1090:	48 c7 45 d8 00 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
   pi = '\0';
    1098:	48 c7 45 d8 00 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
   pi = NULL;
    10a0:	48 c7 45 d8 00 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0

   pi  = &a;
    10a8:	48 8d 45 d0             	lea    rax,[rbp-0x30]
    10ac:	48 89 45 d8             	mov    QWORD PTR [rbp-0x28],rax
   *pi = 3;
    10b0:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    10b4:	c7 00 03 00 00 00       	mov    DWORD PTR [rax],0x3

   addressX = &a;
    10ba:	48 8d 45 d0             	lea    rax,[rbp-0x30]
    10be:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
   addressY = pi;
    10c1:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    10c5:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

   a = 5;
    10c8:	c7 45 d0 05 00 00 00    	mov    DWORD PTR [rbp-0x30],0x5
   b = *pi;
    10cf:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    10d3:	8b 00                   	mov    eax,DWORD PTR [rax]
    10d5:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

   pi++;
    10d8:	48 83 45 d8 04          	add    QWORD PTR [rbp-0x28],0x4
   *pi = 7;
    10dd:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    10e1:	c7 00 07 00 00 00       	mov    DWORD PTR [rax],0x7

   pi  = ar;
    10e7:	48 8d 45 ca             	lea    rax,[rbp-0x36]
    10eb:	48 89 45 d8             	mov    QWORD PTR [rbp-0x28],rax
   *pi = 1684234849;
    10ef:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    10f3:	c7 00 61 62 63 64       	mov    DWORD PTR [rax],0x64636261

   a   = 3;
    10f9:	c7 45 d0 03 00 00 00    	mov    DWORD PTR [rbp-0x30],0x3
   piA = &a;
    1100:	48 8d 45 d0             	lea    rax,[rbp-0x30]
    1104:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
   piB = &a;
    1108:	48 8d 45 d0             	lea    rax,[rbp-0x30]
    110c:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

   int c = 0;
    1110:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x0
   c = *piA;
    1117:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    111b:	8b 00                   	mov    eax,DWORD PTR [rax]
    111d:	89 45 d4                	mov    DWORD PTR [rbp-0x2c],eax
   c = *piB;
    1120:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1124:	8b 00                   	mov    eax,DWORD PTR [rax]
    1126:	89 45 d4                	mov    DWORD PTR [rbp-0x2c],eax

   c = 4;
    1129:	c7 45 d4 04 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x4
   *piB = c;
    1130:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1134:	8b 55 d4                	mov    edx,DWORD PTR [rbp-0x2c]
    1137:	89 10                   	mov    DWORD PTR [rax],edx
   c = a + *piA + *piB;
    1139:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    113d:	8b 10                   	mov    edx,DWORD PTR [rax]
    113f:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    1142:	01 c2                   	add    edx,eax
    1144:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1148:	8b 00                   	mov    eax,DWORD PTR [rax]
    114a:	01 d0                   	add    eax,edx
    114c:	89 45 d4                	mov    DWORD PTR [rbp-0x2c],eax

   char d[] = "efgh";
    114f:	c7 45 c5 65 66 67 68    	mov    DWORD PTR [rbp-0x3b],0x68676665
    1156:	c6 45 c9 00             	mov    BYTE PTR [rbp-0x37],0x0
   *pi = *(int*)d;
    115a:	48 8d 45 c5             	lea    rax,[rbp-0x3b]
    115e:	8b 10                   	mov    edx,DWORD PTR [rax]
    1160:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    1164:	89 10                   	mov    DWORD PTR [rax],edx

}//pointers1
    1166:	90                      	nop
    1167:	5d                      	pop    rbp
    1168:	c3                      	ret    

0000000000001169 <pointers2>:

//-----------------------------------------------------------------------------

void pointers2( void ) {
    1169:	55                      	push   rbp
    116a:	48 89 e5                	mov    rbp,rsp

   int a = 0;
    116d:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
   int b = 0;
    1174:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
   int c = 0;
    117b:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
   int d = 0;
    1182:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
   int e = 0;
    1189:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [rbp-0x10],0x0

   int* pi  = NULL;
    1190:	48 c7 45 e0 00 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0

   int arr[] = { 0, 0, 0, 0, 0 };
    1198:	c7 45 c0 00 00 00 00    	mov    DWORD PTR [rbp-0x40],0x0
    119f:	c7 45 c4 00 00 00 00    	mov    DWORD PTR [rbp-0x3c],0x0
    11a6:	c7 45 c8 00 00 00 00    	mov    DWORD PTR [rbp-0x38],0x0
    11ad:	c7 45 cc 00 00 00 00    	mov    DWORD PTR [rbp-0x34],0x0
    11b4:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0

   pi = &arr[0];
    11bb:	48 8d 45 c0             	lea    rax,[rbp-0x40]
    11bf:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   *pi = 15;
    11c3:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    11c7:	c7 00 0f 00 00 00       	mov    DWORD PTR [rax],0xf

   pi = pi + 1;
    11cd:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    11d1:	48 83 c0 04             	add    rax,0x4
    11d5:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   *pi = 20;
    11d9:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    11dd:	c7 00 14 00 00 00       	mov    DWORD PTR [rax],0x14

   pi += 1;
    11e3:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    11e7:	48 83 c0 04             	add    rax,0x4
    11eb:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   *pi = 25;
    11ef:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    11f3:	c7 00 19 00 00 00       	mov    DWORD PTR [rax],0x19

   pi++;
    11f9:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    11fd:	48 83 c0 04             	add    rax,0x4
    1201:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   *pi = 30;
    1205:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1209:	c7 00 1e 00 00 00       	mov    DWORD PTR [rax],0x1e

   *pi++ = 35;
    120f:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1213:	48 8d 50 04             	lea    rdx,[rax+0x4]
    1217:	48 89 55 e0             	mov    QWORD PTR [rbp-0x20],rdx
    121b:	c7 00 23 00 00 00       	mov    DWORD PTR [rax],0x23

   *pi = 40;
    1221:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1225:	c7 00 28 00 00 00       	mov    DWORD PTR [rax],0x28

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    122b:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0
    1232:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    1235:	89 45 cc                	mov    DWORD PTR [rbp-0x34],eax
    1238:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    123b:	89 45 c8                	mov    DWORD PTR [rbp-0x38],eax
    123e:	8b 45 c8                	mov    eax,DWORD PTR [rbp-0x38]
    1241:	89 45 c4                	mov    DWORD PTR [rbp-0x3c],eax
    1244:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    1247:	89 45 c0                	mov    DWORD PTR [rbp-0x40],eax

   pi = &arr[0];
    124a:	48 8d 45 c0             	lea    rax,[rbp-0x40]
    124e:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   *(pi + 0) = 2;
    1252:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1256:	c7 00 02 00 00 00       	mov    DWORD PTR [rax],0x2
   *(pi + 1) = 4;
    125c:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1260:	48 83 c0 04             	add    rax,0x4
    1264:	c7 00 04 00 00 00       	mov    DWORD PTR [rax],0x4
   *(pi + 2) = 6;
    126a:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    126e:	48 83 c0 08             	add    rax,0x8
    1272:	c7 00 06 00 00 00       	mov    DWORD PTR [rax],0x6
   *(pi + 3) = 8;
    1278:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    127c:	48 83 c0 0c             	add    rax,0xc
    1280:	c7 00 08 00 00 00       	mov    DWORD PTR [rax],0x8
   *(pi + 4) = 10;
    1286:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    128a:	48 83 c0 10             	add    rax,0x10
    128e:	c7 00 0a 00 00 00       	mov    DWORD PTR [rax],0xa

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    1294:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0
    129b:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    129e:	89 45 cc                	mov    DWORD PTR [rbp-0x34],eax
    12a1:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    12a4:	89 45 c8                	mov    DWORD PTR [rbp-0x38],eax
    12a7:	8b 45 c8                	mov    eax,DWORD PTR [rbp-0x38]
    12aa:	89 45 c4                	mov    DWORD PTR [rbp-0x3c],eax
    12ad:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    12b0:	89 45 c0                	mov    DWORD PTR [rbp-0x40],eax

   pi = &arr[0];
    12b3:	48 8d 45 c0             	lea    rax,[rbp-0x40]
    12b7:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   pi[0] = 3;
    12bb:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    12bf:	c7 00 03 00 00 00       	mov    DWORD PTR [rax],0x3
   pi[1] = 5;
    12c5:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    12c9:	48 83 c0 04             	add    rax,0x4
    12cd:	c7 00 05 00 00 00       	mov    DWORD PTR [rax],0x5
   pi[2] = 7;
    12d3:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    12d7:	48 83 c0 08             	add    rax,0x8
    12db:	c7 00 07 00 00 00       	mov    DWORD PTR [rax],0x7
   pi[3] = 9;
    12e1:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    12e5:	48 83 c0 0c             	add    rax,0xc
    12e9:	c7 00 09 00 00 00       	mov    DWORD PTR [rax],0x9
   pi[4] = 11;
    12ef:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    12f3:	48 83 c0 10             	add    rax,0x10
    12f7:	c7 00 0b 00 00 00       	mov    DWORD PTR [rax],0xb

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    12fd:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0
    1304:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    1307:	89 45 cc                	mov    DWORD PTR [rbp-0x34],eax
    130a:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    130d:	89 45 c8                	mov    DWORD PTR [rbp-0x38],eax
    1310:	8b 45 c8                	mov    eax,DWORD PTR [rbp-0x38]
    1313:	89 45 c4                	mov    DWORD PTR [rbp-0x3c],eax
    1316:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    1319:	89 45 c0                	mov    DWORD PTR [rbp-0x40],eax

   *arr = 111;
    131c:	c7 45 c0 6f 00 00 00    	mov    DWORD PTR [rbp-0x40],0x6f
   *(arr + 0) = 100;
    1323:	c7 45 c0 64 00 00 00    	mov    DWORD PTR [rbp-0x40],0x64
   *(arr + 1) = 200;
    132a:	c7 45 c4 c8 00 00 00    	mov    DWORD PTR [rbp-0x3c],0xc8
   *(arr + 2) = 300;
    1331:	c7 45 c8 2c 01 00 00    	mov    DWORD PTR [rbp-0x38],0x12c
   *(arr + 3) = 400;
    1338:	c7 45 cc 90 01 00 00    	mov    DWORD PTR [rbp-0x34],0x190
   *(arr + 4) = 500;
    133f:	c7 45 d0 f4 01 00 00    	mov    DWORD PTR [rbp-0x30],0x1f4


   pi = &arr[4];
    1346:	48 8d 45 c0             	lea    rax,[rbp-0x40]
    134a:	48 83 c0 10             	add    rax,0x10
    134e:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   pi[-4] = 10;
    1352:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1356:	48 83 e8 10             	sub    rax,0x10
    135a:	c7 00 0a 00 00 00       	mov    DWORD PTR [rax],0xa
   pi[-3] = 20;
    1360:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1364:	48 83 e8 0c             	sub    rax,0xc
    1368:	c7 00 14 00 00 00       	mov    DWORD PTR [rax],0x14
   pi[-2] = 30;
    136e:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1372:	48 83 e8 08             	sub    rax,0x8
    1376:	c7 00 1e 00 00 00       	mov    DWORD PTR [rax],0x1e
   pi[-1] = 40;
    137c:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1380:	48 83 e8 04             	sub    rax,0x4
    1384:	c7 00 28 00 00 00       	mov    DWORD PTR [rax],0x28
   pi[ 0] = 50;
    138a:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    138e:	c7 00 32 00 00 00       	mov    DWORD PTR [rax],0x32


   pi = &c;
    1394:	48 8d 45 ec             	lea    rax,[rbp-0x14]
    1398:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

   // !! danger
   *(pi - 1) = 22;
    139c:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    13a0:	48 83 e8 04             	sub    rax,0x4
    13a4:	c7 00 16 00 00 00       	mov    DWORD PTR [rax],0x16
   *(pi - 2) = 11;
    13aa:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    13ae:	48 83 e8 08             	sub    rax,0x8
    13b2:	c7 00 0b 00 00 00       	mov    DWORD PTR [rax],0xb

   *(pi + 1) = 44;
    13b8:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    13bc:	48 83 c0 04             	add    rax,0x4
    13c0:	c7 00 2c 00 00 00       	mov    DWORD PTR [rax],0x2c
   *(pi + 2) = 55;
    13c6:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    13ca:	48 83 c0 08             	add    rax,0x8
    13ce:	c7 00 37 00 00 00       	mov    DWORD PTR [rax],0x37

   *(pi + 3) = 66;
    13d4:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    13d8:	48 83 c0 0c             	add    rax,0xc
    13dc:	c7 00 42 00 00 00       	mov    DWORD PTR [rax],0x42
   *(pi + 4) = 77;
    13e2:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    13e6:	48 83 c0 10             	add    rax,0x10
    13ea:	c7 00 4d 00 00 00       	mov    DWORD PTR [rax],0x4d

   a = b = c = d = e;
    13f0:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    13f3:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
    13f6:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    13f9:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax
    13fc:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    13ff:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
    1402:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    1405:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

   pi = (int*)&pi;
    1408:	48 8d 45 e0             	lea    rax,[rbp-0x20]
    140c:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

   // !! danger
   pi[-1] = 8;
    1410:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1414:	48 83 e8 04             	sub    rax,0x4
    1418:	c7 00 08 00 00 00       	mov    DWORD PTR [rax],0x8
   pi[-2] = 7;
    141e:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1422:	48 83 e8 08             	sub    rax,0x8
    1426:	c7 00 07 00 00 00       	mov    DWORD PTR [rax],0x7
   pi[-3] = 6;
    142c:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    1430:	48 83 e8 0c             	sub    rax,0xc
    1434:	c7 00 06 00 00 00       	mov    DWORD PTR [rax],0x6
   pi[-4] = 5;
    143a:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    143e:	48 83 e8 10             	sub    rax,0x10
    1442:	c7 00 05 00 00 00       	mov    DWORD PTR [rax],0x5
   pi[-5] = 4;
    1448:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    144c:	48 83 e8 14             	sub    rax,0x14
    1450:	c7 00 04 00 00 00       	mov    DWORD PTR [rax],0x4

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
    1456:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0
    145d:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    1460:	89 45 cc                	mov    DWORD PTR [rbp-0x34],eax
    1463:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    1466:	89 45 c8                	mov    DWORD PTR [rbp-0x38],eax
    1469:	8b 45 c8                	mov    eax,DWORD PTR [rbp-0x38]
    146c:	89 45 c4                	mov    DWORD PTR [rbp-0x3c],eax
    146f:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    1472:	89 45 c0                	mov    DWORD PTR [rbp-0x40],eax

   0[arr] = 7;
    1475:	c7 45 c0 07 00 00 00    	mov    DWORD PTR [rbp-0x40],0x7
   1[arr] = 6;
    147c:	c7 45 c4 06 00 00 00    	mov    DWORD PTR [rbp-0x3c],0x6
   2[arr] = 5;
    1483:	c7 45 c8 05 00 00 00    	mov    DWORD PTR [rbp-0x38],0x5
   3[arr] = 4;
    148a:	c7 45 cc 04 00 00 00    	mov    DWORD PTR [rbp-0x34],0x4
   4[arr] = 2;
    1491:	c7 45 d0 02 00 00 00    	mov    DWORD PTR [rbp-0x30],0x2

   // http://www.youtube.com/watch?v=IJNR2EpS0jw
   *(pi + 5) = 88;
    1498:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    149c:	48 83 c0 14             	add    rax,0x14
    14a0:	c7 00 58 00 00 00       	mov    DWORD PTR [rax],0x58
   *(pi + 6) = 99;
    14a6:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    14aa:	48 83 c0 18             	add    rax,0x18
    14ae:	c7 00 63 00 00 00       	mov    DWORD PTR [rax],0x63

}//pointers2
    14b4:	90                      	nop
    14b5:	5d                      	pop    rbp
    14b6:	c3                      	ret    

00000000000014b7 <pointers3>:

//-----------------------------------------------------------------------------

void pointers3( void ) {
    14b7:	55                      	push   rbp
    14b8:	48 89 e5                	mov    rbp,rsp

	// see disassembly
	int    a =  3;
    14bb:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
	int   *b = &a;
    14c2:	48 8d 45 f4             	lea    rax,[rbp-0xc]
    14c6:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
	int  **c = &b;
    14ca:	48 8d 45 e8             	lea    rax,[rbp-0x18]
    14ce:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
	int ***d = &c;
    14d2:	48 8d 45 e0             	lea    rax,[rbp-0x20]
    14d6:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax

	   a = 2;
    14da:	c7 45 f4 02 00 00 00    	mov    DWORD PTR [rbp-0xc],0x2
	  *b = 3;
    14e1:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    14e5:	c7 00 03 00 00 00       	mov    DWORD PTR [rax],0x3
     **c = 4;
    14eb:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    14ef:	48 8b 00                	mov    rax,QWORD PTR [rax]
    14f2:	c7 00 04 00 00 00       	mov    DWORD PTR [rax],0x4
	***d = 5;
    14f8:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    14fc:	48 8b 00                	mov    rax,QWORD PTR [rax]
    14ff:	48 8b 00                	mov    rax,QWORD PTR [rax]
    1502:	c7 00 05 00 00 00       	mov    DWORD PTR [rax],0x5

}//pointers3
    1508:	90                      	nop
    1509:	5d                      	pop    rbp
    150a:	c3                      	ret    

000000000000150b <pointers4>:

//-----------------------------------------------------------------------------

void pointers4( void ) {
    150b:	55                      	push   rbp
    150c:	48 89 e5                	mov    rbp,rsp
    150f:	48 83 ec 28             	sub    rsp,0x28

   // see disassembly
   int arrI[ 5 ] = { 10, 20, 30, 40, 50 };
    1513:	c7 45 b0 0a 00 00 00    	mov    DWORD PTR [rbp-0x50],0xa
    151a:	c7 45 b4 14 00 00 00    	mov    DWORD PTR [rbp-0x4c],0x14
    1521:	c7 45 b8 1e 00 00 00    	mov    DWORD PTR [rbp-0x48],0x1e
    1528:	c7 45 bc 28 00 00 00    	mov    DWORD PTR [rbp-0x44],0x28
    152f:	c7 45 c0 32 00 00 00    	mov    DWORD PTR [rbp-0x40],0x32

   int *piA = NULL;
    1536:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
   int *piB = NULL;
    153e:	48 c7 45 f0 00 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0

   long double arrLD[ 5 ] = { .10L, .20L, .30L, .40L, .50L };
    1546:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 154c <pointers4+0x41>
    154c:	db bd 60 ff ff ff       	fstp   TBYTE PTR [rbp-0xa0]
    1552:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 1558 <pointers4+0x4d>
    1558:	db bd 70 ff ff ff       	fstp   TBYTE PTR [rbp-0x90]
    155e:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 1564 <pointers4+0x59>
    1564:	db 7d 80                	fstp   TBYTE PTR [rbp-0x80]
    1567:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 156d <pointers4+0x62>
    156d:	db 7d 90                	fstp   TBYTE PTR [rbp-0x70]
    1570:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 1576 <pointers4+0x6b>
    1576:	db 7d a0                	fstp   TBYTE PTR [rbp-0x60]

   long double *pldA = NULL;
    1579:	48 c7 45 e8 00 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
   long double *pldB = NULL;
    1581:	48 c7 45 e0 00 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0

   size_t        size = 0;
    1589:	48 c7 45 d8 00 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
   ptrdiff_t distance = 0;
    1591:	48 c7 45 d0 00 00 00 00 	mov    QWORD PTR [rbp-0x30],0x0

   piA = &arrI[ 0 ];
    1599:	48 8d 45 b0             	lea    rax,[rbp-0x50]
    159d:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
   piB = &arrI[ 1 ];
    15a1:	48 8d 45 b0             	lea    rax,[rbp-0x50]
    15a5:	48 83 c0 04             	add    rax,0x4
    15a9:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

   size = sizeof( int );
    15ad:	48 c7 45 d8 04 00 00 00 	mov    QWORD PTR [rbp-0x28],0x4
   distance = piA - piB;
    15b5:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    15b9:	48 2b 45 f0             	sub    rax,QWORD PTR [rbp-0x10]
    15bd:	48 c1 f8 02             	sar    rax,0x2
    15c1:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax


   pldA = &arrLD[ 0 ];
    15c5:	48 8d 85 60 ff ff ff    	lea    rax,[rbp-0xa0]
    15cc:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
   pldB = &arrLD[ 1 ];
    15d0:	48 8d 85 60 ff ff ff    	lea    rax,[rbp-0xa0]
    15d7:	48 83 c0 10             	add    rax,0x10
    15db:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

   size = sizeof( long double );
    15df:	48 c7 45 d8 10 00 00 00 	mov    QWORD PTR [rbp-0x28],0x10
   distance = pldA - pldB;
    15e7:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    15eb:	48 2b 45 e0             	sub    rax,QWORD PTR [rbp-0x20]
    15ef:	48 c1 f8 04             	sar    rax,0x4
    15f3:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax

}//pointers4
    15f7:	90                      	nop
    15f8:	c9                      	leave  
    15f9:	c3                      	ret    

00000000000015fa <pointers5>:

//-----------------------------------------------------------------------------

void pointers5( void ) {
    15fa:	55                      	push   rbp
    15fb:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int arr[ 5 ] = { 10, 20, 30, 40, 50 };
    15fe:	c7 45 e0 0a 00 00 00    	mov    DWORD PTR [rbp-0x20],0xa
    1605:	c7 45 e4 14 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x14
    160c:	c7 45 e8 1e 00 00 00    	mov    DWORD PTR [rbp-0x18],0x1e
    1613:	c7 45 ec 28 00 00 00    	mov    DWORD PTR [rbp-0x14],0x28
    161a:	c7 45 f0 32 00 00 00    	mov    DWORD PTR [rbp-0x10],0x32

   int *pi = NULL;
    1621:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0

   pi = arr;
    1629:	48 8d 45 e0             	lea    rax,[rbp-0x20]
    162d:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax

   arr[ 0 ]   = 11;
    1631:	c7 45 e0 0b 00 00 00    	mov    DWORD PTR [rbp-0x20],0xb
   *(arr + 0) = 12;
    1638:	c7 45 e0 0c 00 00 00    	mov    DWORD PTR [rbp-0x20],0xc
   pi[ 0 ]    = 13;
    163f:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1643:	c7 00 0d 00 00 00       	mov    DWORD PTR [rax],0xd
   *(pi + 0)  = 14;
    1649:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    164d:	c7 00 0e 00 00 00       	mov    DWORD PTR [rax],0xe

   arr[ 1 ]   = 22;
    1653:	c7 45 e4 16 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x16
   *(arr + 1) = 23;
    165a:	c7 45 e4 17 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x17
   pi[ 1 ]    = 24;
    1661:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1665:	48 83 c0 04             	add    rax,0x4
    1669:	c7 00 18 00 00 00       	mov    DWORD PTR [rax],0x18
   *(pi + 1)  = 25;
    166f:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1673:	48 83 c0 04             	add    rax,0x4
    1677:	c7 00 19 00 00 00       	mov    DWORD PTR [rax],0x19

   arr[ 2 ]   = 33;
    167d:	c7 45 e8 21 00 00 00    	mov    DWORD PTR [rbp-0x18],0x21
   *(arr + 2) = 34;
    1684:	c7 45 e8 22 00 00 00    	mov    DWORD PTR [rbp-0x18],0x22
   pi[ 2 ]    = 35;
    168b:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    168f:	48 83 c0 08             	add    rax,0x8
    1693:	c7 00 23 00 00 00       	mov    DWORD PTR [rax],0x23
   *(pi + 2)  = 36;
    1699:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    169d:	48 83 c0 08             	add    rax,0x8
    16a1:	c7 00 24 00 00 00       	mov    DWORD PTR [rax],0x24

   arr[ 3 ]   = 44;
    16a7:	c7 45 ec 2c 00 00 00    	mov    DWORD PTR [rbp-0x14],0x2c
   *(arr + 3) = 45;
    16ae:	c7 45 ec 2d 00 00 00    	mov    DWORD PTR [rbp-0x14],0x2d
   pi[ 3 ]    = 46;
    16b5:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    16b9:	48 83 c0 0c             	add    rax,0xc
    16bd:	c7 00 2e 00 00 00       	mov    DWORD PTR [rax],0x2e
   *(pi + 3)  = 47;
    16c3:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    16c7:	48 83 c0 0c             	add    rax,0xc
    16cb:	c7 00 2f 00 00 00       	mov    DWORD PTR [rax],0x2f

   arr[ 4 ]   = 55;
    16d1:	c7 45 f0 37 00 00 00    	mov    DWORD PTR [rbp-0x10],0x37
   *(arr + 4) = 56;
    16d8:	c7 45 f0 38 00 00 00    	mov    DWORD PTR [rbp-0x10],0x38
   pi[ 4 ]    = 57;
    16df:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    16e3:	48 83 c0 10             	add    rax,0x10
    16e7:	c7 00 39 00 00 00       	mov    DWORD PTR [rax],0x39
   *(pi + 4)  = 58;
    16ed:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    16f1:	48 83 c0 10             	add    rax,0x10
    16f5:	c7 00 3a 00 00 00       	mov    DWORD PTR [rax],0x3a

}//pointers5
    16fb:	90                      	nop
    16fc:	5d                      	pop    rbp
    16fd:	c3                      	ret    

00000000000016fe <pointers6>:

//-----------------------------------------------------------------------------

void pointers6( void ) {
    16fe:	55                      	push   rbp
    16ff:	48 89 e5                	mov    rbp,rsp
    1702:	48 83 ec 10             	sub    rsp,0x10

   // see disassembly
   int *arr = NULL;
    1706:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0

   arr = malloc( 5 * sizeof(int) );
    170e:	bf 14 00 00 00          	mov    edi,0x14
    1713:	e8 00 00 00 00          	call   1718 <pointers6+0x1a>
    1718:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax

   arr[ 0 ]   = 11;
    171c:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1720:	c7 00 0b 00 00 00       	mov    DWORD PTR [rax],0xb
   *(arr + 0) = 12;
    1726:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    172a:	c7 00 0c 00 00 00       	mov    DWORD PTR [rax],0xc

   arr[ 1 ]   = 22;
    1730:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1734:	48 83 c0 04             	add    rax,0x4
    1738:	c7 00 16 00 00 00       	mov    DWORD PTR [rax],0x16
   *(arr + 1) = 23;
    173e:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1742:	48 83 c0 04             	add    rax,0x4
    1746:	c7 00 17 00 00 00       	mov    DWORD PTR [rax],0x17

   arr[ 2 ]   = 33;
    174c:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1750:	48 83 c0 08             	add    rax,0x8
    1754:	c7 00 21 00 00 00       	mov    DWORD PTR [rax],0x21
   *(arr + 2) = 34;
    175a:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    175e:	48 83 c0 08             	add    rax,0x8
    1762:	c7 00 22 00 00 00       	mov    DWORD PTR [rax],0x22

   arr[ 3 ]   = 44;
    1768:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    176c:	48 83 c0 0c             	add    rax,0xc
    1770:	c7 00 2c 00 00 00       	mov    DWORD PTR [rax],0x2c
   *(arr + 3) = 45;
    1776:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    177a:	48 83 c0 0c             	add    rax,0xc
    177e:	c7 00 2d 00 00 00       	mov    DWORD PTR [rax],0x2d

   arr[ 4 ]   = 55;
    1784:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1788:	48 83 c0 10             	add    rax,0x10
    178c:	c7 00 37 00 00 00       	mov    DWORD PTR [rax],0x37
   *(arr + 4) = 56;
    1792:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    1796:	48 83 c0 10             	add    rax,0x10
    179a:	c7 00 38 00 00 00       	mov    DWORD PTR [rax],0x38

   free( arr );
    17a0:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    17a4:	48 89 c7                	mov    rdi,rax
    17a7:	e8 00 00 00 00          	call   17ac <pointers6+0xae>

}//pointers6
    17ac:	90                      	nop
    17ad:	c9                      	leave  
    17ae:	c3                      	ret    

00000000000017af <pointersConstantPointers>:

//-----------------------------------------------------------------------------

void pointersConstantPointers( void ) {
    17af:	55                      	push   rbp
    17b0:	48 89 e5                	mov    rbp,rsp

   int a = 0;
    17b3:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [rbp-0x24],0x0
   int b = 0;
    17ba:	c7 45 d8 00 00 00 00    	mov    DWORD PTR [rbp-0x28],0x0

   // both same
   const int *pcA;
   int const *pcB;

   int *const cpi = &a;
    17c1:	48 8d 45 dc             	lea    rax,[rbp-0x24]
    17c5:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax

   const int *const cpci = &a;
    17c9:	48 8d 45 dc             	lea    rax,[rbp-0x24]
    17cd:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

   pcA = &a;
    17d1:	48 8d 45 dc             	lea    rax,[rbp-0x24]
    17d5:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
   pcB = &b;
    17d9:	48 8d 45 d8             	lea    rax,[rbp-0x28]
    17dd:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax
   // *pcA = 3; // error
   // *pcB = 5; // error

   // cpi = &b; // error

}//pointersConstantPointers
    17e1:	90                      	nop
    17e2:	5d                      	pop    rbp
    17e3:	c3                      	ret    

00000000000017e4 <arrays>:

//-----------------------------------------------------------------------------

void arrays( void ) {
    17e4:	55                      	push   rbp
    17e5:	48 89 e5                	mov    rbp,rsp
    17e8:	48 83 ec 78             	sub    rsp,0x78
   int arrA3[] = {};
   int arrB[ 0 ];
   int arrC[ 5 ];


   char lettersA[] = { 65, 66, 67, 68, 69 };
    17ec:	c7 45 db 41 42 43 44    	mov    DWORD PTR [rbp-0x25],0x44434241
    17f3:	c6 45 df 45             	mov    BYTE PTR [rbp-0x21],0x45
   char lettersB[] = { 'A','B','C','D','E' };
    17f7:	c7 45 d6 41 42 43 44    	mov    DWORD PTR [rbp-0x2a],0x44434241
    17fe:	c6 45 da 45             	mov    BYTE PTR [rbp-0x26],0x45

   char stringA[] = { 'A','B','C','D','E', 0 };
    1802:	c7 45 d0 41 42 43 44    	mov    DWORD PTR [rbp-0x30],0x44434241
    1809:	66 c7 45 d4 45 00       	mov    WORD PTR [rbp-0x2c],0x45
   char stringB[] = { 'A','B','C','D','E', '\0' };
    180f:	c7 45 ca 41 42 43 44    	mov    DWORD PTR [rbp-0x36],0x44434241
    1816:	66 c7 45 ce 45 00       	mov    WORD PTR [rbp-0x32],0x45
   char stringC[] = { "ABCDE" };
    181c:	c7 45 c4 41 42 43 44    	mov    DWORD PTR [rbp-0x3c],0x44434241
    1823:	66 c7 45 c8 45 00       	mov    WORD PTR [rbp-0x38],0x45

   wchar_t unicodeA[] = { L'Ğ', L'Ü', L'Ş', L'İ', L'Ö', L'Ç', 0 };
    1829:	c7 45 a0 1e 01 00 00    	mov    DWORD PTR [rbp-0x60],0x11e
    1830:	c7 45 a4 dc 00 00 00    	mov    DWORD PTR [rbp-0x5c],0xdc
    1837:	c7 45 a8 5e 01 00 00    	mov    DWORD PTR [rbp-0x58],0x15e
    183e:	c7 45 ac 30 01 00 00    	mov    DWORD PTR [rbp-0x54],0x130
    1845:	c7 45 b0 d6 00 00 00    	mov    DWORD PTR [rbp-0x50],0xd6
    184c:	c7 45 b4 c7 00 00 00    	mov    DWORD PTR [rbp-0x4c],0xc7
    1853:	c7 45 b8 00 00 00 00    	mov    DWORD PTR [rbp-0x48],0x0
   wchar_t unicodeB[] = L"ĞÜŞİÖÇ";
    185a:	48 b8 1e 01 00 00 dc 00 	movabs rax,0xdc0000011e
    1862:	00 00 
    1864:	48 ba 5e 01 00 00 30 01 	movabs rdx,0x1300000015e
    186c:	00 00 
    186e:	48 89 45 80             	mov    QWORD PTR [rbp-0x80],rax
    1872:	48 89 55 88             	mov    QWORD PTR [rbp-0x78],rdx
    1876:	48 b8 d6 00 00 00 c7 00 	movabs rax,0xc7000000d6
    187e:	00 00 
    1880:	48 89 45 90             	mov    QWORD PTR [rbp-0x70],rax
    1884:	c7 45 98 00 00 00 00    	mov    DWORD PTR [rbp-0x68],0x0

   int arrQ[ 2 ] = { 1, 2, 3 }; // initialize the first 2, discard the 3rd.
    188b:	c7 85 78 ff ff ff 01 00 	mov    DWORD PTR [rbp-0x88],0x1
    1893:	00 00 
    1895:	c7 85 7c ff ff ff 02 00 	mov    DWORD PTR [rbp-0x84],0x2
    189d:	00 00 
   int arrW[ 3 ] = { 1, 2, 3 }; // initialize all.
    189f:	c7 85 6c ff ff ff 01 00 	mov    DWORD PTR [rbp-0x94],0x1
    18a7:	00 00 
    18a9:	c7 85 70 ff ff ff 02 00 	mov    DWORD PTR [rbp-0x90],0x2
    18b1:	00 00 
    18b3:	c7 85 74 ff ff ff 03 00 	mov    DWORD PTR [rbp-0x8c],0x3
    18bb:	00 00 
   int arrX[ 4 ] = { 1, 2, 3 }; // initialize the first 3, leave 4th uninitialized.
    18bd:	48 c7 85 50 ff ff ff 00 	mov    QWORD PTR [rbp-0xb0],0x0
    18c5:	00 00 00 
    18c8:	48 c7 85 58 ff ff ff 00 	mov    QWORD PTR [rbp-0xa8],0x0
    18d0:	00 00 00 
    18d3:	c7 85 50 ff ff ff 01 00 	mov    DWORD PTR [rbp-0xb0],0x1
    18db:	00 00 
    18dd:	c7 85 54 ff ff ff 02 00 	mov    DWORD PTR [rbp-0xac],0x2
    18e5:	00 00 
    18e7:	c7 85 58 ff ff ff 03 00 	mov    DWORD PTR [rbp-0xa8],0x3
    18ef:	00 00 
   int arrY[ 5 ] = { [2] = 30 };// initialize the 3rd. initialize the rest with zero.
    18f1:	48 c7 85 30 ff ff ff 00 	mov    QWORD PTR [rbp-0xd0],0x0
    18f9:	00 00 00 
    18fc:	48 c7 85 38 ff ff ff 00 	mov    QWORD PTR [rbp-0xc8],0x0
    1904:	00 00 00 
    1907:	c7 85 40 ff ff ff 00 00 	mov    DWORD PTR [rbp-0xc0],0x0
    190f:	00 00 
    1911:	c7 85 38 ff ff ff 1e 00 	mov    DWORD PTR [rbp-0xc8],0x1e
    1919:	00 00 
   int arrZ[ 5 ] = {};          // initialize all with zero.
    191b:	48 c7 85 10 ff ff ff 00 	mov    QWORD PTR [rbp-0xf0],0x0
    1923:	00 00 00 
    1926:	48 c7 85 18 ff ff ff 00 	mov    QWORD PTR [rbp-0xe8],0x0
    192e:	00 00 00 
    1931:	c7 85 20 ff ff ff 00 00 	mov    DWORD PTR [rbp-0xe0],0x0
    1939:	00 00 

   size_t size = 0;
    193b:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
   int count   = 0;
    1943:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   size = sizeof( arrA1 );
    194a:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
   size = sizeof( arrB );
    1952:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0

   size  = sizeof( arrC );
    195a:	48 c7 45 f8 14 00 00 00 	mov    QWORD PTR [rbp-0x8],0x14
   size  = sizeof arrC;
    1962:	48 c7 45 f8 14 00 00 00 	mov    QWORD PTR [rbp-0x8],0x14
   count = sizeof( arrC ) / sizeof( int );
    196a:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [rbp-0xc],0x5

   size = sizeof( lettersA );
    1971:	48 c7 45 f8 05 00 00 00 	mov    QWORD PTR [rbp-0x8],0x5
   size = sizeof( lettersB );
    1979:	48 c7 45 f8 05 00 00 00 	mov    QWORD PTR [rbp-0x8],0x5

   size = sizeof( stringA );
    1981:	48 c7 45 f8 06 00 00 00 	mov    QWORD PTR [rbp-0x8],0x6
   size = sizeof( stringB );
    1989:	48 c7 45 f8 06 00 00 00 	mov    QWORD PTR [rbp-0x8],0x6
   size = sizeof( stringC );
    1991:	48 c7 45 f8 06 00 00 00 	mov    QWORD PTR [rbp-0x8],0x6

   size = sizeof( wchar_t );
    1999:	48 c7 45 f8 04 00 00 00 	mov    QWORD PTR [rbp-0x8],0x4
   size = sizeof( unicodeA );
    19a1:	48 c7 45 f8 1c 00 00 00 	mov    QWORD PTR [rbp-0x8],0x1c

   size  = sizeof( unicodeB );
    19a9:	48 c7 45 f8 1c 00 00 00 	mov    QWORD PTR [rbp-0x8],0x1c
   count = sizeof( unicodeB ) / sizeof( wchar_t );
    19b1:	c7 45 f4 07 00 00 00    	mov    DWORD PTR [rbp-0xc],0x7

   size = sizeof( arrW );
    19b8:	48 c7 45 f8 0c 00 00 00 	mov    QWORD PTR [rbp-0x8],0xc
   size = sizeof( arrX );
    19c0:	48 c7 45 f8 10 00 00 00 	mov    QWORD PTR [rbp-0x8],0x10
   size = sizeof( arrY );
    19c8:	48 c7 45 f8 14 00 00 00 	mov    QWORD PTR [rbp-0x8],0x14

   size = sizeof stringB;
    19d0:	48 c7 45 f8 06 00 00 00 	mov    QWORD PTR [rbp-0x8],0x6
   size = sizeof( arrX );
    19d8:	48 c7 45 f8 10 00 00 00 	mov    QWORD PTR [rbp-0x8],0x10
   size = sizeof( arrY );
    19e0:	48 c7 45 f8 14 00 00 00 	mov    QWORD PTR [rbp-0x8],0x14

   size  = sizeof( arrC );
    19e8:	48 c7 45 f8 14 00 00 00 	mov    QWORD PTR [rbp-0x8],0x14
   size  = sizeof arrC;
    19f0:	48 c7 45 f8 14 00 00 00 	mov    QWORD PTR [rbp-0x8],0x14


   arrA1[ 0 ] = 1;
    19f8:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1
   arrA2[ 0 ] = 2;
    19ff:	c7 45 f4 02 00 00 00    	mov    DWORD PTR [rbp-0xc],0x2
   arrA3[ 0 ] = 3;
    1a06:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
   arrB[ 0 ]  = 1;
    1a0d:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1

   arrC[ 0 ] = 10;
    1a14:	c7 45 e0 0a 00 00 00    	mov    DWORD PTR [rbp-0x20],0xa
   arrC[ 1 ] = 20;
    1a1b:	c7 45 e4 14 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x14

   stringC[0] = 'F';
    1a22:	c6 45 c4 46             	mov    BYTE PTR [rbp-0x3c],0x46

}//arrays
    1a26:	90                      	nop
    1a27:	c9                      	leave  
    1a28:	c3                      	ret    

0000000000001a29 <everyIdentifierHasAnAddress>:

//-----------------------------------------------------------------------------

void everyIdentifierHasAnAddress( void ) {
    1a29:	55                      	push   rbp
    1a2a:	48 89 e5                	mov    rbp,rsp

   int a = 2;
    1a2d:	c7 45 e8 02 00 00 00    	mov    DWORD PTR [rbp-0x18],0x2
   int b = 3;
    1a34:	c7 45 e4 03 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x3
   int c = 0;
    1a3b:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0

   int size = sizeof( int );
    1a42:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [rbp-0x8],0x4
   size = sizeof( c );
    1a49:	c7 45 f8 04 00 00 00    	mov    DWORD PTR [rbp-0x8],0x4

   int arrA[] = { 10, 20, 30, 40, 50 };
    1a50:	c7 45 d0 0a 00 00 00    	mov    DWORD PTR [rbp-0x30],0xa
    1a57:	c7 45 d4 14 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x14
    1a5e:	c7 45 d8 1e 00 00 00    	mov    DWORD PTR [rbp-0x28],0x1e
    1a65:	c7 45 dc 28 00 00 00    	mov    DWORD PTR [rbp-0x24],0x28
    1a6c:	c7 45 e0 32 00 00 00    	mov    DWORD PTR [rbp-0x20],0x32
   int arrB[] = { 10, 20, 30, 40, 50 };
    1a73:	c7 45 b0 0a 00 00 00    	mov    DWORD PTR [rbp-0x50],0xa
    1a7a:	c7 45 b4 14 00 00 00    	mov    DWORD PTR [rbp-0x4c],0x14
    1a81:	c7 45 b8 1e 00 00 00    	mov    DWORD PTR [rbp-0x48],0x1e
    1a88:	c7 45 bc 28 00 00 00    	mov    DWORD PTR [rbp-0x44],0x28
    1a8f:	c7 45 c0 32 00 00 00    	mov    DWORD PTR [rbp-0x40],0x32
   int arrC[] = { 10, 20, 30, 40, 50 };
    1a96:	c7 45 90 0a 00 00 00    	mov    DWORD PTR [rbp-0x70],0xa
    1a9d:	c7 45 94 14 00 00 00    	mov    DWORD PTR [rbp-0x6c],0x14
    1aa4:	c7 45 98 1e 00 00 00    	mov    DWORD PTR [rbp-0x68],0x1e
    1aab:	c7 45 9c 28 00 00 00    	mov    DWORD PTR [rbp-0x64],0x28
    1ab2:	c7 45 a0 32 00 00 00    	mov    DWORD PTR [rbp-0x60],0x32

   int *arrD  = { 10, 20, 30, 40, 50 };// !!
    1ab9:	48 c7 45 f0 0a 00 00 00 	mov    QWORD PTR [rbp-0x10],0xa

   size = sizeof( arrC );
    1ac1:	c7 45 f8 14 00 00 00    	mov    DWORD PTR [rbp-0x8],0x14
   size = sizeof( arrD );
    1ac8:	c7 45 f8 08 00 00 00    	mov    DWORD PTR [rbp-0x8],0x8

   int i = 2;
    1acf:	c7 45 ec 02 00 00 00    	mov    DWORD PTR [rbp-0x14],0x2
   c = arrA[ i ];
    1ad6:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    1ad9:	48 98                   	cdqe   
    1adb:	8b 44 85 d0             	mov    eax,DWORD PTR [rbp+rax*4-0x30]
    1adf:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   c = arrA[ 2 ];
    1ae2:	8b 45 d8                	mov    eax,DWORD PTR [rbp-0x28]
    1ae5:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   c = i[ arrA ];
    1ae8:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    1aeb:	48 98                   	cdqe   
    1aed:	8b 44 85 d0             	mov    eax,DWORD PTR [rbp+rax*4-0x30]
    1af1:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   c = 2[ arrA ];
    1af4:	8b 45 d8                	mov    eax,DWORD PTR [rbp-0x28]
    1af7:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

   c = arrA[ 0 ];
    1afa:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    1afd:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   c = arrD[ 0 ];
    1b00:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    1b04:	8b 00                   	mov    eax,DWORD PTR [rax]
    1b06:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

   c = arrA[ 2 ];
    1b09:	8b 45 d8                	mov    eax,DWORD PTR [rbp-0x28]
    1b0c:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   //c = arrD[ 2 ];//!!

   c = arrays - everyIdentifierHasAnAddress;
    1b0f:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1b16 <everyIdentifierHasAnAddress+0xed>
    1b16:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 1b1d <everyIdentifierHasAnAddress+0xf4>
    1b1d:	48 29 d0                	sub    rax,rdx
    1b20:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   c = &b - &a;
    1b23:	48 8d 45 e4             	lea    rax,[rbp-0x1c]
    1b27:	48 8d 55 e8             	lea    rdx,[rbp-0x18]
    1b2b:	48 29 d0                	sub    rax,rdx
    1b2e:	48 c1 f8 02             	sar    rax,0x2
    1b32:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   c = (void*)&b - (void*)&a;
    1b35:	48 8d 45 e4             	lea    rax,[rbp-0x1c]
    1b39:	48 8d 55 e8             	lea    rdx,[rbp-0x18]
    1b3d:	48 29 d0                	sub    rax,rdx
    1b40:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

}//everyIdentifierHasAnAddress
    1b43:	90                      	nop
    1b44:	5d                      	pop    rbp
    1b45:	c3                      	ret    

0000000000001b46 <controlFlow_if>:

//-----------------------------------------------------------------------------

void controlFlow_if() {
    1b46:	55                      	push   rbp
    1b47:	48 89 e5                	mov    rbp,rsp

   int a = 2;
    1b4a:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
   int b = 3;
    1b51:	c7 45 f8 03 00 00 00    	mov    DWORD PTR [rbp-0x8],0x3
   int c = 0;
    1b58:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   _Bool result = a < b;
    1b5f:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1b62:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
    1b65:	0f 9c c0                	setl   al
    1b68:	88 45 f3                	mov    BYTE PTR [rbp-0xd],al

   if ( result )
    1b6b:	80 7d f3 00             	cmp    BYTE PTR [rbp-0xd],0x0
    1b6f:	74 09                   	je     1b7a <controlFlow_if+0x34>
      c = 1;
    1b71:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1
    1b78:	eb 07                   	jmp    1b81 <controlFlow_if+0x3b>
   else
	  c = 0;
    1b7a:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   if ( a < b )
    1b81:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1b84:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
    1b87:	7d 09                   	jge    1b92 <controlFlow_if+0x4c>
      c = 1;
    1b89:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1
    1b90:	eb 07                   	jmp    1b99 <controlFlow_if+0x53>
   else
	  c = 0;
    1b92:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   if ( !(a < b) )
    1b99:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1b9c:	3b 45 f8                	cmp    eax,DWORD PTR [rbp-0x8]
    1b9f:	7c 07                   	jl     1ba8 <controlFlow_if+0x62>
      c = 0;
    1ba1:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0


   enum { colder, cold, warm, hot, hotter } climate = colder;
    1ba8:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0

   c = 18;
    1baf:	c7 45 f4 12 00 00 00    	mov    DWORD PTR [rbp-0xc],0x12

   // if ladder
   if ( c <= -10 ) {
    1bb6:	83 7d f4 f7             	cmp    DWORD PTR [rbp-0xc],0xfffffff7
    1bba:	7d 09                   	jge    1bc5 <controlFlow_if+0x7f>

	  climate = colder;
    1bbc:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
    1bc3:	eb 46                   	jmp    1c0b <controlFlow_if+0xc5>

   } else if ( ( c > -10 ) && ( c <= 10 ) ) {
    1bc5:	83 7d f4 f7             	cmp    DWORD PTR [rbp-0xc],0xfffffff7
    1bc9:	7c 0f                   	jl     1bda <controlFlow_if+0x94>
    1bcb:	83 7d f4 0a             	cmp    DWORD PTR [rbp-0xc],0xa
    1bcf:	7f 09                   	jg     1bda <controlFlow_if+0x94>

	   climate = cold;
    1bd1:	c7 45 ec 01 00 00 00    	mov    DWORD PTR [rbp-0x14],0x1
    1bd8:	eb 31                   	jmp    1c0b <controlFlow_if+0xc5>

   } else if ( ( c >  10 ) && ( c <= 25 ) ) {
    1bda:	83 7d f4 0a             	cmp    DWORD PTR [rbp-0xc],0xa
    1bde:	7e 0f                   	jle    1bef <controlFlow_if+0xa9>
    1be0:	83 7d f4 19             	cmp    DWORD PTR [rbp-0xc],0x19
    1be4:	7f 09                   	jg     1bef <controlFlow_if+0xa9>

	   climate = warm;
    1be6:	c7 45 ec 02 00 00 00    	mov    DWORD PTR [rbp-0x14],0x2
    1bed:	eb 1c                   	jmp    1c0b <controlFlow_if+0xc5>

   } else if ( ( c >  25 ) && ( c <= 35 ) ) {
    1bef:	83 7d f4 19             	cmp    DWORD PTR [rbp-0xc],0x19
    1bf3:	7e 0f                   	jle    1c04 <controlFlow_if+0xbe>
    1bf5:	83 7d f4 23             	cmp    DWORD PTR [rbp-0xc],0x23
    1bf9:	7f 09                   	jg     1c04 <controlFlow_if+0xbe>

	   climate = hot;
    1bfb:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
    1c02:	eb 07                   	jmp    1c0b <controlFlow_if+0xc5>

   } else {

	   climate = hotter;
    1c04:	c7 45 ec 04 00 00 00    	mov    DWORD PTR [rbp-0x14],0x4

   }//if

   // if-ladder switch case alternative
   climate = ( c <= -10 ) ? colder :
    1c0b:	83 7d f4 f7             	cmp    DWORD PTR [rbp-0xc],0xfffffff7
    1c0f:	7c 40                   	jl     1c51 <controlFlow_if+0x10b>
    1c11:	83 7d f4 f7             	cmp    DWORD PTR [rbp-0xc],0xfffffff7
    1c15:	7c 06                   	jl     1c1d <controlFlow_if+0xd7>
             ( c > -10 ) && ( c <= 10 ) ? cold :
    1c17:	83 7d f4 0a             	cmp    DWORD PTR [rbp-0xc],0xa
    1c1b:	7e 2d                   	jle    1c4a <controlFlow_if+0x104>
   climate = ( c <= -10 ) ? colder :
    1c1d:	83 7d f4 0a             	cmp    DWORD PTR [rbp-0xc],0xa
    1c21:	7e 06                   	jle    1c29 <controlFlow_if+0xe3>
             ( c >  10 ) && ( c <= 25 ) ? warm :
    1c23:	83 7d f4 19             	cmp    DWORD PTR [rbp-0xc],0x19
    1c27:	7e 1a                   	jle    1c43 <controlFlow_if+0xfd>
   climate = ( c <= -10 ) ? colder :
    1c29:	83 7d f4 19             	cmp    DWORD PTR [rbp-0xc],0x19
    1c2d:	7e 0d                   	jle    1c3c <controlFlow_if+0xf6>
             ( c >  25 ) && ( c <= 35 ) ? hot  :
    1c2f:	83 7d f4 23             	cmp    DWORD PTR [rbp-0xc],0x23
    1c33:	7f 07                   	jg     1c3c <controlFlow_if+0xf6>
   climate = ( c <= -10 ) ? colder :
    1c35:	b8 03 00 00 00          	mov    eax,0x3
    1c3a:	eb 1a                   	jmp    1c56 <controlFlow_if+0x110>
    1c3c:	b8 04 00 00 00          	mov    eax,0x4
    1c41:	eb 13                   	jmp    1c56 <controlFlow_if+0x110>
    1c43:	b8 02 00 00 00          	mov    eax,0x2
    1c48:	eb 0c                   	jmp    1c56 <controlFlow_if+0x110>
    1c4a:	b8 01 00 00 00          	mov    eax,0x1
    1c4f:	eb 05                   	jmp    1c56 <controlFlow_if+0x110>
    1c51:	b8 00 00 00 00          	mov    eax,0x0
    1c56:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax
             hotter;


}//controlFlow_if
    1c59:	90                      	nop
    1c5a:	5d                      	pop    rbp
    1c5b:	c3                      	ret    

0000000000001c5c <controlFlow_Switch>:

//-----------------------------------------------------------------------------

void controlFlow_Switch() {
    1c5c:	55                      	push   rbp
    1c5d:	48 89 e5                	mov    rbp,rsp

   int  value = 3;
    1c60:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [rbp-0x4],0x3
   char rating = 'X';
    1c67:	c6 45 fb 58             	mov    BYTE PTR [rbp-0x5],0x58

   // fall-through switch
   switch( value ) {
    1c6b:	83 7d fc 0a             	cmp    DWORD PTR [rbp-0x4],0xa
    1c6f:	7f 45                   	jg     1cb6 <controlFlow_Switch+0x5a>
    1c71:	83 7d fc 09             	cmp    DWORD PTR [rbp-0x4],0x9
    1c75:	7d 39                   	jge    1cb0 <controlFlow_Switch+0x54>
    1c77:	83 7d fc 08             	cmp    DWORD PTR [rbp-0x4],0x8
    1c7b:	7f 39                   	jg     1cb6 <controlFlow_Switch+0x5a>
    1c7d:	83 7d fc 06             	cmp    DWORD PTR [rbp-0x4],0x6
    1c81:	7d 27                   	jge    1caa <controlFlow_Switch+0x4e>
    1c83:	83 7d fc 02             	cmp    DWORD PTR [rbp-0x4],0x2
    1c87:	7f 08                   	jg     1c91 <controlFlow_Switch+0x35>
    1c89:	83 7d fc 00             	cmp    DWORD PTR [rbp-0x4],0x0
    1c8d:	79 0f                   	jns    1c9e <controlFlow_Switch+0x42>
    1c8f:	eb 25                   	jmp    1cb6 <controlFlow_Switch+0x5a>
    1c91:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1c94:	83 e8 03                	sub    eax,0x3
    1c97:	83 f8 02                	cmp    eax,0x2
    1c9a:	77 1a                   	ja     1cb6 <controlFlow_Switch+0x5a>
    1c9c:	eb 06                   	jmp    1ca4 <controlFlow_Switch+0x48>

	   case 0 :
	   case 1 :
	   case 2 :
		   rating = 'D';
    1c9e:	c6 45 fb 44             	mov    BYTE PTR [rbp-0x5],0x44
		   break;
    1ca2:	eb 16                   	jmp    1cba <controlFlow_Switch+0x5e>

	   case 3 :
	   case 4 :
	   case 5 :
		   rating = 'C';
    1ca4:	c6 45 fb 43             	mov    BYTE PTR [rbp-0x5],0x43
	   break;
    1ca8:	eb 10                   	jmp    1cba <controlFlow_Switch+0x5e>

	   case 6 :
	   case 7 :
	   case 8 :
		   rating = 'B';
    1caa:	c6 45 fb 42             	mov    BYTE PTR [rbp-0x5],0x42
		   break;
    1cae:	eb 0a                   	jmp    1cba <controlFlow_Switch+0x5e>

	   case 9 :
	   case 10 :
		   rating = 'A';
    1cb0:	c6 45 fb 41             	mov    BYTE PTR [rbp-0x5],0x41
		   break;
    1cb4:	eb 04                   	jmp    1cba <controlFlow_Switch+0x5e>

	   default :
		   rating = 'X';
    1cb6:	c6 45 fb 58             	mov    BYTE PTR [rbp-0x5],0x58

   }//switch

	enum { colder, cold, warm, hot, hotter } climate = cold;
    1cba:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1
	wchar_t* text = "bilinmiyor";
    1cc1:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1cc8 <controlFlow_Switch+0x6c>
    1cc8:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
    1ccc:	83 7d f4 04             	cmp    DWORD PTR [rbp-0xc],0x4
    1cd0:	77 63                   	ja     1d35 <controlFlow_Switch+0xd9>
    1cd2:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    1cd5:	48 8d 14 85 00 00 00 00 	lea    rdx,[rax*4+0x0]
    1cdd:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1ce4 <controlFlow_Switch+0x88>
    1ce4:	8b 04 02                	mov    eax,DWORD PTR [rdx+rax*1]
    1ce7:	48 98                   	cdqe   
    1ce9:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 1cf0 <controlFlow_Switch+0x94>
    1cf0:	48 01 d0                	add    rax,rdx
    1cf3:	ff e0                   	jmp    rax

	// switch without default
	switch ( climate ) {
		case colder : text = L"çok soğuk"; break;
    1cf5:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1cfc <controlFlow_Switch+0xa0>
    1cfc:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
    1d00:	eb 33                   	jmp    1d35 <controlFlow_Switch+0xd9>
		case cold   : text = L"soğuk";     break;
    1d02:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1d09 <controlFlow_Switch+0xad>
    1d09:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
    1d0d:	eb 26                   	jmp    1d35 <controlFlow_Switch+0xd9>
		case warm   : text = L"ılık";      break;
    1d0f:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1d16 <controlFlow_Switch+0xba>
    1d16:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
    1d1a:	eb 19                   	jmp    1d35 <controlFlow_Switch+0xd9>
		case hot    : text = L"sıcak";     break;
    1d1c:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1d23 <controlFlow_Switch+0xc7>
    1d23:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
    1d27:	eb 0c                   	jmp    1d35 <controlFlow_Switch+0xd9>
		case hotter : text = L"çok sıcak"; break;
    1d29:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1d30 <controlFlow_Switch+0xd4>
    1d30:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
    1d34:	90                      	nop
	};

}//controlFlow_Switch
    1d35:	90                      	nop
    1d36:	5d                      	pop    rbp
    1d37:	c3                      	ret    

0000000000001d38 <sinus>:
//-----------------------------------------------------------------------------

/*
 * switch sample : lookup table
 */
float sinus( int angle ) {
    1d38:	55                      	push   rbp
    1d39:	48 89 e5                	mov    rbp,rsp
    1d3c:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi

	// TODO : process sign 0..360 degrees
	angle = angle > 45 ? 90 - angle : angle;
    1d3f:	83 7d fc 2d             	cmp    DWORD PTR [rbp-0x4],0x2d
    1d43:	7e 0a                   	jle    1d4f <sinus+0x17>
    1d45:	b8 5a 00 00 00          	mov    eax,0x5a
    1d4a:	2b 45 fc                	sub    eax,DWORD PTR [rbp-0x4]
    1d4d:	eb 03                   	jmp    1d52 <sinus+0x1a>
    1d4f:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1d52:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
    1d55:	83 7d fc 2d             	cmp    DWORD PTR [rbp-0x4],0x2d
    1d59:	77 23                   	ja     1d7e <sinus+0x46>
    1d5b:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1d5e:	48 8d 14 85 00 00 00 00 	lea    rdx,[rax*4+0x0]
    1d66:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1d6d <sinus+0x35>
    1d6d:	8b 04 02                	mov    eax,DWORD PTR [rdx+rax*1]
    1d70:	48 98                   	cdqe   
    1d72:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 1d79 <sinus+0x41>
    1d79:	48 01 d0                	add    rax,rdx
    1d7c:	ff e0                   	jmp    rax

	switch( angle ) {

    	default : return NAN;
    1d7e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1d86 <sinus+0x4e>
    1d86:	e9 29 02 00 00          	jmp    1fb4 <sinus+0x27c>

	    case 0  : return .0000;
    1d8b:	66 0f ef c0             	pxor   xmm0,xmm0
    1d8f:	e9 20 02 00 00          	jmp    1fb4 <sinus+0x27c>
		case 1  : return .0175;
    1d94:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1d9c <sinus+0x64>
    1d9c:	e9 13 02 00 00          	jmp    1fb4 <sinus+0x27c>
		case 2  : return .0349;
    1da1:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1da9 <sinus+0x71>
    1da9:	e9 06 02 00 00          	jmp    1fb4 <sinus+0x27c>
		case 3  : return .0523;
    1dae:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1db6 <sinus+0x7e>
    1db6:	e9 f9 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 4  : return .0698;
    1dbb:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1dc3 <sinus+0x8b>
    1dc3:	e9 ec 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 5  : return .0872;
    1dc8:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1dd0 <sinus+0x98>
    1dd0:	e9 df 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 6  : return .1045;
    1dd5:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1ddd <sinus+0xa5>
    1ddd:	e9 d2 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 7  : return .1219;
    1de2:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1dea <sinus+0xb2>
    1dea:	e9 c5 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 8  : return .1392;
    1def:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1df7 <sinus+0xbf>
    1df7:	e9 b8 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 9  : return .1564;
    1dfc:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e04 <sinus+0xcc>
    1e04:	e9 ab 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 10 : return .1736;
    1e09:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e11 <sinus+0xd9>
    1e11:	e9 9e 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 11 : return .1908;
    1e16:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e1e <sinus+0xe6>
    1e1e:	e9 91 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 12 : return .2079;
    1e23:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e2b <sinus+0xf3>
    1e2b:	e9 84 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 13 : return .2250;
    1e30:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e38 <sinus+0x100>
    1e38:	e9 77 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 14 : return .2419;
    1e3d:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e45 <sinus+0x10d>
    1e45:	e9 6a 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 15 : return .2588;
    1e4a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e52 <sinus+0x11a>
    1e52:	e9 5d 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 16 : return .2756;
    1e57:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e5f <sinus+0x127>
    1e5f:	e9 50 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 17 : return .2924;
    1e64:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e6c <sinus+0x134>
    1e6c:	e9 43 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 18 : return .3090;
    1e71:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e79 <sinus+0x141>
    1e79:	e9 36 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 19 : return .3256;
    1e7e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e86 <sinus+0x14e>
    1e86:	e9 29 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 20 : return .3420;
    1e8b:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1e93 <sinus+0x15b>
    1e93:	e9 1c 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 21 : return .3584;
    1e98:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1ea0 <sinus+0x168>
    1ea0:	e9 0f 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 22 : return .3746;
    1ea5:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1ead <sinus+0x175>
    1ead:	e9 02 01 00 00          	jmp    1fb4 <sinus+0x27c>
		case 23 : return .3907;
    1eb2:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1eba <sinus+0x182>
    1eba:	e9 f5 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 24 : return .4067;
    1ebf:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1ec7 <sinus+0x18f>
    1ec7:	e9 e8 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 25 : return .4226;
    1ecc:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1ed4 <sinus+0x19c>
    1ed4:	e9 db 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 26 : return .4384;
    1ed9:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1ee1 <sinus+0x1a9>
    1ee1:	e9 ce 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 27 : return .4540;
    1ee6:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1eee <sinus+0x1b6>
    1eee:	e9 c1 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 28 : return .4695;
    1ef3:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1efb <sinus+0x1c3>
    1efb:	e9 b4 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 29 : return .4848;
    1f00:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f08 <sinus+0x1d0>
    1f08:	e9 a7 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 30 : return .5000;
    1f0d:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f15 <sinus+0x1dd>
    1f15:	e9 9a 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 31 : return .5150;
    1f1a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f22 <sinus+0x1ea>
    1f22:	e9 8d 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 32 : return .5299;
    1f27:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f2f <sinus+0x1f7>
    1f2f:	e9 80 00 00 00          	jmp    1fb4 <sinus+0x27c>
		case 33 : return .5446;
    1f34:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f3c <sinus+0x204>
    1f3c:	eb 76                   	jmp    1fb4 <sinus+0x27c>
		case 34 : return .5592;
    1f3e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f46 <sinus+0x20e>
    1f46:	eb 6c                   	jmp    1fb4 <sinus+0x27c>
		case 35 : return .5736;
    1f48:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f50 <sinus+0x218>
    1f50:	eb 62                   	jmp    1fb4 <sinus+0x27c>
		case 36 : return .5878;
    1f52:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f5a <sinus+0x222>
    1f5a:	eb 58                   	jmp    1fb4 <sinus+0x27c>
		case 37 : return .6018;
    1f5c:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f64 <sinus+0x22c>
    1f64:	eb 4e                   	jmp    1fb4 <sinus+0x27c>
		case 38 : return .6157;
    1f66:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f6e <sinus+0x236>
    1f6e:	eb 44                   	jmp    1fb4 <sinus+0x27c>
		case 39 : return .6293;
    1f70:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f78 <sinus+0x240>
    1f78:	eb 3a                   	jmp    1fb4 <sinus+0x27c>
		case 40 : return .6428;
    1f7a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f82 <sinus+0x24a>
    1f82:	eb 30                   	jmp    1fb4 <sinus+0x27c>
		case 41 : return .6561;
    1f84:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f8c <sinus+0x254>
    1f8c:	eb 26                   	jmp    1fb4 <sinus+0x27c>
		case 42 : return .6691;
    1f8e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1f96 <sinus+0x25e>
    1f96:	eb 1c                   	jmp    1fb4 <sinus+0x27c>
		case 43 : return .6820;
    1f98:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1fa0 <sinus+0x268>
    1fa0:	eb 12                   	jmp    1fb4 <sinus+0x27c>
		case 44 : return .6947;
    1fa2:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1faa <sinus+0x272>
    1faa:	eb 08                   	jmp    1fb4 <sinus+0x27c>
		case 45 : return .7071;
    1fac:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 1fb4 <sinus+0x27c>

	};//switch

}//sinus
    1fb4:	5d                      	pop    rbp
    1fb5:	c3                      	ret    

0000000000001fb6 <dosomething>:

//-----------------------------------------------------------------------------

typedef int (*callsomething)( int, int );

int dosomething( int a, int b ) {
    1fb6:	55                      	push   rbp
    1fb7:	48 89 e5                	mov    rbp,rsp
    1fba:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi
    1fbd:	89 75 e8                	mov    DWORD PTR [rbp-0x18],esi

	int loop = 3;
    1fc0:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [rbp-0x4],0x3
	while ( loop-- );
    1fc7:	90                      	nop
    1fc8:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    1fcb:	8d 50 ff                	lea    edx,[rax-0x1]
    1fce:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    1fd1:	85 c0                   	test   eax,eax
    1fd3:	75 f3                   	jne    1fc8 <dosomething+0x12>

	return 0;
    1fd5:	b8 00 00 00 00          	mov    eax,0x0

}//dosomething
    1fda:	5d                      	pop    rbp
    1fdb:	c3                      	ret    

0000000000001fdc <dosomething_endmarker>:

void dosomething_endmarker( void ) {
    1fdc:	55                      	push   rbp
    1fdd:	48 89 e5                	mov    rbp,rsp


}//dosomething_endmarker
    1fe0:	90                      	nop
    1fe1:	5d                      	pop    rbp
    1fe2:	c3                      	ret    

0000000000001fe3 <messWithTheFunctions>:

void messWithTheFunctions() {
    1fe3:	55                      	push   rbp
    1fe4:	48 89 e5                	mov    rbp,rsp
    1fe7:	48 83 ec 20             	sub    rsp,0x20

	int size = (void*)dosomething_endmarker - (void*)dosomething;
    1feb:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 1ff2 <messWithTheFunctions+0xf>
    1ff2:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 1ff9 <messWithTheFunctions+0x16>
    1ff9:	48 29 d0                	sub    rax,rdx
    1ffc:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

	char *source = dosomething;
    1fff:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 2006 <messWithTheFunctions+0x23>
    2006:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
	char *target = calloc( size, sizeof(char) );
    200a:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    200d:	48 98                   	cdqe   
    200f:	be 01 00 00 00          	mov    esi,0x1
    2014:	48 89 c7                	mov    rdi,rax
    2017:	e8 00 00 00 00          	call   201c <messWithTheFunctions+0x39>
    201c:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax

	while ( size-- )
    2020:	eb 1d                   	jmp    203f <messWithTheFunctions+0x5c>
		*target++ = *source++;
    2022:	48 8b 55 f0             	mov    rdx,QWORD PTR [rbp-0x10]
    2026:	48 8d 42 01             	lea    rax,[rdx+0x1]
    202a:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
    202e:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    2032:	48 8d 48 01             	lea    rcx,[rax+0x1]
    2036:	48 89 4d e8             	mov    QWORD PTR [rbp-0x18],rcx
    203a:	0f b6 12                	movzx  edx,BYTE PTR [rdx]
    203d:	88 10                   	mov    BYTE PTR [rax],dl
	while ( size-- )
    203f:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2042:	8d 50 ff                	lea    edx,[rax-0x1]
    2045:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    2048:	85 c0                   	test   eax,eax
    204a:	75 d6                   	jne    2022 <messWithTheFunctions+0x3f>

	callsomething call = target;
    204c:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    2050:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

	call( 3, 5 );
    2054:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    2058:	be 05 00 00 00          	mov    esi,0x5
    205d:	bf 03 00 00 00          	mov    edi,0x3
    2062:	ff d0                   	call   rax

}//messWithTheFunctions
    2064:	90                      	nop
    2065:	c9                      	leave  
    2066:	c3                      	ret    

0000000000002067 <printArguments>:

//-----------------------------------------------------------------------------

void printArguments( int argc, char** argv ) {
    2067:	55                      	push   rbp
    2068:	48 89 e5                	mov    rbp,rsp
    206b:	48 83 ec 20             	sub    rsp,0x20
    206f:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi
    2072:	48 89 75 e0             	mov    QWORD PTR [rbp-0x20],rsi

	for ( int i = 0; i < argc; i++ ) {
    2076:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
    207d:	eb 37                   	jmp    20b6 <printArguments+0x4f>
		printf( "[%d] : %s\r\n", (i+1), argv[i] );
    207f:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2082:	48 98                   	cdqe   
    2084:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    208c:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    2090:	48 01 d0                	add    rax,rdx
    2093:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2096:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    2099:	8d 4a 01                	lea    ecx,[rdx+0x1]
    209c:	48 89 c2                	mov    rdx,rax
    209f:	89 ce                   	mov    esi,ecx
    20a1:	48 8d 3d 00 00 00 00    	lea    rdi,[rip+0x0]        # 20a8 <printArguments+0x41>
    20a8:	b8 00 00 00 00          	mov    eax,0x0
    20ad:	e8 00 00 00 00          	call   20b2 <printArguments+0x4b>
	for ( int i = 0; i < argc; i++ ) {
    20b2:	83 45 fc 01             	add    DWORD PTR [rbp-0x4],0x1
    20b6:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    20b9:	3b 45 ec                	cmp    eax,DWORD PTR [rbp-0x14]
    20bc:	7c c1                   	jl     207f <printArguments+0x18>
	}//for

}//printArguments
    20be:	90                      	nop
    20bf:	90                      	nop
    20c0:	c9                      	leave  
    20c1:	c3                      	ret    

00000000000020c2 <nop>:

// iki "int" tipinde değer alan ve bir "int" tipinde değer döndüren
// her tür fonksiyonu gösterebilen "function pointer" tanımla.
typedef int (*operation)( int, int );

int nop( int a, int b ) {
    20c2:	55                      	push   rbp
    20c3:	48 89 e5                	mov    rbp,rsp
    20c6:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi
    20c9:	89 75 f8                	mov    DWORD PTR [rbp-0x8],esi
	return 0;
    20cc:	b8 00 00 00 00          	mov    eax,0x0
}
    20d1:	5d                      	pop    rbp
    20d2:	c3                      	ret    

00000000000020d3 <add>:

int add( int a, int b ) {
    20d3:	55                      	push   rbp
    20d4:	48 89 e5                	mov    rbp,rsp
    20d7:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi
    20da:	89 75 f8                	mov    DWORD PTR [rbp-0x8],esi
	return a + b;
    20dd:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    20e0:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    20e3:	01 d0                   	add    eax,edx
}
    20e5:	5d                      	pop    rbp
    20e6:	c3                      	ret    

00000000000020e7 <sub>:

int sub( int a, int b ) {
    20e7:	55                      	push   rbp
    20e8:	48 89 e5                	mov    rbp,rsp
    20eb:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi
    20ee:	89 75 f8                	mov    DWORD PTR [rbp-0x8],esi
	return a - b;
    20f1:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    20f4:	2b 45 f8                	sub    eax,DWORD PTR [rbp-0x8]
}
    20f7:	5d                      	pop    rbp
    20f8:	c3                      	ret    

00000000000020f9 <mul>:

int mul( int a, int b ) {
    20f9:	55                      	push   rbp
    20fa:	48 89 e5                	mov    rbp,rsp
    20fd:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi
    2100:	89 75 f8                	mov    DWORD PTR [rbp-0x8],esi
	return a * b;
    2103:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2106:	0f af 45 f8             	imul   eax,DWORD PTR [rbp-0x8]
}
    210a:	5d                      	pop    rbp
    210b:	c3                      	ret    

000000000000210c <idv>:

int idv( int a, int b ) {
    210c:	55                      	push   rbp
    210d:	48 89 e5                	mov    rbp,rsp
    2110:	89 7d fc                	mov    DWORD PTR [rbp-0x4],edi
    2113:	89 75 f8                	mov    DWORD PTR [rbp-0x8],esi
	return a / b;
    2116:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2119:	99                      	cdq    
    211a:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
}
    211d:	5d                      	pop    rbp
    211e:	c3                      	ret    

000000000000211f <parseArguments>:
 * out_operandB : tamsayı değer.
 *
 * RETURN:
 * void
 */
void parseArguments( char** in_values, char* out_operator, int* out_operandA, int* out_operandB ) {
    211f:	55                      	push   rbp
    2120:	48 89 e5                	mov    rbp,rsp
    2123:	48 89 7d c8             	mov    QWORD PTR [rbp-0x38],rdi
    2127:	48 89 75 c0             	mov    QWORD PTR [rbp-0x40],rsi
    212b:	48 89 55 b8             	mov    QWORD PTR [rbp-0x48],rdx
    212f:	48 89 4d b0             	mov    QWORD PTR [rbp-0x50],rcx

	*out_operator = in_values[ 1 ][ 0 ];
    2133:	48 8b 45 c8             	mov    rax,QWORD PTR [rbp-0x38]
    2137:	48 83 c0 08             	add    rax,0x8
    213b:	48 8b 00                	mov    rax,QWORD PTR [rax]
    213e:	0f b6 10                	movzx  edx,BYTE PTR [rax]
    2141:	48 8b 45 c0             	mov    rax,QWORD PTR [rbp-0x40]
    2145:	88 10                   	mov    BYTE PTR [rax],dl

    int* values[] = { out_operandA, out_operandB };
    2147:	48 8b 45 b8             	mov    rax,QWORD PTR [rbp-0x48]
    214b:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax
    214f:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2153:	48 89 45 d8             	mov    QWORD PTR [rbp-0x28],rax
    int index     = ( sizeof(values) / sizeof(int*) );
    2157:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2

	while ( index ) {
    215e:	e9 a8 00 00 00          	jmp    220b <parseArguments+0xec>

		char *valueStart = NULL;
    2163:	48 c7 45 e0 00 00 00 00 	mov    QWORD PTR [rbp-0x20],0x0
		char *valueEnd   = NULL;
    216b:	48 c7 45 f0 00 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0

		// string'in başına git
		valueStart = valueEnd = in_values[ index + 1 ];
    2173:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2176:	48 98                   	cdqe   
    2178:	48 83 c0 01             	add    rax,0x1
    217c:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    2184:	48 8b 45 c8             	mov    rax,QWORD PTR [rbp-0x38]
    2188:	48 01 d0                	add    rax,rdx
    218b:	48 8b 00                	mov    rax,QWORD PTR [rax]
    218e:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
    2192:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2196:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

		// string'in sonuna git
		while ( *++valueEnd );
    219a:	48 83 45 f0 01          	add    QWORD PTR [rbp-0x10],0x1
    219f:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    21a3:	0f b6 00                	movzx  eax,BYTE PTR [rax]
    21a6:	84 c0                   	test   al,al
    21a8:	75 f0                   	jne    219a <parseArguments+0x7b>

		// son, baştan büyük olduğu sürece "geri" git ve basamakların değerini hesapla
		int place = 1;
    21aa:	c7 45 ec 01 00 00 00    	mov    DWORD PTR [rbp-0x14],0x1
		while ( valueStart < valueEnd-- ) {
    21b1:	eb 42                   	jmp    21f5 <parseArguments+0xd6>

			*values[ index - 1 ] += ( *valueEnd - '0' ) * place;
    21b3:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    21b6:	83 e8 01                	sub    eax,0x1
    21b9:	48 98                   	cdqe   
    21bb:	48 8b 44 c5 d0          	mov    rax,QWORD PTR [rbp+rax*8-0x30]
    21c0:	8b 08                   	mov    ecx,DWORD PTR [rax]
    21c2:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    21c6:	0f b6 00                	movzx  eax,BYTE PTR [rax]
    21c9:	0f be c0                	movsx  eax,al
    21cc:	83 e8 30                	sub    eax,0x30
    21cf:	0f af 45 ec             	imul   eax,DWORD PTR [rbp-0x14]
    21d3:	89 c2                   	mov    edx,eax
    21d5:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    21d8:	83 e8 01                	sub    eax,0x1
    21db:	48 98                   	cdqe   
    21dd:	48 8b 44 c5 d0          	mov    rax,QWORD PTR [rbp+rax*8-0x30]
    21e2:	01 ca                   	add    edx,ecx
    21e4:	89 10                   	mov    DWORD PTR [rax],edx
			place *= 10;
    21e6:	8b 55 ec                	mov    edx,DWORD PTR [rbp-0x14]
    21e9:	89 d0                   	mov    eax,edx
    21eb:	c1 e0 02                	shl    eax,0x2
    21ee:	01 d0                   	add    eax,edx
    21f0:	01 c0                   	add    eax,eax
    21f2:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax
		while ( valueStart < valueEnd-- ) {
    21f5:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    21f9:	48 8d 50 ff             	lea    rdx,[rax-0x1]
    21fd:	48 89 55 f0             	mov    QWORD PTR [rbp-0x10],rdx
    2201:	48 39 45 e0             	cmp    QWORD PTR [rbp-0x20],rax
    2205:	72 ac                   	jb     21b3 <parseArguments+0x94>

		}

		index--;
    2207:	83 6d fc 01             	sub    DWORD PTR [rbp-0x4],0x1
	while ( index ) {
    220b:	83 7d fc 00             	cmp    DWORD PTR [rbp-0x4],0x0
    220f:	0f 85 4e ff ff ff       	jne    2163 <parseArguments+0x44>

	}//while

}//parseArguments
    2215:	90                      	nop
    2216:	90                      	nop
    2217:	5d                      	pop    rbp
    2218:	c3                      	ret    

0000000000002219 <functionPointerSample>:

/*
 *  Eclipse, komut satırı parametrelerini belirle:
 *  Run => Debug Configurations... => tab[Arguments] => textbox[Program arguments]: + 1234 789
 */
int functionPointerSample( int argc, char** argv ) {
    2219:	55                      	push   rbp
    221a:	48 89 e5                	mov    rbp,rsp
    221d:	41 57                   	push   r15
    221f:	41 56                   	push   r14
    2221:	41 55                   	push   r13
    2223:	41 54                   	push   r12
    2225:	53                      	push   rbx
    2226:	48 83 ec 48             	sub    rsp,0x48
    222a:	89 7d 9c                	mov    DWORD PTR [rbp-0x64],edi
    222d:	48 89 75 90             	mov    QWORD PTR [rbp-0x70],rsi
    2231:	48 89 e0                	mov    rax,rsp
    2234:	48 89 c3                	mov    rbx,rax

	const int minArgs = 4;
    2237:	c7 45 c8 04 00 00 00    	mov    DWORD PTR [rbp-0x38],0x4

	if ( argc < minArgs ) {
    223e:	8b 45 9c                	mov    eax,DWORD PTR [rbp-0x64]
    2241:	3b 45 c8                	cmp    eax,DWORD PTR [rbp-0x38]
    2244:	7d 16                   	jge    225c <functionPointerSample+0x43>
	   puts( "Argüman sayısı yetersiz. En az 3 argüman gerekli." );
    2246:	48 8d 3d 00 00 00 00    	lea    rdi,[rip+0x0]        # 224d <functionPointerSample+0x34>
    224d:	e8 00 00 00 00          	call   2252 <functionPointerSample+0x39>
	   return EXIT_FAILURE;
    2252:	b8 01 00 00 00          	mov    eax,0x1
    2257:	e9 4c 01 00 00          	jmp    23a8 <functionPointerSample+0x18f>
	}

	// operatör ve operandların değerlerini tutacak değişkenleri hazırla
	char operator = '\0';
    225c:	c6 45 ab 00             	mov    BYTE PTR [rbp-0x55],0x0
	int  operandA = 0;
    2260:	c7 45 a4 00 00 00 00    	mov    DWORD PTR [rbp-0x5c],0x0
	int  operandB = 0;
    2267:	c7 45 a0 00 00 00 00    	mov    DWORD PTR [rbp-0x60],0x0

	// komut satırından girlen "ham" metinleri "kullanılabilir" veriye çevir
	parseArguments( argv, &operator, &operandA, &operandB );
    226e:	48 8d 4d a0             	lea    rcx,[rbp-0x60]
    2272:	48 8d 55 a4             	lea    rdx,[rbp-0x5c]
    2276:	48 8d 75 ab             	lea    rsi,[rbp-0x55]
    227a:	48 8b 45 90             	mov    rax,QWORD PTR [rbp-0x70]
    227e:	48 89 c7                	mov    rdi,rax
    2281:	e8 00 00 00 00          	call   2286 <functionPointerSample+0x6d>

	// operatörlere karşılık gelen operasyonları sağlayan fonksiyonların
	// adreslerini tutan "lookup table"ı tanımla
	const int maxEntries = 255;
    2286:	c7 45 c4 ff 00 00 00    	mov    DWORD PTR [rbp-0x3c],0xff
	operation operations[ maxEntries ];
    228d:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    2290:	48 98                   	cdqe   
    2292:	48 83 e8 01             	sub    rax,0x1
    2296:	48 89 45 b8             	mov    QWORD PTR [rbp-0x48],rax
    229a:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    229d:	48 98                   	cdqe   
    229f:	49 89 c6                	mov    r14,rax
    22a2:	41 bf 00 00 00 00       	mov    r15d,0x0
    22a8:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    22ab:	48 98                   	cdqe   
    22ad:	49 89 c4                	mov    r12,rax
    22b0:	41 bd 00 00 00 00       	mov    r13d,0x0
    22b6:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    22b9:	48 98                   	cdqe   
    22bb:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    22c3:	b8 10 00 00 00          	mov    eax,0x10
    22c8:	48 83 e8 01             	sub    rax,0x1
    22cc:	48 01 d0                	add    rax,rdx
    22cf:	bf 10 00 00 00          	mov    edi,0x10
    22d4:	ba 00 00 00 00          	mov    edx,0x0
    22d9:	48 f7 f7                	div    rdi
    22dc:	48 6b c0 10             	imul   rax,rax,0x10
    22e0:	48 29 c4                	sub    rsp,rax
    22e3:	48 89 e0                	mov    rax,rsp
    22e6:	48 83 c0 07             	add    rax,0x7
    22ea:	48 c1 e8 03             	shr    rax,0x3
    22ee:	48 c1 e0 03             	shl    rax,0x3
    22f2:	48 89 45 b0             	mov    QWORD PTR [rbp-0x50],rax

	int entryCount = maxEntries;
    22f6:	8b 45 c4                	mov    eax,DWORD PTR [rbp-0x3c]
    22f9:	89 45 cc                	mov    DWORD PTR [rbp-0x34],eax

	// "lookup table"ı "no-operation" ile doldurarak başlat
	while ( entryCount-- )
    22fc:	eb 15                   	jmp    2313 <functionPointerSample+0xfa>
		operations[ entryCount ] = nop;
    22fe:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2302:	8b 55 cc                	mov    edx,DWORD PTR [rbp-0x34]
    2305:	48 63 d2                	movsxd rdx,edx
    2308:	48 8d 0d 00 00 00 00    	lea    rcx,[rip+0x0]        # 230f <functionPointerSample+0xf6>
    230f:	48 89 0c d0             	mov    QWORD PTR [rax+rdx*8],rcx
	while ( entryCount-- )
    2313:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    2316:	8d 50 ff                	lea    edx,[rax-0x1]
    2319:	89 55 cc                	mov    DWORD PTR [rbp-0x34],edx
    231c:	85 c0                   	test   eax,eax
    231e:	75 de                   	jne    22fe <functionPointerSample+0xe5>

	// başlatılan tabloyu hazırla
	operations[ '+' ] = add;
    2320:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2324:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 232b <functionPointerSample+0x112>
    232b:	48 89 90 58 01 00 00    	mov    QWORD PTR [rax+0x158],rdx
	operations[ '-' ] = sub;
    2332:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2336:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 233d <functionPointerSample+0x124>
    233d:	48 89 90 68 01 00 00    	mov    QWORD PTR [rax+0x168],rdx
	operations[ '*' ] = mul;
    2344:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2348:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 234f <functionPointerSample+0x136>
    234f:	48 89 90 50 01 00 00    	mov    QWORD PTR [rax+0x150],rdx
	operations[ '/' ] = idv;
    2356:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    235a:	48 8d 15 00 00 00 00    	lea    rdx,[rip+0x0]        # 2361 <functionPointerSample+0x148>
    2361:	48 89 90 78 01 00 00    	mov    QWORD PTR [rax+0x178],rdx

	// verilen operatörün operasyonunu tablodan bul çağır ve işlem sonucunu al
	int result = operations[ operator ]( operandA, operandB );
    2368:	0f b6 45 ab             	movzx  eax,BYTE PTR [rbp-0x55]
    236c:	0f be d0                	movsx  edx,al
    236f:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2373:	48 63 d2                	movsxd rdx,edx
    2376:	48 8b 0c d0             	mov    rcx,QWORD PTR [rax+rdx*8]
    237a:	8b 55 a0                	mov    edx,DWORD PTR [rbp-0x60]
    237d:	8b 45 a4                	mov    eax,DWORD PTR [rbp-0x5c]
    2380:	89 d6                   	mov    esi,edx
    2382:	89 c7                   	mov    edi,eax
    2384:	ff d1                   	call   rcx
    2386:	89 45 ac                	mov    DWORD PTR [rbp-0x54],eax

	// herhangi bir karakterle "no-operation"ı dene.
	result = operations[ '?' ]( operandA, operandB );
    2389:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    238d:	48 8b 88 f8 01 00 00    	mov    rcx,QWORD PTR [rax+0x1f8]
    2394:	8b 55 a0                	mov    edx,DWORD PTR [rbp-0x60]
    2397:	8b 45 a4                	mov    eax,DWORD PTR [rbp-0x5c]
    239a:	89 d6                   	mov    esi,edx
    239c:	89 c7                   	mov    edi,eax
    239e:	ff d1                   	call   rcx
    23a0:	89 45 ac                	mov    DWORD PTR [rbp-0x54],eax

	return EXIT_SUCCESS;
    23a3:	b8 00 00 00 00          	mov    eax,0x0
    23a8:	48 89 dc                	mov    rsp,rbx

}//functionPointerSample
    23ab:	48 8d 65 d8             	lea    rsp,[rbp-0x28]
    23af:	5b                      	pop    rbx
    23b0:	41 5c                   	pop    r12
    23b2:	41 5d                   	pop    r13
    23b4:	41 5e                   	pop    r14
    23b6:	41 5f                   	pop    r15
    23b8:	5d                      	pop    rbp
    23b9:	c3                      	ret    

00000000000023ba <functionPointers>:

//-----------------------------------------------------------------------------

void functionPointers( void ) {
    23ba:	55                      	push   rbp
    23bb:	48 89 e5                	mov    rbp,rsp
    23be:	48 83 ec 20             	sub    rsp,0x20

   int (*fp)( int, int ) = NULL;
    23c2:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
   void *pv = NULL;
    23ca:	48 c7 45 f0 00 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0

   int result = 0;
    23d2:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0

   // both the same
   fp = add;
    23d9:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 23e0 <functionPointers+0x26>
    23e0:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
   fp = &add;
    23e4:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 23eb <functionPointers+0x31>
    23eb:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax

   // old style call
   result = (*fp)( 5,3 );
    23ef:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    23f3:	be 03 00 00 00          	mov    esi,0x3
    23f8:	bf 05 00 00 00          	mov    edi,0x5
    23fd:	ff d0                   	call   rax
    23ff:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

   // C99 style call
   result = fp( 5, 3 );
    2402:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    2406:	be 03 00 00 00          	mov    esi,0x3
    240b:	bf 05 00 00 00          	mov    edi,0x5
    2410:	ff d0                   	call   rax
    2412:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

   pv = add;
    2415:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 241c <functionPointers+0x62>
    241c:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

   // function address assignment with and without casting
   fp = (int(*)(int,int)) pv;
    2420:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2424:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
   fp = pv;
    2428:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    242c:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax

   result = fp( 5, 3 );
    2430:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    2434:	be 03 00 00 00          	mov    esi,0x3
    2439:	bf 05 00 00 00          	mov    edi,0x5
    243e:	ff d0                   	call   rax
    2440:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

   // cast to function poimter than call :  int(*)(int,int)
   result = ( (int(*)(int,int))pv )( 5, 3 );
    2443:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2447:	be 03 00 00 00          	mov    esi,0x3
    244c:	bf 05 00 00 00          	mov    edi,0x5
    2451:	ff d0                   	call   rax
    2453:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

   pv = sub;
    2456:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 245d <functionPointers+0xa3>
    245d:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
   result = ( (int(*)(int,int))pv )( 5, 3 );
    2461:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2465:	be 03 00 00 00          	mov    esi,0x3
    246a:	bf 05 00 00 00          	mov    edi,0x5
    246f:	ff d0                   	call   rax
    2471:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

   pv = mul;
    2474:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 247b <functionPointers+0xc1>
    247b:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
   result = ( (int(*)(int,int))pv )( 5, 3 );
    247f:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2483:	be 03 00 00 00          	mov    esi,0x3
    2488:	bf 05 00 00 00          	mov    edi,0x5
    248d:	ff d0                   	call   rax
    248f:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

}//functionPointers
    2492:	90                      	nop
    2493:	c9                      	leave  
    2494:	c3                      	ret    

0000000000002495 <enums>:
	yellow,
	black,
	white
} AllColor;

void enums( void ) {
    2495:	55                      	push   rbp
    2496:	48 89 e5                	mov    rbp,rsp

	enum PrintColor { cyan, magenta, yellow, black };

	enum PrintColor colorW;
	enum PrintColor colorX;
	enum PrintColor colorY = black;
    2499:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [rbp-0x4],0x3
	enum PrintColor colorZ = magenta;
    24a0:	c7 45 f8 01 00 00 00    	mov    DWORD PTR [rbp-0x8],0x1

    enum TAllColor allA;
    enum TAllColor allB = black;
    24a7:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
	AllColor       allC;
	AllColor       allD = white;
    24ae:	c7 45 f0 0a 00 00 00    	mov    DWORD PTR [rbp-0x10],0xa

	size_t size = 0;
    24b5:	48 c7 45 e8 00 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0
	size = sizeof( colorA );
    24bd:	48 c7 45 e8 04 00 00 00 	mov    QWORD PTR [rbp-0x18],0x4

	colorA = 0;
    24c5:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0
	colorA = 1;
    24cc:	c7 45 e4 01 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x1
	colorA = 2;
    24d3:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x2

	colorA = red;
    24da:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0
	colorA = green;
    24e1:	c7 45 e4 01 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x1
	colorA = blue;
    24e8:	c7 45 e4 02 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x2

	colorA = colorA - 1;
    24ef:	83 6d e4 01             	sub    DWORD PTR [rbp-0x1c],0x1
	colorA = colorA - 1;
    24f3:	83 6d e4 01             	sub    DWORD PTR [rbp-0x1c],0x1
	colorA = colorA - 1;
    24f7:	83 6d e4 01             	sub    DWORD PTR [rbp-0x1c],0x1

	colorA = INT_MIN;
    24fb:	c7 45 e4 00 00 00 80    	mov    DWORD PTR [rbp-0x1c],0x80000000
	colorA = INT_MAX;
    2502:	c7 45 e4 ff ff ff 7f    	mov    DWORD PTR [rbp-0x1c],0x7fffffff

    colorA = colorZ;
    2509:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    250c:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax

}//enums
    250f:	90                      	nop
    2510:	5d                      	pop    rbp
    2511:	c3                      	ret    

0000000000002512 <arrays_variableSize>:

//------------------------------------------------------------------------------

void arrays_variableSize( int length ) {
    2512:	55                      	push   rbp
    2513:	48 89 e5                	mov    rbp,rsp
    2516:	53                      	push   rbx
    2517:	48 83 ec 38             	sub    rsp,0x38
    251b:	89 7d cc                	mov    DWORD PTR [rbp-0x34],edi
    251e:	48 89 e0                	mov    rax,rsp
    2521:	48 89 c3                	mov    rbx,rax

	//int valuesA[ length ] = {}; // error : variable-sized object may not be initialized
	int valuesA[ length ];
    2524:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    2527:	48 63 d0                	movsxd rdx,eax
    252a:	48 83 ea 01             	sub    rdx,0x1
    252e:	48 89 55 e0             	mov    QWORD PTR [rbp-0x20],rdx
    2532:	48 63 d0                	movsxd rdx,eax
    2535:	49 89 d2                	mov    r10,rdx
    2538:	41 bb 00 00 00 00       	mov    r11d,0x0
    253e:	48 63 d0                	movsxd rdx,eax
    2541:	49 89 d0                	mov    r8,rdx
    2544:	41 b9 00 00 00 00       	mov    r9d,0x0
    254a:	48 98                   	cdqe   
    254c:	48 8d 14 85 00 00 00 00 	lea    rdx,[rax*4+0x0]
    2554:	b8 10 00 00 00          	mov    eax,0x10
    2559:	48 83 e8 01             	sub    rax,0x1
    255d:	48 01 d0                	add    rax,rdx
    2560:	be 10 00 00 00          	mov    esi,0x10
    2565:	ba 00 00 00 00          	mov    edx,0x0
    256a:	48 f7 f6                	div    rsi
    256d:	48 6b c0 10             	imul   rax,rax,0x10
    2571:	48 29 c4                	sub    rsp,rax
    2574:	48 89 e0                	mov    rax,rsp
    2577:	48 83 c0 03             	add    rax,0x3
    257b:	48 c1 e8 02             	shr    rax,0x2
    257f:	48 c1 e0 02             	shl    rax,0x2
    2583:	48 89 45 d8             	mov    QWORD PTR [rbp-0x28],rax

	int* valuesB = malloc( length * sizeof(int) );
    2587:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    258a:	48 98                   	cdqe   
    258c:	48 c1 e0 02             	shl    rax,0x2
    2590:	48 89 c7                	mov    rdi,rax
    2593:	e8 00 00 00 00          	call   2598 <arrays_variableSize+0x86>
    2598:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax

	int loop = length;
    259c:	8b 45 cc                	mov    eax,DWORD PTR [rbp-0x34]
    259f:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax
	while( loop-- )
    25a2:	eb 35                   	jmp    25d9 <arrays_variableSize+0xc7>
	   valuesB[ loop ] = valuesA[ loop ] = 0;
    25a4:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    25a8:	8b 55 ec                	mov    edx,DWORD PTR [rbp-0x14]
    25ab:	48 63 d2                	movsxd rdx,edx
    25ae:	c7 04 90 00 00 00 00    	mov    DWORD PTR [rax+rdx*4],0x0
    25b5:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    25b8:	48 98                   	cdqe   
    25ba:	48 8d 14 85 00 00 00 00 	lea    rdx,[rax*4+0x0]
    25c2:	48 8b 45 d0             	mov    rax,QWORD PTR [rbp-0x30]
    25c6:	48 8d 0c 02             	lea    rcx,[rdx+rax*1]
    25ca:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    25ce:	8b 55 ec                	mov    edx,DWORD PTR [rbp-0x14]
    25d1:	48 63 d2                	movsxd rdx,edx
    25d4:	8b 04 90                	mov    eax,DWORD PTR [rax+rdx*4]
    25d7:	89 01                   	mov    DWORD PTR [rcx],eax
	while( loop-- )
    25d9:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    25dc:	8d 50 ff                	lea    edx,[rax-0x1]
    25df:	89 55 ec                	mov    DWORD PTR [rbp-0x14],edx
    25e2:	85 c0                   	test   eax,eax
    25e4:	75 be                   	jne    25a4 <arrays_variableSize+0x92>
    25e6:	48 89 dc                	mov    rsp,rbx

}//arrays_variableSize
    25e9:	90                      	nop
    25ea:	48 8b 5d f8             	mov    rbx,QWORD PTR [rbp-0x8]
    25ee:	c9                      	leave  
    25ef:	c3                      	ret    

00000000000025f0 <arrays_multiDimensional>:
//-----------------------------------------------------------------------------

// defines special type for ( 3 x 4 ) of integers.
typedef int Special3D[ 3 ][ 4 ];

void arrays_multiDimensional() {
    25f0:	55                      	push   rbp
    25f1:	48 89 e5                	mov    rbp,rsp
    25f4:	48 81 ec 10 01 00 00    	sub    rsp,0x110

    char valuesA[ 5 ][ 2 ] = { {0,1}, {2,3}, {4,5}, {6,7}, {8,9} };
    25fb:	66 c7 45 8e 00 01       	mov    WORD PTR [rbp-0x72],0x100
    2601:	66 c7 45 90 02 03       	mov    WORD PTR [rbp-0x70],0x302
    2607:	66 c7 45 92 04 05       	mov    WORD PTR [rbp-0x6e],0x504
    260d:	66 c7 45 94 06 07       	mov    WORD PTR [rbp-0x6c],0x706
    2613:	66 c7 45 96 08 09       	mov    WORD PTR [rbp-0x6a],0x908

	int valuesB[   ][ 3 ] = { {1,3,5} , {2,4,6} };
    2619:	c7 85 70 ff ff ff 01 00 	mov    DWORD PTR [rbp-0x90],0x1
    2621:	00 00 
    2623:	c7 85 74 ff ff ff 03 00 	mov    DWORD PTR [rbp-0x8c],0x3
    262b:	00 00 
    262d:	c7 85 78 ff ff ff 05 00 	mov    DWORD PTR [rbp-0x88],0x5
    2635:	00 00 
    2637:	c7 85 7c ff ff ff 02 00 	mov    DWORD PTR [rbp-0x84],0x2
    263f:	00 00 
    2641:	c7 45 80 04 00 00 00    	mov    DWORD PTR [rbp-0x80],0x4
    2648:	c7 45 84 06 00 00 00    	mov    DWORD PTR [rbp-0x7c],0x6
	int valuesC[ 2 ][ 3 ] = { {1,3,5} , {2,4,6} };
    264f:	c7 85 50 ff ff ff 01 00 	mov    DWORD PTR [rbp-0xb0],0x1
    2657:	00 00 
    2659:	c7 85 54 ff ff ff 03 00 	mov    DWORD PTR [rbp-0xac],0x3
    2661:	00 00 
    2663:	c7 85 58 ff ff ff 05 00 	mov    DWORD PTR [rbp-0xa8],0x5
    266b:	00 00 
    266d:	c7 85 5c ff ff ff 02 00 	mov    DWORD PTR [rbp-0xa4],0x2
    2675:	00 00 
    2677:	c7 85 60 ff ff ff 04 00 	mov    DWORD PTR [rbp-0xa0],0x4
    267f:	00 00 
    2681:	c7 85 64 ff ff ff 06 00 	mov    DWORD PTR [rbp-0x9c],0x6
    2689:	00 00 
	//int valuesC[ 2 ][  ] = { {1,3,5} , {2,4,6} };// error : array type has incomplete element type

	int valuesE[ 2 ][ 3 ][ 4 ] = {
    268b:	c7 85 f0 fe ff ff 6f 00 	mov    DWORD PTR [rbp-0x110],0x6f
    2693:	00 00 
    2695:	c7 85 f4 fe ff ff 70 00 	mov    DWORD PTR [rbp-0x10c],0x70
    269d:	00 00 
    269f:	c7 85 f8 fe ff ff 71 00 	mov    DWORD PTR [rbp-0x108],0x71
    26a7:	00 00 
    26a9:	c7 85 fc fe ff ff 72 00 	mov    DWORD PTR [rbp-0x104],0x72
    26b1:	00 00 
    26b3:	c7 85 00 ff ff ff 79 00 	mov    DWORD PTR [rbp-0x100],0x79
    26bb:	00 00 
    26bd:	c7 85 04 ff ff ff 7a 00 	mov    DWORD PTR [rbp-0xfc],0x7a
    26c5:	00 00 
    26c7:	c7 85 08 ff ff ff 7b 00 	mov    DWORD PTR [rbp-0xf8],0x7b
    26cf:	00 00 
    26d1:	c7 85 0c ff ff ff 7c 00 	mov    DWORD PTR [rbp-0xf4],0x7c
    26d9:	00 00 
    26db:	c7 85 10 ff ff ff 83 00 	mov    DWORD PTR [rbp-0xf0],0x83
    26e3:	00 00 
    26e5:	c7 85 14 ff ff ff 84 00 	mov    DWORD PTR [rbp-0xec],0x84
    26ed:	00 00 
    26ef:	c7 85 18 ff ff ff 85 00 	mov    DWORD PTR [rbp-0xe8],0x85
    26f7:	00 00 
    26f9:	c7 85 1c ff ff ff 86 00 	mov    DWORD PTR [rbp-0xe4],0x86
    2701:	00 00 
    2703:	c7 85 20 ff ff ff d3 00 	mov    DWORD PTR [rbp-0xe0],0xd3
    270b:	00 00 
    270d:	c7 85 24 ff ff ff d4 00 	mov    DWORD PTR [rbp-0xdc],0xd4
    2715:	00 00 
    2717:	c7 85 28 ff ff ff d5 00 	mov    DWORD PTR [rbp-0xd8],0xd5
    271f:	00 00 
    2721:	c7 85 2c ff ff ff d6 00 	mov    DWORD PTR [rbp-0xd4],0xd6
    2729:	00 00 
    272b:	c7 85 30 ff ff ff dd 00 	mov    DWORD PTR [rbp-0xd0],0xdd
    2733:	00 00 
    2735:	c7 85 34 ff ff ff de 00 	mov    DWORD PTR [rbp-0xcc],0xde
    273d:	00 00 
    273f:	c7 85 38 ff ff ff df 00 	mov    DWORD PTR [rbp-0xc8],0xdf
    2747:	00 00 
    2749:	c7 85 3c ff ff ff e0 00 	mov    DWORD PTR [rbp-0xc4],0xe0
    2751:	00 00 
    2753:	c7 85 40 ff ff ff e7 00 	mov    DWORD PTR [rbp-0xc0],0xe7
    275b:	00 00 
    275d:	c7 85 44 ff ff ff e8 00 	mov    DWORD PTR [rbp-0xbc],0xe8
    2765:	00 00 
    2767:	c7 85 48 ff ff ff e9 00 	mov    DWORD PTR [rbp-0xb8],0xe9
    276f:	00 00 
    2771:	c7 85 4c ff ff ff ea 00 	mov    DWORD PTR [rbp-0xb4],0xea
    2779:	00 00 
		{
			{211, 212, 213, 214} ,  {221, 222, 223, 224} ,  {231, 232, 233, 234}
		}
	};

	int distanceAsBytes = (int)&valuesA[0][0] - (int)&valuesA[1][0];
    277b:	48 8d 45 8e             	lea    rax,[rbp-0x72]
    277f:	89 c2                   	mov    edx,eax
    2781:	48 8d 45 8e             	lea    rax,[rbp-0x72]
    2785:	48 83 c0 02             	add    rax,0x2
    2789:	89 c1                   	mov    ecx,eax
    278b:	89 d0                   	mov    eax,edx
    278d:	29 c8                   	sub    eax,ecx
    278f:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax

	// see disassembly
	int value = 0;
    2792:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [rbp-0x20],0x0
	value = valuesA[0][0];
    2799:	0f b6 45 8e             	movzx  eax,BYTE PTR [rbp-0x72]
    279d:	0f be c0                	movsx  eax,al
    27a0:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = valuesA[0][1];
    27a3:	0f b6 45 8f             	movzx  eax,BYTE PTR [rbp-0x71]
    27a7:	0f be c0                	movsx  eax,al
    27aa:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = valuesA[1][0];
    27ad:	0f b6 45 90             	movzx  eax,BYTE PTR [rbp-0x70]
    27b1:	0f be c0                	movsx  eax,al
    27b4:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = valuesA[1][1];
    27b7:	0f b6 45 91             	movzx  eax,BYTE PTR [rbp-0x6f]
    27bb:	0f be c0                	movsx  eax,al
    27be:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = valuesA[2][0];
    27c1:	0f b6 45 92             	movzx  eax,BYTE PTR [rbp-0x6e]
    27c5:	0f be c0                	movsx  eax,al
    27c8:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = valuesA[3][1];
    27cb:	0f b6 45 95             	movzx  eax,BYTE PTR [rbp-0x6b]
    27cf:	0f be c0                	movsx  eax,al
    27d2:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	const int lengthI = 4;
    27d5:	c7 45 dc 04 00 00 00    	mov    DWORD PTR [rbp-0x24],0x4
	const int lengthJ = 3;
    27dc:	c7 45 d8 03 00 00 00    	mov    DWORD PTR [rbp-0x28],0x3
	const int lengthK = 2;
    27e3:	c7 45 d4 02 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x2

	size_t size = sizeof valuesE;
    27ea:	48 c7 45 c8 60 00 00 00 	mov    QWORD PTR [rbp-0x38],0x60

	for ( int k = 0; k < lengthK; k++ ) {
    27f2:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
    27f9:	e9 b4 00 00 00          	jmp    28b2 <arrays_multiDimensional+0x2c2>

		for ( int j = 0; j < lengthJ; j++ ) {
    27fe:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
    2805:	e9 98 00 00 00          	jmp    28a2 <arrays_multiDimensional+0x2b2>

			for ( int i = 0; i < lengthI; i++ ) {
    280a:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
    2811:	eb 7f                   	jmp    2892 <arrays_multiDimensional+0x2a2>

				int hundreds = k + 1;
    2813:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2816:	83 c0 01                	add    eax,0x1
    2819:	89 45 a0                	mov    DWORD PTR [rbp-0x60],eax
				int tens     = j + 1;
    281c:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    281f:	83 c0 01                	add    eax,0x1
    2822:	89 45 9c                	mov    DWORD PTR [rbp-0x64],eax
				int ones     = i;
    2825:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    2828:	89 45 98                	mov    DWORD PTR [rbp-0x68],eax

				valuesE[ k ][ j ][ i ] = 100*hundreds + 10*tens + ones;
    282b:	8b 45 a0                	mov    eax,DWORD PTR [rbp-0x60]
    282e:	6b c8 64                	imul   ecx,eax,0x64
    2831:	8b 55 9c                	mov    edx,DWORD PTR [rbp-0x64]
    2834:	89 d0                   	mov    eax,edx
    2836:	c1 e0 02                	shl    eax,0x2
    2839:	01 d0                   	add    eax,edx
    283b:	01 c0                   	add    eax,eax
    283d:	8d 14 01                	lea    edx,[rcx+rax*1]
    2840:	8b 45 98                	mov    eax,DWORD PTR [rbp-0x68]
    2843:	8d 0c 02                	lea    ecx,[rdx+rax*1]
    2846:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    2849:	48 63 f0                	movsxd rsi,eax
    284c:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    284f:	48 63 d0                	movsxd rdx,eax
    2852:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2855:	48 63 f8                	movsxd rdi,eax
    2858:	48 89 d0                	mov    rax,rdx
    285b:	48 01 c0                	add    rax,rax
    285e:	48 01 d0                	add    rax,rdx
    2861:	48 01 f8                	add    rax,rdi
    2864:	48 c1 e0 02             	shl    rax,0x2
    2868:	48 01 f0                	add    rax,rsi
    286b:	89 8c 85 f0 fe ff ff    	mov    DWORD PTR [rbp+rax*4-0x110],ecx
				printf( "%d%d%d ", hundreds, tens, ones );
    2872:	8b 4d 98                	mov    ecx,DWORD PTR [rbp-0x68]
    2875:	8b 55 9c                	mov    edx,DWORD PTR [rbp-0x64]
    2878:	8b 45 a0                	mov    eax,DWORD PTR [rbp-0x60]
    287b:	89 c6                   	mov    esi,eax
    287d:	48 8d 3d 00 00 00 00    	lea    rdi,[rip+0x0]        # 2884 <arrays_multiDimensional+0x294>
    2884:	b8 00 00 00 00          	mov    eax,0x0
    2889:	e8 00 00 00 00          	call   288e <arrays_multiDimensional+0x29e>
			for ( int i = 0; i < lengthI; i++ ) {
    288e:	83 45 f4 01             	add    DWORD PTR [rbp-0xc],0x1
    2892:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    2895:	3b 45 dc                	cmp    eax,DWORD PTR [rbp-0x24]
    2898:	0f 8c 75 ff ff ff       	jl     2813 <arrays_multiDimensional+0x223>
		for ( int j = 0; j < lengthJ; j++ ) {
    289e:	83 45 f8 01             	add    DWORD PTR [rbp-0x8],0x1
    28a2:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    28a5:	3b 45 d8                	cmp    eax,DWORD PTR [rbp-0x28]
    28a8:	0f 8c 5c ff ff ff       	jl     280a <arrays_multiDimensional+0x21a>
	for ( int k = 0; k < lengthK; k++ ) {
    28ae:	83 45 fc 01             	add    DWORD PTR [rbp-0x4],0x1
    28b2:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    28b5:	3b 45 d4                	cmp    eax,DWORD PTR [rbp-0x2c]
    28b8:	0f 8c 40 ff ff ff       	jl     27fe <arrays_multiDimensional+0x20e>

		}//forj

	}//fork

	Special3D* p3D = NULL;
    28be:	48 c7 45 c0 00 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
	size_t allocateBytes = sizeof(Special3D) * lengthK;
    28c6:	8b 45 d4                	mov    eax,DWORD PTR [rbp-0x2c]
    28c9:	48 63 d0                	movsxd rdx,eax
    28cc:	48 89 d0                	mov    rax,rdx
    28cf:	48 01 c0                	add    rax,rax
    28d2:	48 01 d0                	add    rax,rdx
    28d5:	48 c1 e0 04             	shl    rax,0x4
    28d9:	48 89 45 b8             	mov    QWORD PTR [rbp-0x48],rax

	void* buffer = malloc( allocateBytes );
    28dd:	48 8b 45 b8             	mov    rax,QWORD PTR [rbp-0x48]
    28e1:	48 89 c7                	mov    rdi,rax
    28e4:	e8 00 00 00 00          	call   28e9 <arrays_multiDimensional+0x2f9>
    28e9:	48 89 45 b0             	mov    QWORD PTR [rbp-0x50],rax
	if ( buffer == NULL ) {
    28ed:	48 83 7d b0 00          	cmp    QWORD PTR [rbp-0x50],0x0
    28f2:	75 0a                   	jne    28fe <arrays_multiDimensional+0x30e>
		// not enough memory, terminate the program with failure
	    exit( EXIT_FAILURE );
    28f4:	bf 01 00 00 00          	mov    edi,0x1
    28f9:	e8 00 00 00 00          	call   28fe <arrays_multiDimensional+0x30e>
	}

	// Casting void* to int(*)[3][4]. Same effect as casting to Special3D*
	p3D = (int(*)[3][4]) buffer;
    28fe:	48 8b 45 b0             	mov    rax,QWORD PTR [rbp-0x50]
    2902:	48 89 45 c0             	mov    QWORD PTR [rbp-0x40],rax

	for ( int k = 0; k < lengthK; k++ ) {
    2906:	c7 45 f0 00 00 00 00    	mov    DWORD PTR [rbp-0x10],0x0
    290d:	e9 96 00 00 00          	jmp    29a8 <arrays_multiDimensional+0x3b8>

		for ( int j = 0; j < lengthJ; j++ ) {
    2912:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
    2919:	eb 7d                   	jmp    2998 <arrays_multiDimensional+0x3a8>

			for ( int i = 0; i < lengthI; i++ ) {
    291b:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [rbp-0x18],0x0
    2922:	eb 68                   	jmp    298c <arrays_multiDimensional+0x39c>

				int hundreds = k + 1;
    2924:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    2927:	83 c0 01                	add    eax,0x1
    292a:	89 45 ac                	mov    DWORD PTR [rbp-0x54],eax
				int tens     = j + 1;
    292d:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    2930:	83 c0 01                	add    eax,0x1
    2933:	89 45 a8                	mov    DWORD PTR [rbp-0x58],eax
				int ones     = i;
    2936:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
    2939:	89 45 a4                	mov    DWORD PTR [rbp-0x5c],eax

				p3D[ k ][ j ][ i ] = 100*hundreds + 10*tens + ones;
    293c:	8b 45 ac                	mov    eax,DWORD PTR [rbp-0x54]
    293f:	6b c8 64                	imul   ecx,eax,0x64
    2942:	8b 55 a8                	mov    edx,DWORD PTR [rbp-0x58]
    2945:	89 d0                   	mov    eax,edx
    2947:	c1 e0 02                	shl    eax,0x2
    294a:	01 d0                   	add    eax,edx
    294c:	01 c0                   	add    eax,eax
    294e:	01 c1                   	add    ecx,eax
    2950:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    2953:	48 63 d0                	movsxd rdx,eax
    2956:	48 89 d0                	mov    rax,rdx
    2959:	48 01 c0                	add    rax,rax
    295c:	48 01 d0                	add    rax,rdx
    295f:	48 c1 e0 04             	shl    rax,0x4
    2963:	48 89 c2                	mov    rdx,rax
    2966:	48 8b 45 c0             	mov    rax,QWORD PTR [rbp-0x40]
    296a:	48 01 d0                	add    rax,rdx
    296d:	8b 55 a4                	mov    edx,DWORD PTR [rbp-0x5c]
    2970:	01 d1                   	add    ecx,edx
    2972:	8b 55 e8                	mov    edx,DWORD PTR [rbp-0x18]
    2975:	48 63 f2                	movsxd rsi,edx
    2978:	8b 55 ec                	mov    edx,DWORD PTR [rbp-0x14]
    297b:	48 63 d2                	movsxd rdx,edx
    297e:	48 c1 e2 02             	shl    rdx,0x2
    2982:	48 01 f2                	add    rdx,rsi
    2985:	89 0c 90                	mov    DWORD PTR [rax+rdx*4],ecx
			for ( int i = 0; i < lengthI; i++ ) {
    2988:	83 45 e8 01             	add    DWORD PTR [rbp-0x18],0x1
    298c:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
    298f:	3b 45 dc                	cmp    eax,DWORD PTR [rbp-0x24]
    2992:	7c 90                   	jl     2924 <arrays_multiDimensional+0x334>
		for ( int j = 0; j < lengthJ; j++ ) {
    2994:	83 45 ec 01             	add    DWORD PTR [rbp-0x14],0x1
    2998:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    299b:	3b 45 d8                	cmp    eax,DWORD PTR [rbp-0x28]
    299e:	0f 8c 77 ff ff ff       	jl     291b <arrays_multiDimensional+0x32b>
	for ( int k = 0; k < lengthK; k++ ) {
    29a4:	83 45 f0 01             	add    DWORD PTR [rbp-0x10],0x1
    29a8:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    29ab:	3b 45 d4                	cmp    eax,DWORD PTR [rbp-0x2c]
    29ae:	0f 8c 5e ff ff ff       	jl     2912 <arrays_multiDimensional+0x322>
		}//forj

	}//fork

    // free the previously allocated memory
	free( p3D );
    29b4:	48 8b 45 c0             	mov    rax,QWORD PTR [rbp-0x40]
    29b8:	48 89 c7                	mov    rdi,rax
    29bb:	e8 00 00 00 00          	call   29c0 <arrays_multiDimensional+0x3d0>

}//arrays_multiDimensional
    29c0:	90                      	nop
    29c1:	c9                      	leave  
    29c2:	c3                      	ret    

00000000000029c3 <arrays_multiDimensionalJagged>:

//-----------------------------------------------------------------------------

void arrays_multiDimensionalJagged() {
    29c3:	55                      	push   rbp
    29c4:	48 89 e5                	mov    rbp,rsp
    29c7:	48 83 ec 30             	sub    rsp,0x30

	// jagged array sample
	// refer https://en.wikipedia.org/wiki/Jagged_array
	int** values = NULL;
    29cb:	48 c7 45 f0 00 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0

    // TODO : implement check for return value of all "malloc()"s for an allocation error
    int arrayCount = 3;
    29d3:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
    values = (int**) malloc( arrayCount * sizeof(int*) );
    29da:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    29dd:	48 98                   	cdqe   
    29df:	48 c1 e0 03             	shl    rax,0x3
    29e3:	48 89 c7                	mov    rdi,rax
    29e6:	e8 00 00 00 00          	call   29eb <arrays_multiDimensionalJagged+0x28>
    29eb:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

    const int leastElementCount = 2;
    29ef:	c7 45 e8 02 00 00 00    	mov    DWORD PTR [rbp-0x18],0x2
	for ( int i = 0; i < arrayCount; i++ ) {
    29f6:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
    29fd:	e9 8c 00 00 00          	jmp    2a8e <arrays_multiDimensionalJagged+0xcb>

		int  length = i + leastElementCount;
    2a02:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    2a05:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
    2a08:	01 d0                   	add    eax,edx
    2a0a:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
		int* buffer = malloc( length * sizeof(int) );
    2a0d:	8b 45 dc                	mov    eax,DWORD PTR [rbp-0x24]
    2a10:	48 98                   	cdqe   
    2a12:	48 c1 e0 02             	shl    rax,0x2
    2a16:	48 89 c7                	mov    rdi,rax
    2a19:	e8 00 00 00 00          	call   2a1e <arrays_multiDimensionalJagged+0x5b>
    2a1e:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax

		values[ i ] = buffer;
    2a22:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2a25:	48 98                   	cdqe   
    2a27:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    2a2f:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2a33:	48 01 c2                	add    rdx,rax
    2a36:	48 8b 45 d0             	mov    rax,QWORD PTR [rbp-0x30]
    2a3a:	48 89 02                	mov    QWORD PTR [rdx],rax

		// fill the buffer
		for ( int j = 0; j < length; j++ ) {
    2a3d:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
    2a44:	eb 3c                   	jmp    2a82 <arrays_multiDimensionalJagged+0xbf>

			values[ i ][ j ] = i*10 + j;
    2a46:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    2a49:	89 d0                   	mov    eax,edx
    2a4b:	c1 e0 02                	shl    eax,0x2
    2a4e:	01 d0                   	add    eax,edx
    2a50:	01 c0                   	add    eax,eax
    2a52:	89 c1                   	mov    ecx,eax
    2a54:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2a57:	48 98                   	cdqe   
    2a59:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    2a61:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2a65:	48 01 d0                	add    rax,rdx
    2a68:	48 8b 10                	mov    rdx,QWORD PTR [rax]
    2a6b:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2a6e:	48 98                   	cdqe   
    2a70:	48 c1 e0 02             	shl    rax,0x2
    2a74:	48 01 d0                	add    rax,rdx
    2a77:	8b 55 f8                	mov    edx,DWORD PTR [rbp-0x8]
    2a7a:	01 ca                   	add    edx,ecx
    2a7c:	89 10                   	mov    DWORD PTR [rax],edx
		for ( int j = 0; j < length; j++ ) {
    2a7e:	83 45 f8 01             	add    DWORD PTR [rbp-0x8],0x1
    2a82:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2a85:	3b 45 dc                	cmp    eax,DWORD PTR [rbp-0x24]
    2a88:	7c bc                   	jl     2a46 <arrays_multiDimensionalJagged+0x83>
	for ( int i = 0; i < arrayCount; i++ ) {
    2a8a:	83 45 fc 01             	add    DWORD PTR [rbp-0x4],0x1
    2a8e:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2a91:	3b 45 ec                	cmp    eax,DWORD PTR [rbp-0x14]
    2a94:	0f 8c 68 ff ff ff       	jl     2a02 <arrays_multiDimensionalJagged+0x3f>
		}//forj

	}//fori


	int distanceAsBytes = (int)&values[0][0] - (int)&values[1][0];
    2a9a:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2a9e:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2aa1:	89 c2                   	mov    edx,eax
    2aa3:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2aa7:	48 83 c0 08             	add    rax,0x8
    2aab:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2aae:	89 c1                   	mov    ecx,eax
    2ab0:	89 d0                   	mov    eax,edx
    2ab2:	29 c8                   	sub    eax,ecx
    2ab4:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax

	// see disassembly
	int value = 0;
    2ab7:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [rbp-0x20],0x0
	value = values[0][0];
    2abe:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2ac2:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2ac5:	8b 00                   	mov    eax,DWORD PTR [rax]
    2ac7:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = values[0][1];
    2aca:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2ace:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2ad1:	8b 40 04                	mov    eax,DWORD PTR [rax+0x4]
    2ad4:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = values[0][2];
    2ad7:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2adb:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2ade:	8b 40 08                	mov    eax,DWORD PTR [rax+0x8]
    2ae1:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = values[1][0];
    2ae4:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2ae8:	48 83 c0 08             	add    rax,0x8
    2aec:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2aef:	8b 00                   	mov    eax,DWORD PTR [rax]
    2af1:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = values[1][1];
    2af4:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2af8:	48 83 c0 08             	add    rax,0x8
    2afc:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2aff:	8b 40 04                	mov    eax,DWORD PTR [rax+0x4]
    2b02:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = values[1][2];
    2b05:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2b09:	48 83 c0 08             	add    rax,0x8
    2b0d:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2b10:	8b 40 08                	mov    eax,DWORD PTR [rax+0x8]
    2b13:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = values[2][0];
    2b16:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2b1a:	48 83 c0 10             	add    rax,0x10
    2b1e:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2b21:	8b 00                   	mov    eax,DWORD PTR [rax]
    2b23:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = values[2][1];
    2b26:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2b2a:	48 83 c0 10             	add    rax,0x10
    2b2e:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2b31:	8b 40 04                	mov    eax,DWORD PTR [rax+0x4]
    2b34:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = values[2][2];
    2b37:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2b3b:	48 83 c0 10             	add    rax,0x10
    2b3f:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2b42:	8b 40 08                	mov    eax,DWORD PTR [rax+0x8]
    2b45:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	// TODO : we need lots of "free()"s here...

}//arrays_multiDimensionalJagged
    2b48:	90                      	nop
    2b49:	c9                      	leave  
    2b4a:	c3                      	ret    

0000000000002b4b <arrays_multiDimensionalJaggedvsFlat>:

//-----------------------------------------------------------------------------

void arrays_multiDimensionalJaggedvsFlat() {
    2b4b:	55                      	push   rbp
    2b4c:	48 89 e5                	mov    rbp,rsp
    2b4f:	48 83 ec 60             	sub    rsp,0x60

	// jagged array sample
	// refer https://en.wikipedia.org/wiki/Jagged_array

	int** jagged = NULL;
    2b53:	48 c7 45 f0 00 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0
    int   flat[3][3] = { {0,1,2}, {10,11,12}, {20,21,22} };
    2b5b:	c7 45 a0 00 00 00 00    	mov    DWORD PTR [rbp-0x60],0x0
    2b62:	c7 45 a4 01 00 00 00    	mov    DWORD PTR [rbp-0x5c],0x1
    2b69:	c7 45 a8 02 00 00 00    	mov    DWORD PTR [rbp-0x58],0x2
    2b70:	c7 45 ac 0a 00 00 00    	mov    DWORD PTR [rbp-0x54],0xa
    2b77:	c7 45 b0 0b 00 00 00    	mov    DWORD PTR [rbp-0x50],0xb
    2b7e:	c7 45 b4 0c 00 00 00    	mov    DWORD PTR [rbp-0x4c],0xc
    2b85:	c7 45 b8 14 00 00 00    	mov    DWORD PTR [rbp-0x48],0x14
    2b8c:	c7 45 bc 15 00 00 00    	mov    DWORD PTR [rbp-0x44],0x15
    2b93:	c7 45 c0 16 00 00 00    	mov    DWORD PTR [rbp-0x40],0x16

    // TODO : implement check for return value of all "malloc"s for an allocation error
    int arrayCount = 3;
    2b9a:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
    jagged = (int**) malloc( 2 * sizeof(int*) );
    2ba1:	bf 10 00 00 00          	mov    edi,0x10
    2ba6:	e8 00 00 00 00          	call   2bab <arrays_multiDimensionalJaggedvsFlat+0x60>
    2bab:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

    const int leastElementCount = 2;
    2baf:	c7 45 e8 02 00 00 00    	mov    DWORD PTR [rbp-0x18],0x2
	for ( int i = 0; i < arrayCount; i++ ) {
    2bb6:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
    2bbd:	e9 8c 00 00 00          	jmp    2c4e <arrays_multiDimensionalJaggedvsFlat+0x103>

		int  length = i + leastElementCount;
    2bc2:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    2bc5:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
    2bc8:	01 d0                   	add    eax,edx
    2bca:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax
		int* buffer = malloc( length * sizeof(int) );
    2bcd:	8b 45 dc                	mov    eax,DWORD PTR [rbp-0x24]
    2bd0:	48 98                   	cdqe   
    2bd2:	48 c1 e0 02             	shl    rax,0x2
    2bd6:	48 89 c7                	mov    rdi,rax
    2bd9:	e8 00 00 00 00          	call   2bde <arrays_multiDimensionalJaggedvsFlat+0x93>
    2bde:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax

		jagged[ i ] = buffer;
    2be2:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2be5:	48 98                   	cdqe   
    2be7:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    2bef:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2bf3:	48 01 c2                	add    rdx,rax
    2bf6:	48 8b 45 d0             	mov    rax,QWORD PTR [rbp-0x30]
    2bfa:	48 89 02                	mov    QWORD PTR [rdx],rax

		// fill the buffer
		for ( int j = 0; j < length; j++ ) {
    2bfd:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
    2c04:	eb 3c                   	jmp    2c42 <arrays_multiDimensionalJaggedvsFlat+0xf7>

			jagged[ i ][ j ] = i*10 + j;
    2c06:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    2c09:	89 d0                   	mov    eax,edx
    2c0b:	c1 e0 02                	shl    eax,0x2
    2c0e:	01 d0                   	add    eax,edx
    2c10:	01 c0                   	add    eax,eax
    2c12:	89 c1                   	mov    ecx,eax
    2c14:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2c17:	48 98                   	cdqe   
    2c19:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
    2c21:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2c25:	48 01 d0                	add    rax,rdx
    2c28:	48 8b 10                	mov    rdx,QWORD PTR [rax]
    2c2b:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2c2e:	48 98                   	cdqe   
    2c30:	48 c1 e0 02             	shl    rax,0x2
    2c34:	48 01 d0                	add    rax,rdx
    2c37:	8b 55 f8                	mov    edx,DWORD PTR [rbp-0x8]
    2c3a:	01 ca                   	add    edx,ecx
    2c3c:	89 10                   	mov    DWORD PTR [rax],edx
		for ( int j = 0; j < length; j++ ) {
    2c3e:	83 45 f8 01             	add    DWORD PTR [rbp-0x8],0x1
    2c42:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2c45:	3b 45 dc                	cmp    eax,DWORD PTR [rbp-0x24]
    2c48:	7c bc                   	jl     2c06 <arrays_multiDimensionalJaggedvsFlat+0xbb>
	for ( int i = 0; i < arrayCount; i++ ) {
    2c4a:	83 45 fc 01             	add    DWORD PTR [rbp-0x4],0x1
    2c4e:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2c51:	3b 45 ec                	cmp    eax,DWORD PTR [rbp-0x14]
    2c54:	0f 8c 68 ff ff ff       	jl     2bc2 <arrays_multiDimensionalJaggedvsFlat+0x77>

		}//forj

	}//fori

	int distanceAsBytes = 0;
    2c5a:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0
	distanceAsBytes = (int)&jagged[0][0] - (int)&jagged[1][0];
    2c61:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2c65:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2c68:	89 c2                   	mov    edx,eax
    2c6a:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2c6e:	48 83 c0 08             	add    rax,0x8
    2c72:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2c75:	89 c1                   	mov    ecx,eax
    2c77:	89 d0                   	mov    eax,edx
    2c79:	29 c8                   	sub    eax,ecx
    2c7b:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax
	distanceAsBytes = (int)&flat[0][0]   - (int)&flat[1][0];
    2c7e:	48 8d 45 a0             	lea    rax,[rbp-0x60]
    2c82:	89 c2                   	mov    edx,eax
    2c84:	48 8d 45 a0             	lea    rax,[rbp-0x60]
    2c88:	48 83 c0 0c             	add    rax,0xc
    2c8c:	89 c1                   	mov    ecx,eax
    2c8e:	89 d0                   	mov    eax,edx
    2c90:	29 c8                   	sub    eax,ecx
    2c92:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax

	// see disassembly
	int value = 0;
    2c95:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [rbp-0x20],0x0

	value = flat[0][0];
    2c9c:	8b 45 a0                	mov    eax,DWORD PTR [rbp-0x60]
    2c9f:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = jagged[0][0];
    2ca2:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2ca6:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2ca9:	8b 00                   	mov    eax,DWORD PTR [rax]
    2cab:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = jagged[0][0];
    2cae:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2cb2:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2cb5:	8b 00                   	mov    eax,DWORD PTR [rax]
    2cb7:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = jagged[0][1];
    2cba:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2cbe:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2cc1:	8b 40 04                	mov    eax,DWORD PTR [rax+0x4]
    2cc4:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = jagged[0][2];
    2cc7:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2ccb:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2cce:	8b 40 08                	mov    eax,DWORD PTR [rax+0x8]
    2cd1:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = jagged[1][0];
    2cd4:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2cd8:	48 83 c0 08             	add    rax,0x8
    2cdc:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2cdf:	8b 00                   	mov    eax,DWORD PTR [rax]
    2ce1:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = jagged[1][1];
    2ce4:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2ce8:	48 83 c0 08             	add    rax,0x8
    2cec:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2cef:	8b 40 04                	mov    eax,DWORD PTR [rax+0x4]
    2cf2:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = jagged[1][2];
    2cf5:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    2cf9:	48 83 c0 08             	add    rax,0x8
    2cfd:	48 8b 00                	mov    rax,QWORD PTR [rax]
    2d00:	8b 40 08                	mov    eax,DWORD PTR [rax+0x8]
    2d03:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = flat[0][0];
    2d06:	8b 45 a0                	mov    eax,DWORD PTR [rbp-0x60]
    2d09:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = flat[0][1];
    2d0c:	8b 45 a4                	mov    eax,DWORD PTR [rbp-0x5c]
    2d0f:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = flat[0][2];
    2d12:	8b 45 a8                	mov    eax,DWORD PTR [rbp-0x58]
    2d15:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	value = flat[1][0];
    2d18:	8b 45 ac                	mov    eax,DWORD PTR [rbp-0x54]
    2d1b:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = flat[1][1];
    2d1e:	8b 45 b0                	mov    eax,DWORD PTR [rbp-0x50]
    2d21:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
	value = flat[1][2];
    2d24:	8b 45 b4                	mov    eax,DWORD PTR [rbp-0x4c]
    2d27:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

	// TODO : we need lots of "free()"s here...

}//arrays_multiDimensionalJagged
    2d2a:	90                      	nop
    2d2b:	c9                      	leave  
    2d2c:	c3                      	ret    

0000000000002d2d <setBit>:

typedef unsigned char byte;
typedef unsigned int doubleword;
typedef enum { zero, one } BitValue;

doubleword setBit( doubleword value, byte bitIndex ) {
    2d2d:	55                      	push   rbp
    2d2e:	48 89 e5                	mov    rbp,rsp
    2d31:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi
    2d34:	89 f0                   	mov    eax,esi
    2d36:	88 45 e8                	mov    BYTE PTR [rbp-0x18],al

	doubleword mask = 0;
    2d39:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0

	mask = (unsigned) 1 << bitIndex;
    2d40:	0f b6 45 e8             	movzx  eax,BYTE PTR [rbp-0x18]
    2d44:	ba 01 00 00 00          	mov    edx,0x1
    2d49:	89 c1                   	mov    ecx,eax
    2d4b:	d3 e2                   	shl    edx,cl
    2d4d:	89 d0                   	mov    eax,edx
    2d4f:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
    value |= mask;
    2d52:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2d55:	09 45 ec                	or     DWORD PTR [rbp-0x14],eax

	return value;
    2d58:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]

}//setBit
    2d5b:	5d                      	pop    rbp
    2d5c:	c3                      	ret    

0000000000002d5d <resetBit>:

doubleword resetBit( doubleword value, byte bitIndex ) {
    2d5d:	55                      	push   rbp
    2d5e:	48 89 e5                	mov    rbp,rsp
    2d61:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi
    2d64:	89 f0                   	mov    eax,esi
    2d66:	88 45 e8                	mov    BYTE PTR [rbp-0x18],al

	doubleword mask = 0;
    2d69:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0

	mask = (unsigned) 1 << bitIndex;
    2d70:	0f b6 45 e8             	movzx  eax,BYTE PTR [rbp-0x18]
    2d74:	ba 01 00 00 00          	mov    edx,0x1
    2d79:	89 c1                   	mov    ecx,eax
    2d7b:	d3 e2                   	shl    edx,cl
    2d7d:	89 d0                   	mov    eax,edx
    2d7f:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
	mask = ~mask;
    2d82:	f7 55 fc                	not    DWORD PTR [rbp-0x4]

	value &= mask;
    2d85:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2d88:	21 45 ec                	and    DWORD PTR [rbp-0x14],eax

	return value;
    2d8b:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]

}//resetBit
    2d8e:	5d                      	pop    rbp
    2d8f:	c3                      	ret    

0000000000002d90 <readBit>:

BitValue readBit( doubleword value, byte bitIndex ) {
    2d90:	55                      	push   rbp
    2d91:	48 89 e5                	mov    rbp,rsp
    2d94:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi
    2d97:	89 f0                   	mov    eax,esi
    2d99:	88 45 e8                	mov    BYTE PTR [rbp-0x18],al

	doubleword mask = 0;
    2d9c:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0

	mask = (unsigned) 1 << bitIndex;
    2da3:	0f b6 45 e8             	movzx  eax,BYTE PTR [rbp-0x18]
    2da7:	ba 01 00 00 00          	mov    edx,0x1
    2dac:	89 c1                   	mov    ecx,eax
    2dae:	d3 e2                   	shl    edx,cl
    2db0:	89 d0                   	mov    eax,edx
    2db2:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
	mask = ~mask;
    2db5:	f7 55 fc                	not    DWORD PTR [rbp-0x4]

	return (value & mask) ? one : zero;
    2db8:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    2dbb:	23 45 fc                	and    eax,DWORD PTR [rbp-0x4]
    2dbe:	85 c0                   	test   eax,eax
    2dc0:	0f 95 c0                	setne  al
    2dc3:	0f b6 c0                	movzx  eax,al

}//readBit
    2dc6:	5d                      	pop    rbp
    2dc7:	c3                      	ret    

0000000000002dc8 <xorSwap>:

void xorSwap( doubleword* pValueA, doubleword* pValueB ) {
    2dc8:	55                      	push   rbp
    2dc9:	48 89 e5                	mov    rbp,rsp
    2dcc:	48 89 7d f8             	mov    QWORD PTR [rbp-0x8],rdi
    2dd0:	48 89 75 f0             	mov    QWORD PTR [rbp-0x10],rsi

	if ( *pValueA == *pValueA )
		return;
    2dd4:	90                      	nop
    *pValueB ^= *pValueA;
    *pValueA ^= *pValueB;

    //*pValueA ^= *pValueB ^= *pValueA ^= *pValueB;

}//xorSwap
    2dd5:	5d                      	pop    rbp
    2dd6:	c3                      	ret    

0000000000002dd7 <xorIsNonDestructiveOperation>:

void xorIsNonDestructiveOperation( void ) {
    2dd7:	55                      	push   rbp
    2dd8:	48 89 e5                	mov    rbp,rsp

   int value = 0xF0000000;
    2ddb:	c7 45 f4 00 00 00 f0    	mov    DWORD PTR [rbp-0xc],0xf0000000

   value = value ^ value;
    2de2:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   value ^= value;
    2de9:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
   value ^= value;
    2df0:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   value = 0xFFFF0000;
    2df7:	c7 45 f4 00 00 ff ff    	mov    DWORD PTR [rbp-0xc],0xffff0000

   value ^= value;
    2dfe:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
   value ^= value;
    2e05:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0

   byte cipherKey = '#';
    2e0c:	c6 45 f3 23             	mov    BYTE PTR [rbp-0xd],0x23
   char message[] = "look to my coming on the first light of the fifth day";
    2e10:	48 b8 6c 6f 6f 6b 20 74 	movabs rax,0x206f74206b6f6f6c
    2e18:	6f 20 
    2e1a:	48 ba 6d 79 20 63 6f 6d 	movabs rdx,0x6e696d6f6320796d
    2e22:	69 6e 
    2e24:	48 89 45 b0             	mov    QWORD PTR [rbp-0x50],rax
    2e28:	48 89 55 b8             	mov    QWORD PTR [rbp-0x48],rdx
    2e2c:	48 b8 67 20 6f 6e 20 74 	movabs rax,0x656874206e6f2067
    2e34:	68 65 
    2e36:	48 ba 20 66 69 72 73 74 	movabs rdx,0x6c20747372696620
    2e3e:	20 6c 
    2e40:	48 89 45 c0             	mov    QWORD PTR [rbp-0x40],rax
    2e44:	48 89 55 c8             	mov    QWORD PTR [rbp-0x38],rdx
    2e48:	48 b8 69 67 68 74 20 6f 	movabs rax,0x20666f2074686769
    2e50:	66 20 
    2e52:	48 ba 74 68 65 20 66 69 	movabs rdx,0x7466696620656874
    2e5a:	66 74 
    2e5c:	48 89 45 d0             	mov    QWORD PTR [rbp-0x30],rax
    2e60:	48 89 55 d8             	mov    QWORD PTR [rbp-0x28],rdx
    2e64:	c7 45 e0 68 20 64 61    	mov    DWORD PTR [rbp-0x20],0x61642068
    2e6b:	66 c7 45 e4 79 00       	mov    WORD PTR [rbp-0x1c],0x79

   // cipher
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2e71:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
    2e78:	eb 1d                   	jmp    2e97 <xorIsNonDestructiveOperation+0xc0>

	   message[ i ] ^= (char) cipherKey;
    2e7a:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2e7d:	48 98                   	cdqe   
    2e7f:	0f b6 54 05 b0          	movzx  edx,BYTE PTR [rbp+rax*1-0x50]
    2e84:	0f b6 45 f3             	movzx  eax,BYTE PTR [rbp-0xd]
    2e88:	31 c2                   	xor    edx,eax
    2e8a:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2e8d:	48 98                   	cdqe   
    2e8f:	88 54 05 b0             	mov    BYTE PTR [rbp+rax*1-0x50],dl
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2e93:	83 45 fc 01             	add    DWORD PTR [rbp-0x4],0x1
    2e97:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    2e9a:	48 98                   	cdqe   
    2e9c:	0f b6 44 05 b0          	movzx  eax,BYTE PTR [rbp+rax*1-0x50]
    2ea1:	84 c0                   	test   al,al
    2ea3:	75 d5                   	jne    2e7a <xorIsNonDestructiveOperation+0xa3>

   }

   // decipher
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2ea5:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
    2eac:	eb 1d                   	jmp    2ecb <xorIsNonDestructiveOperation+0xf4>

	   message[ i ] ^= (char) cipherKey;
    2eae:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2eb1:	48 98                   	cdqe   
    2eb3:	0f b6 54 05 b0          	movzx  edx,BYTE PTR [rbp+rax*1-0x50]
    2eb8:	0f b6 45 f3             	movzx  eax,BYTE PTR [rbp-0xd]
    2ebc:	31 c2                   	xor    edx,eax
    2ebe:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2ec1:	48 98                   	cdqe   
    2ec3:	88 54 05 b0             	mov    BYTE PTR [rbp+rax*1-0x50],dl
   for ( int i = 0 ; message[ i ] ; i++ ) {
    2ec7:	83 45 f8 01             	add    DWORD PTR [rbp-0x8],0x1
    2ecb:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2ece:	48 98                   	cdqe   
    2ed0:	0f b6 44 05 b0          	movzx  eax,BYTE PTR [rbp+rax*1-0x50]
    2ed5:	84 c0                   	test   al,al
    2ed7:	75 d5                   	jne    2eae <xorIsNonDestructiveOperation+0xd7>

   }

}//xorIsNonDestructiveOperation
    2ed9:	90                      	nop
    2eda:	90                      	nop
    2edb:	5d                      	pop    rbp
    2edc:	c3                      	ret    

0000000000002edd <getHighNibble>:

#define CLEAR_LOW_NIBBLE (4)
#define CLEAR_HIGH_NIBBLE (0xF)

byte getHighNibble( byte value ) {
    2edd:	55                      	push   rbp
    2ede:	48 89 e5                	mov    rbp,rsp
    2ee1:	89 f8                   	mov    eax,edi
    2ee3:	88 45 fc                	mov    BYTE PTR [rbp-0x4],al

	return (byte)( value >> CLEAR_LOW_NIBBLE );
    2ee6:	0f b6 45 fc             	movzx  eax,BYTE PTR [rbp-0x4]
    2eea:	c0 e8 04                	shr    al,0x4

}//getHighNibble
    2eed:	5d                      	pop    rbp
    2eee:	c3                      	ret    

0000000000002eef <getLowNibble>:

byte getLowNibble( byte value ) {
    2eef:	55                      	push   rbp
    2ef0:	48 89 e5                	mov    rbp,rsp
    2ef3:	89 f8                   	mov    eax,edi
    2ef5:	88 45 fc                	mov    BYTE PTR [rbp-0x4],al

	return value & CLEAR_HIGH_NIBBLE;
    2ef8:	0f b6 45 fc             	movzx  eax,BYTE PTR [rbp-0x4]
    2efc:	83 e0 0f                	and    eax,0xf

}//getLowNibble
    2eff:	5d                      	pop    rbp
    2f00:	c3                      	ret    

0000000000002f01 <bitManipulation>:

void bitManipulation() {
    2f01:	55                      	push   rbp
    2f02:	48 89 e5                	mov    rbp,rsp
    2f05:	48 83 ec 20             	sub    rsp,0x20

	BitValue valueAsBit = 0;
    2f09:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
	int      result     = 0;
    2f10:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
	int      testValue  = 6; // 00000000000000000000000000000110
    2f17:	c7 45 f4 06 00 00 00    	mov    DWORD PTR [rbp-0xc],0x6

	valueAsBit = readBit( testValue, 2 );
    2f1e:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    2f21:	be 02 00 00 00          	mov    esi,0x2
    2f26:	89 c7                   	mov    edi,eax
    2f28:	e8 00 00 00 00          	call   2f2d <bitManipulation+0x2c>
    2f2d:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

	result = resetBit( testValue, 2 );
    2f30:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    2f33:	be 02 00 00 00          	mov    esi,0x2
    2f38:	89 c7                   	mov    edi,eax
    2f3a:	e8 00 00 00 00          	call   2f3f <bitManipulation+0x3e>
    2f3f:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
	result = setBit( result, 2 );
    2f42:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2f45:	be 02 00 00 00          	mov    esi,0x2
    2f4a:	89 c7                   	mov    edi,eax
    2f4c:	e8 00 00 00 00          	call   2f51 <bitManipulation+0x50>
    2f51:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

	const byte mostSignificantBit  = 31;
    2f54:	c6 45 f3 1f             	mov    BYTE PTR [rbp-0xd],0x1f
	const byte leastSignificantBit = 0;
    2f58:	c6 45 f2 00             	mov    BYTE PTR [rbp-0xe],0x0

	// negatif ?
	result = setBit( result, mostSignificantBit );
    2f5c:	0f b6 55 f3             	movzx  edx,BYTE PTR [rbp-0xd]
    2f60:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2f63:	89 d6                   	mov    esi,edx
    2f65:	89 c7                   	mov    edi,eax
    2f67:	e8 00 00 00 00          	call   2f6c <bitManipulation+0x6b>
    2f6c:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
	result = setBit( result, leastSignificantBit );
    2f6f:	0f b6 55 f2             	movzx  edx,BYTE PTR [rbp-0xe]
    2f73:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2f76:	89 d6                   	mov    esi,edx
    2f78:	89 c7                   	mov    edi,eax
    2f7a:	e8 00 00 00 00          	call   2f7f <bitManipulation+0x7e>
    2f7f:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

	result = resetBit( result, leastSignificantBit );
    2f82:	0f b6 55 f2             	movzx  edx,BYTE PTR [rbp-0xe]
    2f86:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2f89:	89 d6                   	mov    esi,edx
    2f8b:	89 c7                   	mov    edi,eax
    2f8d:	e8 00 00 00 00          	call   2f92 <bitManipulation+0x91>
    2f92:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
	result = resetBit( result, mostSignificantBit );
    2f95:	0f b6 55 f3             	movzx  edx,BYTE PTR [rbp-0xd]
    2f99:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    2f9c:	89 d6                   	mov    esi,edx
    2f9e:	89 c7                   	mov    edi,eax
    2fa0:	e8 00 00 00 00          	call   2fa5 <bitManipulation+0xa4>
    2fa5:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

	int a = 3;
    2fa8:	c7 45 e4 03 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x3
	int b = 5;
    2faf:	c7 45 e0 05 00 00 00    	mov    DWORD PTR [rbp-0x20],0x5
	xorSwap( &a, &b );
    2fb6:	48 8d 55 e0             	lea    rdx,[rbp-0x20]
    2fba:	48 8d 45 e4             	lea    rax,[rbp-0x1c]
    2fbe:	48 89 d6                	mov    rsi,rdx
    2fc1:	48 89 c7                	mov    rdi,rax
    2fc4:	e8 00 00 00 00          	call   2fc9 <bitManipulation+0xc8>

	xorIsNonDestructiveOperation();
    2fc9:	e8 00 00 00 00          	call   2fce <bitManipulation+0xcd>

	result = getLowNibble( 221 );
    2fce:	bf dd 00 00 00          	mov    edi,0xdd
    2fd3:	e8 00 00 00 00          	call   2fd8 <bitManipulation+0xd7>
    2fd8:	0f b6 c0                	movzx  eax,al
    2fdb:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
	result = getHighNibble( 221 );
    2fde:	bf dd 00 00 00          	mov    edi,0xdd
    2fe3:	e8 00 00 00 00          	call   2fe8 <bitManipulation+0xe7>
    2fe8:	0f b6 c0                	movzx  eax,al
    2feb:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

	result = getLowNibble( 13 );
    2fee:	bf 0d 00 00 00          	mov    edi,0xd
    2ff3:	e8 00 00 00 00          	call   2ff8 <bitManipulation+0xf7>
    2ff8:	0f b6 c0                	movzx  eax,al
    2ffb:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
	result = getHighNibble( 208 );
    2ffe:	bf d0 00 00 00          	mov    edi,0xd0
    3003:	e8 00 00 00 00          	call   3008 <bitManipulation+0x107>
    3008:	0f b6 c0                	movzx  eax,al
    300b:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

	float fA = 2.99F;
    300e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3016 <bitManipulation+0x115>
    3016:	f3 0f 11 45 ec          	movss  DWORD PTR [rbp-0x14],xmm0
	float fB = 1.99F;
    301b:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3023 <bitManipulation+0x122>
    3023:	f3 0f 11 45 e8          	movss  DWORD PTR [rbp-0x18],xmm0
	//result = fA & fB; // error invalid operands

}//bitManipulation
    3028:	90                      	nop
    3029:	c9                      	leave  
    302a:	c3                      	ret    

000000000000302b <bitFields>:
     unsigned track         : 9;
     unsigned sector        : 5;
     unsigned command       : 5;
} DiskRegister;

void bitFields( void ) {
    302b:	55                      	push   rbp
    302c:	48 89 e5                	mov    rbp,rsp

	int size = 0;
    302f:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
	size = sizeof(FancyChar);
    3036:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
    size = sizeof(Minireal);
    303d:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [rbp-0x4],0x4
    size = sizeof(DiskRegister);
    3044:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [rbp-0x4],0x4

    // blinking underlined red "A"
    FancyChar character = { 'A',red, true, true };
    304b:	0f b7 05 00 00 00 00    	movzx  eax,WORD PTR [rip+0x0]        # 3052 <bitFields+0x27>
    3052:	66 89 45 fa             	mov    WORD PTR [rbp-0x6],ax

    character.underline = false;
    3056:	0f b6 45 fb             	movzx  eax,BYTE PTR [rbp-0x5]
    305a:	83 e0 ef                	and    eax,0xffffffef
    305d:	88 45 fb                	mov    BYTE PTR [rbp-0x5],al
    character.blink     = false;
    3060:	0f b6 45 fb             	movzx  eax,BYTE PTR [rbp-0x5]
    3064:	83 e0 df                	and    eax,0xffffffdf
    3067:	88 45 fb                	mov    BYTE PTR [rbp-0x5],al

	// +2345.678
	Minireal real = { 0, 2345, 1 };
    306a:	0f b7 45 f4             	movzx  eax,WORD PTR [rbp-0xc]
    306e:	66 25 00 fc             	and    ax,0xfc00
    3072:	66 89 45 f4             	mov    WORD PTR [rbp-0xc],ax
    3076:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    3079:	25 ff 03 00 80          	and    eax,0x800003ff
    307e:	0d 00 a4 24 00          	or     eax,0x24a400
    3083:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
    3086:	0f b6 45 f7             	movzx  eax,BYTE PTR [rbp-0x9]
    308a:	83 c8 80                	or     eax,0xffffff80
    308d:	88 45 f7                	mov    BYTE PTR [rbp-0x9],al

	// -1234.567
	real.sign     = 1;
    3090:	0f b6 45 f7             	movzx  eax,BYTE PTR [rbp-0x9]
    3094:	83 c8 80                	or     eax,0xffffff80
    3097:	88 45 f7                	mov    BYTE PTR [rbp-0x9],al
	real.decimal  = 2345;
    309a:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    309d:	25 ff 03 00 80          	and    eax,0x800003ff
    30a2:	0d 00 a4 24 00          	or     eax,0x24a400
    30a7:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
	real.fraction = 0;
    30aa:	0f b7 45 f4             	movzx  eax,WORD PTR [rbp-0xc]
    30ae:	66 25 00 fc             	and    ax,0xfc00
    30b2:	66 89 45 f4             	mov    WORD PTR [rbp-0xc],ax

}//bitFields
    30b6:	90                      	nop
    30b7:	5d                      	pop    rbp
    30b8:	c3                      	ret    

00000000000030b9 <swap>:

//-----------------------------------------------------------------------------

// fast executing small function ( gcc -std=c99 )
static inline void swap( int *x, int *y ) {
    30b9:	55                      	push   rbp
    30ba:	48 89 e5                	mov    rbp,rsp
    30bd:	48 89 7d f8             	mov    QWORD PTR [rbp-0x8],rdi
    30c1:	48 89 75 f0             	mov    QWORD PTR [rbp-0x10],rsi

    if ( x == y )
    30c5:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    30c9:	48 3b 45 f0             	cmp    rax,QWORD PTR [rbp-0x10]
    30cd:	74 3e                   	je     310d <swap+0x54>
    	return;

   *x ^= *y;
    30cf:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    30d3:	8b 10                   	mov    edx,DWORD PTR [rax]
    30d5:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    30d9:	8b 00                   	mov    eax,DWORD PTR [rax]
    30db:	31 c2                   	xor    edx,eax
    30dd:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    30e1:	89 10                   	mov    DWORD PTR [rax],edx
	*y ^= *x;
    30e3:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    30e7:	8b 10                   	mov    edx,DWORD PTR [rax]
    30e9:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    30ed:	8b 00                   	mov    eax,DWORD PTR [rax]
    30ef:	31 c2                   	xor    edx,eax
    30f1:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    30f5:	89 10                   	mov    DWORD PTR [rax],edx
	*x ^= *y;
    30f7:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    30fb:	8b 10                   	mov    edx,DWORD PTR [rax]
    30fd:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    3101:	8b 00                   	mov    eax,DWORD PTR [rax]
    3103:	31 c2                   	xor    edx,eax
    3105:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    3109:	89 10                   	mov    DWORD PTR [rax],edx
    310b:	eb 01                   	jmp    310e <swap+0x55>
    	return;
    310d:	90                      	nop

}//swap
    310e:	5d                      	pop    rbp
    310f:	c3                      	ret    

0000000000003110 <targetFound>:

//-----------------------------------------------------------------------------

void targetFound( void ) {
    3110:	55                      	push   rbp
    3111:	48 89 e5                	mov    rbp,rsp
   printf( "Target value found." );
    3114:	48 8d 3d 00 00 00 00    	lea    rdi,[rip+0x0]        # 311b <targetFound+0xb>
    311b:	b8 00 00 00 00          	mov    eax,0x0
    3120:	e8 00 00 00 00          	call   3125 <targetFound+0x15>
}//targetFound
    3125:	90                      	nop
    3126:	5d                      	pop    rbp
    3127:	c3                      	ret    

0000000000003128 <goodGotosAlwaysBranchesForward>:

void goodGotosAlwaysBranchesForward() {
    3128:	55                      	push   rbp
    3129:	48 89 e5                	mov    rbp,rsp
    312c:	48 81 ec 90 00 00 00    	sub    rsp,0x90

	static const int meaningOfLife       = 42;
	static const unsigned int largePrime = 2147483647;

	int values[ 2 ][ 3 ][ 4 ] = {
    3133:	c7 85 70 ff ff ff 6f 00 	mov    DWORD PTR [rbp-0x90],0x6f
    313b:	00 00 
    313d:	c7 85 74 ff ff ff 70 00 	mov    DWORD PTR [rbp-0x8c],0x70
    3145:	00 00 
    3147:	c7 85 78 ff ff ff 71 00 	mov    DWORD PTR [rbp-0x88],0x71
    314f:	00 00 
    3151:	c7 85 7c ff ff ff 72 00 	mov    DWORD PTR [rbp-0x84],0x72
    3159:	00 00 
    315b:	c7 45 80 79 00 00 00    	mov    DWORD PTR [rbp-0x80],0x79
    3162:	c7 45 84 7a 00 00 00    	mov    DWORD PTR [rbp-0x7c],0x7a
    3169:	c7 45 88 7b 00 00 00    	mov    DWORD PTR [rbp-0x78],0x7b
    3170:	c7 45 8c 7c 00 00 00    	mov    DWORD PTR [rbp-0x74],0x7c
    3177:	c7 45 90 83 00 00 00    	mov    DWORD PTR [rbp-0x70],0x83
    317e:	c7 45 94 84 00 00 00    	mov    DWORD PTR [rbp-0x6c],0x84
    3185:	c7 45 98 85 00 00 00    	mov    DWORD PTR [rbp-0x68],0x85
    318c:	c7 45 9c 86 00 00 00    	mov    DWORD PTR [rbp-0x64],0x86
    3193:	c7 45 a0 d3 00 00 00    	mov    DWORD PTR [rbp-0x60],0xd3
    319a:	c7 45 a4 d4 00 00 00    	mov    DWORD PTR [rbp-0x5c],0xd4
    31a1:	c7 45 a8 d5 00 00 00    	mov    DWORD PTR [rbp-0x58],0xd5
    31a8:	c7 45 ac d6 00 00 00    	mov    DWORD PTR [rbp-0x54],0xd6
    31af:	c7 45 b0 dd 00 00 00    	mov    DWORD PTR [rbp-0x50],0xdd
    31b6:	c7 45 b4 de 00 00 00    	mov    DWORD PTR [rbp-0x4c],0xde
    31bd:	c7 45 b8 df 00 00 00    	mov    DWORD PTR [rbp-0x48],0xdf
    31c4:	c7 45 bc e0 00 00 00    	mov    DWORD PTR [rbp-0x44],0xe0
    31cb:	c7 45 c0 e7 00 00 00    	mov    DWORD PTR [rbp-0x40],0xe7
    31d2:	c7 45 c4 e8 00 00 00    	mov    DWORD PTR [rbp-0x3c],0xe8
    31d9:	c7 45 c8 e9 00 00 00    	mov    DWORD PTR [rbp-0x38],0xe9
    31e0:	c7 45 cc ea 00 00 00    	mov    DWORD PTR [rbp-0x34],0xea
		{
			{211, 212, 213, 214}, {221, 222, 223, 224}, {231, 232, 233, 234}
		}
	};

	const int sizeI = 4;
    31e7:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [rbp-0x10],0x4
	const int sizeJ = 3;
    31ee:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
	const int sizeK = 2;
    31f5:	c7 45 e8 02 00 00 00    	mov    DWORD PTR [rbp-0x18],0x2

	void *buffer = malloc( sizeof(values) );
    31fc:	bf 60 00 00 00          	mov    edi,0x60
    3201:	e8 00 00 00 00          	call   3206 <goodGotosAlwaysBranchesForward+0xde>
    3206:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == meaningOfLife )
    320a:	e8 00 00 00 00          	call   320f <goodGotosAlwaysBranchesForward+0xe7>
    320f:	8b 15 00 00 00 00       	mov    edx,DWORD PTR [rip+0x0]        # 3215 <goodGotosAlwaysBranchesForward+0xed>
    3215:	39 d0                   	cmp    eax,edx
    3217:	0f 84 a1 00 00 00       	je     32be <goodGotosAlwaysBranchesForward+0x196>
	    goto CLEANUP;

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == largePrime )
    321d:	e8 00 00 00 00          	call   3222 <goodGotosAlwaysBranchesForward+0xfa>
    3222:	8b 15 00 00 00 00       	mov    edx,DWORD PTR [rip+0x0]        # 3228 <goodGotosAlwaysBranchesForward+0x100>
    3228:	39 d0                   	cmp    eax,edx
    322a:	0f 84 91 00 00 00       	je     32c1 <goodGotosAlwaysBranchesForward+0x199>
	    goto CLEANUP;

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == NULL )
    3230:	e8 00 00 00 00          	call   3235 <goodGotosAlwaysBranchesForward+0x10d>
    3235:	85 c0                   	test   eax,eax
    3237:	0f 84 87 00 00 00       	je     32c4 <goodGotosAlwaysBranchesForward+0x19c>
	    goto CLEANUP;

	// bulunamadıysa aramaya devam
	int target = 222;
    323d:	c7 45 dc de 00 00 00    	mov    DWORD PTR [rbp-0x24],0xde
	for ( int k = 0; k < sizeK; k++ ) {
    3244:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
    324b:	eb 5f                   	jmp    32ac <goodGotosAlwaysBranchesForward+0x184>

		for ( int j = 0; j < sizeJ; j++ ) {
    324d:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
    3254:	eb 4a                   	jmp    32a0 <goodGotosAlwaysBranchesForward+0x178>

			for ( int i = 0; i < sizeI; i++ ) {
    3256:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
    325d:	eb 35                   	jmp    3294 <goodGotosAlwaysBranchesForward+0x16c>

				if ( target == values[ k ][ j ][ i ] )
    325f:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    3262:	48 63 c8                	movsxd rcx,eax
    3265:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3268:	48 63 d0                	movsxd rdx,eax
    326b:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    326e:	48 63 f0                	movsxd rsi,eax
    3271:	48 89 d0                	mov    rax,rdx
    3274:	48 01 c0                	add    rax,rax
    3277:	48 01 d0                	add    rax,rdx
    327a:	48 01 f0                	add    rax,rsi
    327d:	48 c1 e0 02             	shl    rax,0x2
    3281:	48 01 c8                	add    rax,rcx
    3284:	8b 84 85 70 ff ff ff    	mov    eax,DWORD PTR [rbp+rax*4-0x90]
    328b:	39 45 dc                	cmp    DWORD PTR [rbp-0x24],eax
    328e:	74 26                   	je     32b6 <goodGotosAlwaysBranchesForward+0x18e>
			for ( int i = 0; i < sizeI; i++ ) {
    3290:	83 45 f4 01             	add    DWORD PTR [rbp-0xc],0x1
    3294:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    3297:	3b 45 f0                	cmp    eax,DWORD PTR [rbp-0x10]
    329a:	7c c3                   	jl     325f <goodGotosAlwaysBranchesForward+0x137>
		for ( int j = 0; j < sizeJ; j++ ) {
    329c:	83 45 f8 01             	add    DWORD PTR [rbp-0x8],0x1
    32a0:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    32a3:	3b 45 ec                	cmp    eax,DWORD PTR [rbp-0x14]
    32a6:	7c ae                   	jl     3256 <goodGotosAlwaysBranchesForward+0x12e>
	for ( int k = 0; k < sizeK; k++ ) {
    32a8:	83 45 fc 01             	add    DWORD PTR [rbp-0x4],0x1
    32ac:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    32af:	3b 45 e8                	cmp    eax,DWORD PTR [rbp-0x18]
    32b2:	7c 99                   	jl     324d <goodGotosAlwaysBranchesForward+0x125>

		}//forj

	}//fork

   goto CLEANUP;
    32b4:	eb 0f                   	jmp    32c5 <goodGotosAlwaysBranchesForward+0x19d>
				   goto MULTIBREAK;
    32b6:	90                      	nop

MULTIBREAK:

   targetFound();
    32b7:	e8 00 00 00 00          	call   32bc <goodGotosAlwaysBranchesForward+0x194>
    32bc:	eb 07                   	jmp    32c5 <goodGotosAlwaysBranchesForward+0x19d>
	    goto CLEANUP;
    32be:	90                      	nop
    32bf:	eb 04                   	jmp    32c5 <goodGotosAlwaysBranchesForward+0x19d>
	    goto CLEANUP;
    32c1:	90                      	nop
    32c2:	eb 01                   	jmp    32c5 <goodGotosAlwaysBranchesForward+0x19d>
	    goto CLEANUP;
    32c4:	90                      	nop

CLEANUP:

	free( buffer );
    32c5:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    32c9:	48 89 c7                	mov    rdi,rax
    32cc:	e8 00 00 00 00          	call   32d1 <goodGotosAlwaysBranchesForward+0x1a9>

}//goodGotosAlwaysBranchesForward
    32d1:	90                      	nop
    32d2:	c9                      	leave  
    32d3:	c3                      	ret    

00000000000032d4 <functions_recursiveFunction>:

//-----------------------------------------------------------------------------

int recursionLimit = 16;
void functions_recursiveFunction( void ) {
    32d4:	55                      	push   rbp
    32d5:	48 89 e5                	mov    rbp,rsp

	if ( recursionLimit-- ) {
    32d8:	8b 05 00 00 00 00       	mov    eax,DWORD PTR [rip+0x0]        # 32de <functions_recursiveFunction+0xa>
    32de:	8d 50 ff                	lea    edx,[rax-0x1]
    32e1:	89 15 00 00 00 00       	mov    DWORD PTR [rip+0x0],edx        # 32e7 <functions_recursiveFunction+0x13>
    32e7:	85 c0                   	test   eax,eax
    32e9:	74 05                   	je     32f0 <functions_recursiveFunction+0x1c>
		functions_recursiveFunction();
    32eb:	e8 00 00 00 00          	call   32f0 <functions_recursiveFunction+0x1c>
	}

}//functions_recursiveFunction
    32f0:	90                      	nop
    32f1:	5d                      	pop    rbp
    32f2:	c3                      	ret    

00000000000032f3 <functions_recursiveFactorial>:

long long int functions_recursiveFactorial( long long int number ) {
    32f3:	55                      	push   rbp
    32f4:	48 89 e5                	mov    rbp,rsp
    32f7:	48 83 ec 10             	sub    rsp,0x10
    32fb:	48 89 7d f8             	mov    QWORD PTR [rbp-0x8],rdi
	} else {
	   return number * functions_recursiveFactorial( number - 1 );
	}
    */

	return number == 0 ? 1 : number * functions_recursiveFactorial( number - 1 );
    32ff:	48 83 7d f8 00          	cmp    QWORD PTR [rbp-0x8],0x0
    3304:	74 17                   	je     331d <functions_recursiveFactorial+0x2a>
    3306:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    330a:	48 83 e8 01             	sub    rax,0x1
    330e:	48 89 c7                	mov    rdi,rax
    3311:	e8 00 00 00 00          	call   3316 <functions_recursiveFactorial+0x23>
    3316:	48 0f af 45 f8          	imul   rax,QWORD PTR [rbp-0x8]
    331b:	eb 05                   	jmp    3322 <functions_recursiveFactorial+0x2f>
    331d:	b8 01 00 00 00          	mov    eax,0x1

}//functions_recursionFactorial
    3322:	c9                      	leave  
    3323:	c3                      	ret    

0000000000003324 <functions_sum>:

//-----------------------------------------------------------------------------

long long int functions_sum( int argc, ... ) {
    3324:	55                      	push   rbp
    3325:	48 89 e5                	mov    rbp,rsp
    3328:	48 83 ec 78             	sub    rsp,0x78
    332c:	89 bd 1c ff ff ff       	mov    DWORD PTR [rbp-0xe4],edi
    3332:	48 89 b5 58 ff ff ff    	mov    QWORD PTR [rbp-0xa8],rsi
    3339:	48 89 95 60 ff ff ff    	mov    QWORD PTR [rbp-0xa0],rdx
    3340:	48 89 8d 68 ff ff ff    	mov    QWORD PTR [rbp-0x98],rcx
    3347:	4c 89 85 70 ff ff ff    	mov    QWORD PTR [rbp-0x90],r8
    334e:	4c 89 8d 78 ff ff ff    	mov    QWORD PTR [rbp-0x88],r9
    3355:	84 c0                   	test   al,al
    3357:	74 20                   	je     3379 <functions_sum+0x55>
    3359:	0f 29 45 80             	movaps XMMWORD PTR [rbp-0x80],xmm0
    335d:	0f 29 4d 90             	movaps XMMWORD PTR [rbp-0x70],xmm1
    3361:	0f 29 55 a0             	movaps XMMWORD PTR [rbp-0x60],xmm2
    3365:	0f 29 5d b0             	movaps XMMWORD PTR [rbp-0x50],xmm3
    3369:	0f 29 65 c0             	movaps XMMWORD PTR [rbp-0x40],xmm4
    336d:	0f 29 6d d0             	movaps XMMWORD PTR [rbp-0x30],xmm5
    3371:	0f 29 75 e0             	movaps XMMWORD PTR [rbp-0x20],xmm6
    3375:	0f 29 7d f0             	movaps XMMWORD PTR [rbp-0x10],xmm7

	long long int sum = 0;
    3379:	48 c7 85 48 ff ff ff 00 	mov    QWORD PTR [rbp-0xb8],0x0
    3381:	00 00 00 
	va_list valist;

	// initialize macro
	va_start( valist, argc );
    3384:	c7 85 28 ff ff ff 08 00 	mov    DWORD PTR [rbp-0xd8],0x8
    338c:	00 00 
    338e:	c7 85 2c ff ff ff 30 00 	mov    DWORD PTR [rbp-0xd4],0x30
    3396:	00 00 
    3398:	48 8d 45 10             	lea    rax,[rbp+0x10]
    339c:	48 89 85 30 ff ff ff    	mov    QWORD PTR [rbp-0xd0],rax
    33a3:	48 8d 85 50 ff ff ff    	lea    rax,[rbp-0xb0]
    33aa:	48 89 85 38 ff ff ff    	mov    QWORD PTR [rbp-0xc8],rax

	for ( int i = 0; i < argc; i++)
    33b1:	c7 85 44 ff ff ff 00 00 	mov    DWORD PTR [rbp-0xbc],0x0
    33b9:	00 00 
    33bb:	eb 52                   	jmp    340f <functions_sum+0xeb>
	{
	   sum += va_arg( valist, int );
    33bd:	8b 85 28 ff ff ff       	mov    eax,DWORD PTR [rbp-0xd8]
    33c3:	83 f8 2f                	cmp    eax,0x2f
    33c6:	77 23                   	ja     33eb <functions_sum+0xc7>
    33c8:	48 8b 85 38 ff ff ff    	mov    rax,QWORD PTR [rbp-0xc8]
    33cf:	8b 95 28 ff ff ff       	mov    edx,DWORD PTR [rbp-0xd8]
    33d5:	89 d2                   	mov    edx,edx
    33d7:	48 01 d0                	add    rax,rdx
    33da:	8b 95 28 ff ff ff       	mov    edx,DWORD PTR [rbp-0xd8]
    33e0:	83 c2 08                	add    edx,0x8
    33e3:	89 95 28 ff ff ff       	mov    DWORD PTR [rbp-0xd8],edx
    33e9:	eb 12                   	jmp    33fd <functions_sum+0xd9>
    33eb:	48 8b 85 30 ff ff ff    	mov    rax,QWORD PTR [rbp-0xd0]
    33f2:	48 8d 50 08             	lea    rdx,[rax+0x8]
    33f6:	48 89 95 30 ff ff ff    	mov    QWORD PTR [rbp-0xd0],rdx
    33fd:	8b 00                   	mov    eax,DWORD PTR [rax]
    33ff:	48 98                   	cdqe   
    3401:	48 01 85 48 ff ff ff    	add    QWORD PTR [rbp-0xb8],rax
	for ( int i = 0; i < argc; i++)
    3408:	83 85 44 ff ff ff 01    	add    DWORD PTR [rbp-0xbc],0x1
    340f:	8b 85 44 ff ff ff       	mov    eax,DWORD PTR [rbp-0xbc]
    3415:	3b 85 1c ff ff ff       	cmp    eax,DWORD PTR [rbp-0xe4]
    341b:	7c a0                   	jl     33bd <functions_sum+0x99>
	}

	// clean valist left overs
	va_end( valist );

	return sum;
    341d:	48 8b 85 48 ff ff ff    	mov    rax,QWORD PTR [rbp-0xb8]

}//functions_sum
    3424:	c9                      	leave  
    3425:	c3                      	ret    

0000000000003426 <unions>:
	MixCSI     mixCSI;
	FloatBits  bits;

} VeryMix;

void unions( void ) {
    3426:	55                      	push   rbp
    3427:	48 89 e5                	mov    rbp,rsp

   // left uninitialized
   FloatBits bits;
   size_t size = 0;
    342a:	48 c7 45 e8 00 00 00 00 	mov    QWORD PTR [rbp-0x18],0x0

   size = sizeof( bits );
    3432:	48 c7 45 e8 04 00 00 00 	mov    QWORD PTR [rbp-0x18],0x4

   bits.fv      = -3.14F;
    343a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3442 <unions+0x1c>
    3442:	f3 0f 11 45 d8          	movss  DWORD PTR [rbp-0x28],xmm0
   bits.bv.sign = 0;
    3447:	0f b6 45 db             	movzx  eax,BYTE PTR [rbp-0x25]
    344b:	83 e0 7f                	and    eax,0x7f
    344e:	88 45 db                	mov    BYTE PTR [rbp-0x25],al

   // initialize with zeros
   MixCSI mcsi = {};
    3451:	c7 45 d4 00 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x0
   mcsi.iValue = 0xFAFBFCFD;
    3458:	c7 45 d4 fd fc fb fa    	mov    DWORD PTR [rbp-0x2c],0xfafbfcfd

   size = sizeof( MixCSI );
    345f:	48 c7 45 e8 04 00 00 00 	mov    QWORD PTR [rbp-0x18],0x4

   char c = mcsi.cA;
    3467:	0f b6 45 d7             	movzx  eax,BYTE PTR [rbp-0x29]
    346b:	88 45 e7                	mov    BYTE PTR [rbp-0x19],al

   c = mcsi.cB;
    346e:	0f b6 45 d6             	movzx  eax,BYTE PTR [rbp-0x2a]
    3472:	88 45 e7                	mov    BYTE PTR [rbp-0x19],al
   c = mcsi.cC;
    3475:	0f b6 45 d5             	movzx  eax,BYTE PTR [rbp-0x2b]
    3479:	88 45 e7                	mov    BYTE PTR [rbp-0x19],al
   c = mcsi.cD;
    347c:	0f b6 45 d4             	movzx  eax,BYTE PTR [rbp-0x2c]
    3480:	88 45 e7                	mov    BYTE PTR [rbp-0x19],al

   int s =  mcsi.sL;
    3483:	0f b7 45 d4             	movzx  eax,WORD PTR [rbp-0x2c]
    3487:	98                      	cwde   
    3488:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax
   s =  mcsi.sH;
    348b:	0f b7 45 d6             	movzx  eax,WORD PTR [rbp-0x2a]
    348f:	98                      	cwde   
    3490:	89 45 e0                	mov    DWORD PTR [rbp-0x20],eax

   int i = mcsi.iValue;
    3493:	8b 45 d4                	mov    eax,DWORD PTR [rbp-0x2c]
    3496:	89 45 dc                	mov    DWORD PTR [rbp-0x24],eax

   mcsi.cD = 0xFF;
    3499:	c6 45 d4 ff             	mov    BYTE PTR [rbp-0x2c],0xff

   mcsi.sH = 0xF1F2;
    349d:	66 c7 45 d6 f2 f1       	mov    WORD PTR [rbp-0x2a],0xf1f2

   int loop = 4;
    34a3:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [rbp-0x4],0x4
   while ( loop-- )
    34aa:	eb 17                   	jmp    34c3 <unions+0x9d>
	  mcsi.car[ loop ] = 68 - loop;
    34ac:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    34af:	89 c2                   	mov    edx,eax
    34b1:	b8 44 00 00 00          	mov    eax,0x44
    34b6:	29 d0                   	sub    eax,edx
    34b8:	89 c2                   	mov    edx,eax
    34ba:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    34bd:	48 98                   	cdqe   
    34bf:	88 54 05 d4             	mov    BYTE PTR [rbp+rax*1-0x2c],dl
   while ( loop-- )
    34c3:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    34c6:	8d 50 ff                	lea    edx,[rax-0x1]
    34c9:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    34cc:	85 c0                   	test   eax,eax
    34ce:	75 dc                   	jne    34ac <unions+0x86>

   // initialize with zeros
   Mix mix = {};
    34d0:	48 c7 45 c0 00 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
    34d8:	48 c7 45 c8 00 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
   size = sizeof( Mix );
    34e0:	48 c7 45 e8 10 00 00 00 	mov    QWORD PTR [rbp-0x18],0x10

   mix.decimal = -3.14L;
    34e8:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 34ee <unions+0xc8>
    34ee:	db 7d c0                	fstp   TBYTE PTR [rbp-0x40]
   mix.decimal = LDBL_MAX;
    34f1:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 34f7 <unions+0xd1>
    34f7:	db 7d c0                	fstp   TBYTE PTR [rbp-0x40]

   loop = 12;
    34fa:	c7 45 fc 0c 00 00 00    	mov    DWORD PTR [rbp-0x4],0xc
   while ( loop-- )
    3501:	eb 17                   	jmp    351a <unions+0xf4>
	  mix.text[ loop ] = 80 - loop;
    3503:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3506:	89 c2                   	mov    edx,eax
    3508:	b8 50 00 00 00          	mov    eax,0x50
    350d:	29 d0                   	sub    eax,edx
    350f:	89 c2                   	mov    edx,eax
    3511:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3514:	48 98                   	cdqe   
    3516:	88 54 05 c0             	mov    BYTE PTR [rbp+rax*1-0x40],dl
   while ( loop-- )
    351a:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    351d:	8d 50 ff                	lea    edx,[rax-0x1]
    3520:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    3523:	85 c0                   	test   eax,eax
    3525:	75 dc                   	jne    3503 <unions+0xdd>


   // initialize with zeros
   VeryMix vmx = {};
    3527:	48 c7 45 b0 00 00 00 00 	mov    QWORD PTR [rbp-0x50],0x0
    352f:	48 c7 45 b8 00 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
   char* pc = (char*) &vmx;
    3537:	48 8d 45 b0             	lea    rax,[rbp-0x50]
    353b:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

   loop = sizeof( VeryMix );
    353f:	c7 45 fc 10 00 00 00    	mov    DWORD PTR [rbp-0x4],0x10
   while ( loop-- )
    3546:	eb 0f                   	jmp    3557 <unions+0x131>
	   *pc++ = 0;
    3548:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    354c:	48 8d 50 01             	lea    rdx,[rax+0x1]
    3550:	48 89 55 f0             	mov    QWORD PTR [rbp-0x10],rdx
    3554:	c6 00 00                	mov    BYTE PTR [rax],0x0
   while ( loop-- )
    3557:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    355a:	8d 50 ff                	lea    edx,[rax-0x1]
    355d:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    3560:	85 c0                   	test   eax,eax
    3562:	75 e4                   	jne    3548 <unions+0x122>

   vmx.mixCSI.cD = 65;
    3564:	c6 45 b0 41             	mov    BYTE PTR [rbp-0x50],0x41

}//unions
    3568:	90                      	nop
    3569:	5d                      	pop    rbp
    356a:	c3                      	ret    

000000000000356b <typePromotion>:

//-----------------------------------------------------------------------------

void typePromotion( void ) {
    356b:	55                      	push   rbp
    356c:	48 89 e5                	mov    rbp,rsp

	int   i =  1;
    356f:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [rbp-0x4],0x1
	float f =  0.10F;
    3576:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 357e <typePromotion+0x13>
    357e:	f3 0f 11 45 f8          	movss  DWORD PTR [rbp-0x8],xmm0
	float r =  0.00F;
    3583:	66 0f ef c0             	pxor   xmm0,xmm0
    3587:	f3 0f 11 45 f4          	movss  DWORD PTR [rbp-0xc],xmm0

	r = f + i;
    358c:	66 0f ef c0             	pxor   xmm0,xmm0
    3590:	f3 0f 2a 45 fc          	cvtsi2ss xmm0,DWORD PTR [rbp-0x4]
    3595:	f3 0f 10 4d f8          	movss  xmm1,DWORD PTR [rbp-0x8]
    359a:	f3 0f 58 c1             	addss  xmm0,xmm1
    359e:	f3 0f 11 45 f4          	movss  DWORD PTR [rbp-0xc],xmm0

	char  c  = 2;
    35a3:	c6 45 f3 02             	mov    BYTE PTR [rbp-0xd],0x2
	short s  = 3;
    35a7:	66 c7 45 f0 03 00       	mov    WORD PTR [rbp-0x10],0x3
	unsigned int u = 6;
    35ad:	c7 45 ec 06 00 00 00    	mov    DWORD PTR [rbp-0x14],0x6

	i = i + c;
    35b4:	0f be 45 f3             	movsx  eax,BYTE PTR [rbp-0xd]
    35b8:	01 45 fc                	add    DWORD PTR [rbp-0x4],eax

	i = i + s;
    35bb:	0f bf 45 f0             	movsx  eax,WORD PTR [rbp-0x10]
    35bf:	01 45 fc                	add    DWORD PTR [rbp-0x4],eax

	i = i + u;
    35c2:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    35c5:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    35c8:	01 d0                   	add    eax,edx
    35ca:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

	long long l = 1L + c;
    35cd:	48 0f be 45 f3          	movsx  rax,BYTE PTR [rbp-0xd]
    35d2:	48 83 c0 01             	add    rax,0x1
    35d6:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

}//typePromotion
    35da:	90                      	nop
    35db:	5d                      	pop    rbp
    35dc:	c3                      	ret    

00000000000035dd <typePromotionPromoteToInt>:

//-----------------------------------------------------------------------------

void typePromotionPromoteToInt( void ) {
    35dd:	55                      	push   rbp
    35de:	48 89 e5                	mov    rbp,rsp

	// see disassembly ( sign extend instructions )
	// all ranks lower than int (signed or unsigned), promote to int
	_Bool b =  false;
    35e1:	c6 45 ff 00             	mov    BYTE PTR [rbp-0x1],0x0
	char  c =  'a';
    35e5:	c6 45 fe 61             	mov    BYTE PTR [rbp-0x2],0x61
	short s =  -8;
    35e9:	66 c7 45 fc f8 ff       	mov    WORD PTR [rbp-0x4],0xfff8

	int r = 0;
    35ef:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
	int d = 1;
    35f6:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1
	d = b + b + b;
    35fd:	0f b6 55 ff             	movzx  edx,BYTE PTR [rbp-0x1]
    3601:	89 d0                   	mov    eax,edx
    3603:	01 c0                   	add    eax,eax
    3605:	01 d0                   	add    eax,edx
    3607:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

	r = b + c + s;
    360a:	0f b6 55 ff             	movzx  edx,BYTE PTR [rbp-0x1]
    360e:	0f be 45 fe             	movsx  eax,BYTE PTR [rbp-0x2]
    3612:	01 c2                   	add    edx,eax
    3614:	0f bf 45 fc             	movsx  eax,WORD PTR [rbp-0x4]
    3618:	01 d0                   	add    eax,edx
    361a:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

}//typePromotionPromoteToInt
    361d:	90                      	nop
    361e:	5d                      	pop    rbp
    361f:	c3                      	ret    

0000000000003620 <typePromotionPromoteToInt2>:

//-----------------------------------------------------------------------------

void typePromotionPromoteToInt2( void ) {
    3620:	55                      	push   rbp
    3621:	48 89 e5                	mov    rbp,rsp

	// see disassembly ( sign extend instructions )
	// all ranks lower than int (signed or unsigned), promote to int

	short s1 = -5;
    3624:	66 c7 45 fe fb ff       	mov    WORD PTR [rbp-0x2],0xfffb
	short s2 = 3;
    362a:	66 c7 45 fc 03 00       	mov    WORD PTR [rbp-0x4],0x3

	s2 = -s2;
    3630:	0f b7 45 fc             	movzx  eax,WORD PTR [rbp-0x4]
    3634:	f7 d8                   	neg    eax
    3636:	66 89 45 fc             	mov    WORD PTR [rbp-0x4],ax
	s1 = s1 + s2;
    363a:	0f b7 55 fe             	movzx  edx,WORD PTR [rbp-0x2]
    363e:	0f b7 45 fc             	movzx  eax,WORD PTR [rbp-0x4]
    3642:	01 d0                   	add    eax,edx
    3644:	66 89 45 fe             	mov    WORD PTR [rbp-0x2],ax

	int r = s1 + s1;
    3648:	0f bf 45 fe             	movsx  eax,WORD PTR [rbp-0x2]
    364c:	01 c0                   	add    eax,eax
    364e:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

	r = s1 + s2;
    3651:	0f bf 55 fe             	movsx  edx,WORD PTR [rbp-0x2]
    3655:	0f bf 45 fc             	movsx  eax,WORD PTR [rbp-0x4]
    3659:	01 d0                   	add    eax,edx
    365b:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

}//typePromotionPromoteToInt2
    365e:	90                      	nop
    365f:	5d                      	pop    rbp
    3660:	c3                      	ret    

0000000000003661 <typePromotionSameWidth>:

//-----------------------------------------------------------------------------

void typePromotionSameWidth( void ) {
    3661:	55                      	push   rbp
    3662:	48 89 e5                	mov    rbp,rsp

	// see disassembly
	// same size (representation) different rank
	signed   int negativeOne =  -1;
    3665:	c7 45 fc ff ff ff ff    	mov    DWORD PTR [rbp-0x4],0xffffffff
	unsigned int positiveOne =  +1;
    366c:	c7 45 f8 01 00 00 00    	mov    DWORD PTR [rbp-0x8],0x1

	_Bool result = false;
    3673:	c6 45 f7 00             	mov    BYTE PTR [rbp-0x9],0x0

	result = positiveOne < negativeOne;
    3677:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    367a:	39 45 f8                	cmp    DWORD PTR [rbp-0x8],eax
    367d:	0f 92 c0                	setb   al
    3680:	88 45 f7                	mov    BYTE PTR [rbp-0x9],al

}//typePromotionSameWidth
    3683:	90                      	nop
    3684:	5d                      	pop    rbp
    3685:	c3                      	ret    

0000000000003686 <evaluationOrderA>:

//-----------------------------------------------------------------------------

void evaluationOrderA( void ) {
    3686:	55                      	push   rbp
    3687:	48 89 e5                	mov    rbp,rsp

	// see disassembly
   int a = 1;
    368a:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [rbp-0x4],0x1
   int b = 2;
    3691:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [rbp-0x8],0x2
   int c = 3;
    3698:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
   int d = 4;
    369f:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [rbp-0x10],0x4

   d = a + b - c + 3;
    36a6:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    36a9:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    36ac:	01 d0                   	add    eax,edx
    36ae:	2b 45 f4                	sub    eax,DWORD PTR [rbp-0xc]
    36b1:	83 c0 03                	add    eax,0x3
    36b4:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax

}//evaluationOrderA
    36b7:	90                      	nop
    36b8:	5d                      	pop    rbp
    36b9:	c3                      	ret    

00000000000036ba <evaluationOrderB>:

//-----------------------------------------------------------------------------

void evaluationOrderB( void ) {
    36ba:	55                      	push   rbp
    36bb:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int a = 1;
    36be:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [rbp-0x4],0x1
   int b = 2;
    36c5:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [rbp-0x8],0x2
   int c = 3;
    36cc:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
   int d = 4;
    36d3:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [rbp-0x10],0x4

   d = a + b * c + 3;
    36da:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    36dd:	0f af 45 f4             	imul   eax,DWORD PTR [rbp-0xc]
    36e1:	89 c2                   	mov    edx,eax
    36e3:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    36e6:	01 d0                   	add    eax,edx
    36e8:	83 c0 03                	add    eax,0x3
    36eb:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax

}//evaluationOrderB
    36ee:	90                      	nop
    36ef:	5d                      	pop    rbp
    36f0:	c3                      	ret    

00000000000036f1 <evaluationOrderC>:

//-----------------------------------------------------------------------------

void evaluationOrderC( void ) {
    36f1:	55                      	push   rbp
    36f2:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int a = 1;
    36f5:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [rbp-0x4],0x1
   int b = 2;
    36fc:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [rbp-0x8],0x2
   int c = 3;
    3703:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
   int d = 4;
    370a:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [rbp-0x10],0x4

   d = a = b = c = 5;
    3711:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [rbp-0xc],0x5
    3718:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    371b:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax
    371e:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    3721:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
    3724:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3727:	89 45 f0                	mov    DWORD PTR [rbp-0x10],eax

}//evaluationOrderC
    372a:	90                      	nop
    372b:	5d                      	pop    rbp
    372c:	c3                      	ret    

000000000000372d <division>:

//-----------------------------------------------------------------------------

void division( void ) {
    372d:	55                      	push   rbp
    372e:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int a = 5;
    3731:	c7 45 fc 05 00 00 00    	mov    DWORD PTR [rbp-0x4],0x5
   int b = 2;
    3738:	c7 45 f8 02 00 00 00    	mov    DWORD PTR [rbp-0x8],0x2

   unsigned int ua = 5;
    373f:	c7 45 f4 05 00 00 00    	mov    DWORD PTR [rbp-0xc],0x5
   unsigned int ub = 2;
    3746:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [rbp-0x10],0x2

   int          ir = 0;
    374d:	c7 45 ec 00 00 00 00    	mov    DWORD PTR [rbp-0x14],0x0
   unsigned int ur = 0;
    3754:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [rbp-0x18],0x0
   float        fr = 0.0F;
    375b:	66 0f ef c0             	pxor   xmm0,xmm0
    375f:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0

   ir = a / b;
    3764:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3767:	99                      	cdq    
    3768:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
    376b:	89 45 ec                	mov    DWORD PTR [rbp-0x14],eax

   fr = a / b;
    376e:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3771:	99                      	cdq    
    3772:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
    3775:	66 0f ef c0             	pxor   xmm0,xmm0
    3779:	f3 0f 2a c0             	cvtsi2ss xmm0,eax
    377d:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0

   fr = (float)( a / b );
    3782:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3785:	99                      	cdq    
    3786:	f7 7d f8                	idiv   DWORD PTR [rbp-0x8]
    3789:	66 0f ef c0             	pxor   xmm0,xmm0
    378d:	f3 0f 2a c0             	cvtsi2ss xmm0,eax
    3791:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0

   fr = (float)a / b;
    3796:	66 0f ef c0             	pxor   xmm0,xmm0
    379a:	f3 0f 2a 45 fc          	cvtsi2ss xmm0,DWORD PTR [rbp-0x4]
    379f:	66 0f ef c9             	pxor   xmm1,xmm1
    37a3:	f3 0f 2a 4d f8          	cvtsi2ss xmm1,DWORD PTR [rbp-0x8]
    37a8:	f3 0f 5e c1             	divss  xmm0,xmm1
    37ac:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0

   fr = a / (float)b;
    37b1:	66 0f ef c0             	pxor   xmm0,xmm0
    37b5:	f3 0f 2a 45 fc          	cvtsi2ss xmm0,DWORD PTR [rbp-0x4]
    37ba:	66 0f ef c9             	pxor   xmm1,xmm1
    37be:	f3 0f 2a 4d f8          	cvtsi2ss xmm1,DWORD PTR [rbp-0x8]
    37c3:	f3 0f 5e c1             	divss  xmm0,xmm1
    37c7:	f3 0f 11 45 e4          	movss  DWORD PTR [rbp-0x1c],xmm0

   ur = ua / ub;
    37cc:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    37cf:	ba 00 00 00 00          	mov    edx,0x0
    37d4:	f7 75 f0                	div    DWORD PTR [rbp-0x10]
    37d7:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

   ur = (float)ua / ub;
    37da:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    37dd:	48 85 c0                	test   rax,rax
    37e0:	78 0b                   	js     37ed <division+0xc0>
    37e2:	66 0f ef c0             	pxor   xmm0,xmm0
    37e6:	f3 48 0f 2a c0          	cvtsi2ss xmm0,rax
    37eb:	eb 19                   	jmp    3806 <division+0xd9>
    37ed:	48 89 c2                	mov    rdx,rax
    37f0:	48 d1 ea                	shr    rdx,1
    37f3:	83 e0 01                	and    eax,0x1
    37f6:	48 09 c2                	or     rdx,rax
    37f9:	66 0f ef c0             	pxor   xmm0,xmm0
    37fd:	f3 48 0f 2a c2          	cvtsi2ss xmm0,rdx
    3802:	f3 0f 58 c0             	addss  xmm0,xmm0
    3806:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    3809:	48 85 c0                	test   rax,rax
    380c:	78 0b                   	js     3819 <division+0xec>
    380e:	66 0f ef c9             	pxor   xmm1,xmm1
    3812:	f3 48 0f 2a c8          	cvtsi2ss xmm1,rax
    3817:	eb 19                   	jmp    3832 <division+0x105>
    3819:	48 89 c2                	mov    rdx,rax
    381c:	48 d1 ea                	shr    rdx,1
    381f:	83 e0 01                	and    eax,0x1
    3822:	48 09 c2                	or     rdx,rax
    3825:	66 0f ef c9             	pxor   xmm1,xmm1
    3829:	f3 48 0f 2a ca          	cvtsi2ss xmm1,rdx
    382e:	f3 0f 58 c9             	addss  xmm1,xmm1
    3832:	f3 0f 5e c1             	divss  xmm0,xmm1
    3836:	f3 48 0f 2c c0          	cvttss2si rax,xmm0
    383b:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

}//division
    383e:	90                      	nop
    383f:	5d                      	pop    rbp
    3840:	c3                      	ret    

0000000000003841 <modulus>:

//-----------------------------------------------------------------------------

void modulus( void ) {
    3841:	55                      	push   rbp
    3842:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   int r = 0;
    3845:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0

   r = +5 % 3;
    384c:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2
   r = -5 % 3;
    3853:	c7 45 fc fe ff ff ff    	mov    DWORD PTR [rbp-0x4],0xfffffffe
   r = +5 % -3;
    385a:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2

   r = +3 % 5;
    3861:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [rbp-0x4],0x3
   r = +3 % -5;
    3868:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [rbp-0x4],0x3

   r = (int)7.99F % 5;
    386f:	c7 45 fc 02 00 00 00    	mov    DWORD PTR [rbp-0x4],0x2

   int a = 5;
    3876:	c7 45 f8 05 00 00 00    	mov    DWORD PTR [rbp-0x8],0x5
   int b = 3;
    387d:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3

   r = +a % 3;
    3884:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    3887:	48 63 d0                	movsxd rdx,eax
    388a:	48 69 d2 56 55 55 55    	imul   rdx,rdx,0x55555556
    3891:	48 c1 ea 20             	shr    rdx,0x20
    3895:	89 c6                   	mov    esi,eax
    3897:	c1 fe 1f                	sar    esi,0x1f
    389a:	89 d1                   	mov    ecx,edx
    389c:	29 f1                   	sub    ecx,esi
    389e:	89 ca                   	mov    edx,ecx
    38a0:	01 d2                   	add    edx,edx
    38a2:	01 ca                   	add    edx,ecx
    38a4:	29 d0                   	sub    eax,edx
    38a6:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   r = -a % 3;
    38a9:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    38ac:	f7 d8                   	neg    eax
    38ae:	48 63 d0                	movsxd rdx,eax
    38b1:	48 69 d2 56 55 55 55    	imul   rdx,rdx,0x55555556
    38b8:	48 c1 ea 20             	shr    rdx,0x20
    38bc:	89 c1                   	mov    ecx,eax
    38be:	c1 f9 1f                	sar    ecx,0x1f
    38c1:	29 ca                   	sub    edx,ecx
    38c3:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    38c6:	8b 4d fc                	mov    ecx,DWORD PTR [rbp-0x4]
    38c9:	89 ca                   	mov    edx,ecx
    38cb:	01 d2                   	add    edx,edx
    38cd:	01 ca                   	add    edx,ecx
    38cf:	29 d0                   	sub    eax,edx
    38d1:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

   r = +a % -3;
    38d4:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    38d7:	48 63 d0                	movsxd rdx,eax
    38da:	48 69 d2 56 55 55 55    	imul   rdx,rdx,0x55555556
    38e1:	48 c1 ea 20             	shr    rdx,0x20
    38e5:	89 c6                   	mov    esi,eax
    38e7:	c1 fe 1f                	sar    esi,0x1f
    38ea:	89 d1                   	mov    ecx,edx
    38ec:	29 f1                   	sub    ecx,esi
    38ee:	89 ca                   	mov    edx,ecx
    38f0:	01 d2                   	add    edx,edx
    38f2:	01 ca                   	add    edx,ecx
    38f4:	29 d0                   	sub    eax,edx
    38f6:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax
   r = -a % -3;
    38f9:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    38fc:	f7 d8                   	neg    eax
    38fe:	48 63 d0                	movsxd rdx,eax
    3901:	48 69 d2 56 55 55 55    	imul   rdx,rdx,0x55555556
    3908:	48 c1 ea 20             	shr    rdx,0x20
    390c:	89 c1                   	mov    ecx,eax
    390e:	c1 f9 1f                	sar    ecx,0x1f
    3911:	29 ca                   	sub    edx,ecx
    3913:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    3916:	8b 4d fc                	mov    ecx,DWORD PTR [rbp-0x4]
    3919:	89 ca                   	mov    edx,ecx
    391b:	01 d2                   	add    edx,edx
    391d:	01 ca                   	add    edx,ecx
    391f:	29 d0                   	sub    eax,edx
    3921:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

}//modulus
    3924:	90                      	nop
    3925:	5d                      	pop    rbp
    3926:	c3                      	ret    

0000000000003927 <initializationOfVariables>:

//-----------------------------------------------------------------------------

void initializationOfVariables( void ) {
    3927:	55                      	push   rbp
    3928:	48 89 e5                	mov    rbp,rsp

   // see disassembly
   char           c = 'A';
    392b:	c6 45 ff 41             	mov    BYTE PTR [rbp-0x1],0x41
   unsigned char uc = 'B';
    392f:	c6 45 fe 42             	mov    BYTE PTR [rbp-0x2],0x42

   short          s  = 1;
    3933:	66 c7 45 fc 01 00       	mov    WORD PTR [rbp-0x4],0x1
   unsigned short us = 1;
    3939:	66 c7 45 fa 01 00       	mov    WORD PTR [rbp-0x6],0x1

   int          i  = 3;
    393f:	c7 45 f4 03 00 00 00    	mov    DWORD PTR [rbp-0xc],0x3
   unsigned int ui = 4;
    3946:	c7 45 f0 04 00 00 00    	mov    DWORD PTR [rbp-0x10],0x4

   long long          ll  = 5LL;
    394d:	48 c7 45 e8 05 00 00 00 	mov    QWORD PTR [rbp-0x18],0x5
   unsigned long long ull = 6ULL;
    3955:	48 c7 45 e0 06 00 00 00 	mov    QWORD PTR [rbp-0x20],0x6

   float       fA = 1.99F;
    395d:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3965 <initializationOfVariables+0x3e>
    3965:	f3 0f 11 45 dc          	movss  DWORD PTR [rbp-0x24],xmm0
   double      dB = 2.99;
    396a:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3972 <initializationOfVariables+0x4b>
    3972:	f2 0f 11 45 d0          	movsd  QWORD PTR [rbp-0x30],xmm0
   long double lC = 3.99L;
    3977:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 397d <initializationOfVariables+0x56>
    397d:	db 7d c0                	fstp   TBYTE PTR [rbp-0x40]


   i = c + 1;
    3980:	0f be 45 ff             	movsx  eax,BYTE PTR [rbp-0x1]
    3984:	83 c0 01                	add    eax,0x1
    3987:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   i = s + 1;
    398a:	0f bf 45 fc             	movsx  eax,WORD PTR [rbp-0x4]
    398e:	83 c0 01                	add    eax,0x1
    3991:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   i = i + 1;
    3994:	83 45 f4 01             	add    DWORD PTR [rbp-0xc],0x1

   i = uc + 1;
    3998:	0f b6 45 fe             	movzx  eax,BYTE PTR [rbp-0x2]
    399c:	83 c0 01                	add    eax,0x1
    399f:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   i = us + 1;
    39a2:	0f b7 45 fa             	movzx  eax,WORD PTR [rbp-0x6]
    39a6:	83 c0 01                	add    eax,0x1
    39a9:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
   i = ui + 1;
    39ac:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    39af:	83 c0 01                	add    eax,0x1
    39b2:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax

   fA = fA + i;
    39b5:	66 0f ef c0             	pxor   xmm0,xmm0
    39b9:	f3 0f 2a 45 f4          	cvtsi2ss xmm0,DWORD PTR [rbp-0xc]
    39be:	f3 0f 10 4d dc          	movss  xmm1,DWORD PTR [rbp-0x24]
    39c3:	f3 0f 58 c1             	addss  xmm0,xmm1
    39c7:	f3 0f 11 45 dc          	movss  DWORD PTR [rbp-0x24],xmm0
   dB = dB + 1.99;
    39cc:	f2 0f 10 4d d0          	movsd  xmm1,QWORD PTR [rbp-0x30]
    39d1:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 39d9 <initializationOfVariables+0xb2>
    39d9:	f2 0f 58 c1             	addsd  xmm0,xmm1
    39dd:	f2 0f 11 45 d0          	movsd  QWORD PTR [rbp-0x30],xmm0
   lC = fA + dB;
    39e2:	66 0f ef c0             	pxor   xmm0,xmm0
    39e6:	f3 0f 5a 45 dc          	cvtss2sd xmm0,DWORD PTR [rbp-0x24]
    39eb:	f2 0f 58 45 d0          	addsd  xmm0,QWORD PTR [rbp-0x30]
    39f0:	f2 0f 11 45 b8          	movsd  QWORD PTR [rbp-0x48],xmm0
    39f5:	dd 45 b8                	fld    QWORD PTR [rbp-0x48]
    39f8:	db 7d c0                	fstp   TBYTE PTR [rbp-0x40]

}//initializationOfVariables
    39fb:	90                      	nop
    39fc:	5d                      	pop    rbp
    39fd:	c3                      	ret    

00000000000039fe <initializationOfArrays>:

//-----------------------------------------------------------------------------

void initializationOfArrays( void ) {
    39fe:	55                      	push   rbp
    39ff:	48 89 e5                	mov    rbp,rsp
    3a02:	48 83 ec 78             	sub    rsp,0x78

   // see disassembly
   char carA[ 5 ] = "ABCD";
    3a06:	c7 45 cb 41 42 43 44    	mov    DWORD PTR [rbp-0x35],0x44434241
    3a0d:	c6 45 cf 00             	mov    BYTE PTR [rbp-0x31],0x0
   char carB[ 5 ] = {'A','B','C','D', 0 };
    3a11:	c7 45 c6 41 42 43 44    	mov    DWORD PTR [rbp-0x3a],0x44434241
    3a18:	c6 45 ca 00             	mov    BYTE PTR [rbp-0x36],0x0
   char c         = '\0';
    3a1c:	c6 45 ff 00             	mov    BYTE PTR [rbp-0x1],0x0

   int iar[ 5 ] = { 65, 66, 67, 68, 69 };
    3a20:	c7 45 b0 41 00 00 00    	mov    DWORD PTR [rbp-0x50],0x41
    3a27:	c7 45 b4 42 00 00 00    	mov    DWORD PTR [rbp-0x4c],0x42
    3a2e:	c7 45 b8 43 00 00 00    	mov    DWORD PTR [rbp-0x48],0x43
    3a35:	c7 45 bc 44 00 00 00    	mov    DWORD PTR [rbp-0x44],0x44
    3a3c:	c7 45 c0 45 00 00 00    	mov    DWORD PTR [rbp-0x40],0x45
   int i        = 0;
    3a43:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0

   float far[ 5 ] = { .1F, .2F, .3F, .4F, .5F };
    3a4a:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3a52 <initializationOfArrays+0x54>
    3a52:	f3 0f 11 45 90          	movss  DWORD PTR [rbp-0x70],xmm0
    3a57:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3a5f <initializationOfArrays+0x61>
    3a5f:	f3 0f 11 45 94          	movss  DWORD PTR [rbp-0x6c],xmm0
    3a64:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3a6c <initializationOfArrays+0x6e>
    3a6c:	f3 0f 11 45 98          	movss  DWORD PTR [rbp-0x68],xmm0
    3a71:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3a79 <initializationOfArrays+0x7b>
    3a79:	f3 0f 11 45 9c          	movss  DWORD PTR [rbp-0x64],xmm0
    3a7e:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3a86 <initializationOfArrays+0x88>
    3a86:	f3 0f 11 45 a0          	movss  DWORD PTR [rbp-0x60],xmm0
   float f        = .0F;
    3a8b:	66 0f ef c0             	pxor   xmm0,xmm0
    3a8f:	f3 0f 11 45 f4          	movss  DWORD PTR [rbp-0xc],xmm0

   double dar[ 5 ] = { .1, .2, .3, .4, .5 };
    3a94:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3a9c <initializationOfArrays+0x9e>
    3a9c:	f2 0f 11 85 60 ff ff ff 	movsd  QWORD PTR [rbp-0xa0],xmm0
    3aa4:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3aac <initializationOfArrays+0xae>
    3aac:	f2 0f 11 85 68 ff ff ff 	movsd  QWORD PTR [rbp-0x98],xmm0
    3ab4:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3abc <initializationOfArrays+0xbe>
    3abc:	f2 0f 11 85 70 ff ff ff 	movsd  QWORD PTR [rbp-0x90],xmm0
    3ac4:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3acc <initializationOfArrays+0xce>
    3acc:	f2 0f 11 85 78 ff ff ff 	movsd  QWORD PTR [rbp-0x88],xmm0
    3ad4:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3adc <initializationOfArrays+0xde>
    3adc:	f2 0f 11 45 80          	movsd  QWORD PTR [rbp-0x80],xmm0
   double d        = .0;
    3ae1:	66 0f ef c0             	pxor   xmm0,xmm0
    3ae5:	f2 0f 11 45 e8          	movsd  QWORD PTR [rbp-0x18],xmm0

   long double ldar[ 5 ] = { .1L, .2L, .3L, .4, .5L };
    3aea:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 3af0 <initializationOfArrays+0xf2>
    3af0:	db bd 10 ff ff ff       	fstp   TBYTE PTR [rbp-0xf0]
    3af6:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 3afc <initializationOfArrays+0xfe>
    3afc:	db bd 20 ff ff ff       	fstp   TBYTE PTR [rbp-0xe0]
    3b02:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 3b08 <initializationOfArrays+0x10a>
    3b08:	db bd 30 ff ff ff       	fstp   TBYTE PTR [rbp-0xd0]
    3b0e:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 3b14 <initializationOfArrays+0x116>
    3b14:	db bd 40 ff ff ff       	fstp   TBYTE PTR [rbp-0xc0]
    3b1a:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 3b20 <initializationOfArrays+0x122>
    3b20:	db bd 50 ff ff ff       	fstp   TBYTE PTR [rbp-0xb0]
   long double ld        = .0L;
    3b26:	d9 ee                   	fldz   
    3b28:	db 7d d0                	fstp   TBYTE PTR [rbp-0x30]

   iar[ 0 ] = 66;
    3b2b:	c7 45 b0 42 00 00 00    	mov    DWORD PTR [rbp-0x50],0x42
   i = iar[ 0 ];
    3b32:	8b 45 b0                	mov    eax,DWORD PTR [rbp-0x50]
    3b35:	89 45 f8                	mov    DWORD PTR [rbp-0x8],eax

   carA[ 0 ] = 97;
    3b38:	c6 45 cb 61             	mov    BYTE PTR [rbp-0x35],0x61
   c = carA[0];
    3b3c:	0f b6 45 cb             	movzx  eax,BYTE PTR [rbp-0x35]
    3b40:	88 45 ff                	mov    BYTE PTR [rbp-0x1],al

   far[ 0 ] = .2F;
    3b43:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3b4b <initializationOfArrays+0x14d>
    3b4b:	f3 0f 11 45 90          	movss  DWORD PTR [rbp-0x70],xmm0
   f = far[ 0 ];
    3b50:	f3 0f 10 45 90          	movss  xmm0,DWORD PTR [rbp-0x70]
    3b55:	f3 0f 11 45 f4          	movss  DWORD PTR [rbp-0xc],xmm0

   dar[ 0 ] = .2;
    3b5a:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3b62 <initializationOfArrays+0x164>
    3b62:	f2 0f 11 85 60 ff ff ff 	movsd  QWORD PTR [rbp-0xa0],xmm0
   d = dar[ 0 ];
    3b6a:	f2 0f 10 85 60 ff ff ff 	movsd  xmm0,QWORD PTR [rbp-0xa0]
    3b72:	f2 0f 11 45 e8          	movsd  QWORD PTR [rbp-0x18],xmm0

   ldar[ 0 ] = .2L;
    3b77:	db 2d 00 00 00 00       	fld    TBYTE PTR [rip+0x0]        # 3b7d <initializationOfArrays+0x17f>
    3b7d:	db bd 10 ff ff ff       	fstp   TBYTE PTR [rbp-0xf0]
   ld = dar[ 0 ];
    3b83:	dd 85 60 ff ff ff       	fld    QWORD PTR [rbp-0xa0]
    3b89:	db 7d d0                	fstp   TBYTE PTR [rbp-0x30]

}//initializationOfArrays
    3b8c:	90                      	nop
    3b8d:	c9                      	leave  
    3b8e:	c3                      	ret    

0000000000003b8f <f>:

//-----------------------------------------------------------------------------

int f( void ) { return 3; }
    3b8f:	55                      	push   rbp
    3b90:	48 89 e5                	mov    rbp,rsp
    3b93:	b8 03 00 00 00          	mov    eax,0x3
    3b98:	5d                      	pop    rbp
    3b99:	c3                      	ret    

0000000000003b9a <expressionEvaluationOrder>:

void expressionEvaluationOrder( void ) {
    3b9a:	55                      	push   rbp
    3b9b:	48 89 e5                	mov    rbp,rsp
    3b9e:	48 83 ec 10             	sub    rsp,0x10

	// see disassembly
	int a = 0;
    3ba2:	c7 45 fc 00 00 00 00    	mov    DWORD PTR [rbp-0x4],0x0
	int b = 0;
    3ba9:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
	int c = 1;
    3bb0:	c7 45 f4 01 00 00 00    	mov    DWORD PTR [rbp-0xc],0x1

	// ! : not a 1.99 double
	float fA = 0.0F;
    3bb7:	66 0f ef c0             	pxor   xmm0,xmm0
    3bbb:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0
	fA = 1,99;
    3bc0:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3bc8 <expressionEvaluationOrder+0x2e>
    3bc8:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0
	(fA = 1) , 99;
    3bcd:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3bd5 <expressionEvaluationOrder+0x3b>
    3bd5:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0

	a & b || c;
    3bda:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3bdd:	23 45 f8                	and    eax,DWORD PTR [rbp-0x8]
    3be0:	85 c0                   	test   eax,eax
    3be2:	75 04                   	jne    3be8 <expressionEvaluationOrder+0x4e>
    3be4:	83 7d f4 00             	cmp    DWORD PTR [rbp-0xc],0x0

	a && b || c--;
    3be8:	83 7d fc 00             	cmp    DWORD PTR [rbp-0x4],0x0
    3bec:	74 06                   	je     3bf4 <expressionEvaluationOrder+0x5a>
    3bee:	83 7d f8 00             	cmp    DWORD PTR [rbp-0x8],0x0
    3bf2:	75 0b                   	jne    3bff <expressionEvaluationOrder+0x65>
    3bf4:	8b 45 f4                	mov    eax,DWORD PTR [rbp-0xc]
    3bf7:	8d 50 ff                	lea    edx,[rax-0x1]
    3bfa:	89 55 f4                	mov    DWORD PTR [rbp-0xc],edx
    3bfd:	85 c0                   	test   eax,eax
    3bff:	90                      	nop
	1 + ( (2 * 2) * 4 );

	( 1 + 2 ) * 2 * 4;
	( (1 + 2) * 2 ) * 4;

	1 + 4, c = 2 | 3 + 5;
    3c00:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [rbp-0xc],0xa
	( 1 + 4 ), ( c = ( 2 | ( 3 + 5 ) ) );
    3c07:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [rbp-0xc],0xa
	(1 + 5) & (4 == 3);

	// series of constant expressions
	3 , 4 , 5;

	!a++ + ~f();
    3c0e:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3c11:	8d 50 01                	lea    edx,[rax+0x1]
    3c14:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    3c17:	85 c0                   	test   eax,eax
    3c19:	e8 00 00 00 00          	call   3c1e <expressionEvaluationOrder+0x84>
	( !(a++) ) + ( ~(f()) );
    3c1e:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3c21:	8d 50 01                	lea    edx,[rax+0x1]
    3c24:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    3c27:	85 c0                   	test   eax,eax
    3c29:	e8 00 00 00 00          	call   3c2e <expressionEvaluationOrder+0x94>


}//expressionEvaluationOrder
    3c2e:	90                      	nop
    3c2f:	c9                      	leave  
    3c30:	c3                      	ret    

0000000000003c31 <sequentialEvaluation>:

int sequentialEvaluation( void ) {
    3c31:	55                      	push   rbp
    3c32:	48 89 e5                	mov    rbp,rsp
	// , comma / sequence operator
    // binary operator.
	// Left associative
	// eval first operand than discard it

	int values[2][3] = {
    3c35:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0
    3c3c:	c7 45 d4 0a 00 00 00    	mov    DWORD PTR [rbp-0x2c],0xa
    3c43:	c7 45 d8 16 00 00 00    	mov    DWORD PTR [rbp-0x28],0x16
    3c4a:	c7 45 dc 00 00 00 00    	mov    DWORD PTR [rbp-0x24],0x0
    3c51:	c7 45 e0 0b 00 00 00    	mov    DWORD PTR [rbp-0x20],0xb
    3c58:	c7 45 e4 16 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x16
		{0,10,22} , {0,11,22}
	} ;


	int a=1, b=2, c=3, i=0; // commas act as separators in this line, not as an operator
    3c5f:	c7 45 fc 01 00 00 00    	mov    DWORD PTR [rbp-0x4],0x1
    3c66:	c7 45 f0 02 00 00 00    	mov    DWORD PTR [rbp-0x10],0x2
    3c6d:	c7 45 ec 03 00 00 00    	mov    DWORD PTR [rbp-0x14],0x3
    3c74:	c7 45 e8 00 00 00 00    	mov    DWORD PTR [rbp-0x18],0x0

	i = (a, b);             // stores b into i
    3c7b:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    3c7e:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

	i = a, b;               // stores a into i. Equivalent to (i = a), b;
    3c81:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3c84:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax
	                        // ... a=1, b=2, c=3, i=1
	i = (a += 2, a + b);    // increases a by 2, then stores a+b = 3+2 into i
    3c87:	83 45 fc 02             	add    DWORD PTR [rbp-0x4],0x2
    3c8b:	8b 55 fc                	mov    edx,DWORD PTR [rbp-0x4]
    3c8e:	8b 45 f0                	mov    eax,DWORD PTR [rbp-0x10]
    3c91:	01 d0                   	add    eax,edx
    3c93:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

	i = a += 2, a + b;      // increases a by 2, then stores a to i, and discards unused
    3c96:	83 45 fc 02             	add    DWORD PTR [rbp-0x4],0x2
    3c9a:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3c9d:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

	i = a, b, c;            // stores a into i, discarding the unused b and c rvalues
    3ca0:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3ca3:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax

	i = (a, b, c);          // stores c into i, discarding the unused a and b rvalues
    3ca6:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]
    3ca9:	89 45 e8                	mov    DWORD PTR [rbp-0x18],eax


	values[0,1];             // ! not the same thing as values[0][1] : discards 0, use 1 as index
    values[1,1];             // ! not the same thing as values[1][1] : discards left 1, use riht 1 as index

	while ( a > 0, a-- );
    3cac:	90                      	nop
    3cad:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    3cb0:	8d 50 ff                	lea    edx,[rax-0x1]
    3cb3:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    3cb6:	85 c0                   	test   eax,eax
    3cb8:	75 f3                   	jne    3cad <sequentialEvaluation+0x7c>

	for ( int j = 0, k = 10; j < k; j++, k-- );
    3cba:	c7 45 f8 00 00 00 00    	mov    DWORD PTR [rbp-0x8],0x0
    3cc1:	c7 45 f4 0a 00 00 00    	mov    DWORD PTR [rbp-0xc],0xa
    3cc8:	eb 08                   	jmp    3cd2 <sequentialEvaluation+0xa1>
    3cca:	83 45 f8 01             	add    DWORD PTR [rbp-0x8],0x1
    3cce:	83 6d f4 01             	sub    DWORD PTR [rbp-0xc],0x1
    3cd2:	8b 45 f8                	mov    eax,DWORD PTR [rbp-0x8]
    3cd5:	3b 45 f4                	cmp    eax,DWORD PTR [rbp-0xc]
    3cd8:	7c f0                   	jl     3cca <sequentialEvaluation+0x99>


	return a=4, b=5, c=6;   // returns 6, not 4,
    3cda:	c7 45 fc 04 00 00 00    	mov    DWORD PTR [rbp-0x4],0x4
    3ce1:	c7 45 f0 05 00 00 00    	mov    DWORD PTR [rbp-0x10],0x5
    3ce8:	c7 45 ec 06 00 00 00    	mov    DWORD PTR [rbp-0x14],0x6
    3cef:	8b 45 ec                	mov    eax,DWORD PTR [rbp-0x14]

	return 1, 2, 3;         // returns 3, not 1,

	return (1), 2, 3;        // returns 3, not 1,

}//sequentialEvaluation
    3cf2:	5d                      	pop    rbp
    3cf3:	c3                      	ret    

0000000000003cf4 <structs_asParameterAndReturnValue>:
	int heigthAsCm;
	float weigthAsKg;
};


struct PointX structs_asParameterAndReturnValue( struct PointX point ) {
    3cf4:	55                      	push   rbp
    3cf5:	48 89 e5                	mov    rbp,rsp
    3cf8:	53                      	push   rbx
    3cf9:	48 89 7d f0             	mov    QWORD PTR [rbp-0x10],rdi

	return *(point.pNext);
    3cfd:	48 8b 55 30             	mov    rdx,QWORD PTR [rbp+0x30]
    3d01:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    3d05:	48 8b 0a                	mov    rcx,QWORD PTR [rdx]
    3d08:	48 8b 5a 08             	mov    rbx,QWORD PTR [rdx+0x8]
    3d0c:	48 89 08                	mov    QWORD PTR [rax],rcx
    3d0f:	48 89 58 08             	mov    QWORD PTR [rax+0x8],rbx
    3d13:	48 8b 4a 10             	mov    rcx,QWORD PTR [rdx+0x10]
    3d17:	48 8b 5a 18             	mov    rbx,QWORD PTR [rdx+0x18]
    3d1b:	48 89 48 10             	mov    QWORD PTR [rax+0x10],rcx
    3d1f:	48 89 58 18             	mov    QWORD PTR [rax+0x18],rbx
    3d23:	48 8b 4a 20             	mov    rcx,QWORD PTR [rdx+0x20]
    3d27:	48 8b 5a 28             	mov    rbx,QWORD PTR [rdx+0x28]
    3d2b:	48 89 48 20             	mov    QWORD PTR [rax+0x20],rcx
    3d2f:	48 89 58 28             	mov    QWORD PTR [rax+0x28],rbx

}//structs_asParameterAndReturnValue
    3d33:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    3d37:	48 8b 5d f8             	mov    rbx,QWORD PTR [rbp-0x8]
    3d3b:	c9                      	leave  
    3d3c:	c3                      	ret    

0000000000003d3d <structs>:

// TODO : struct flexible array member C99

void structs( void ) {
    3d3d:	55                      	push   rbp
    3d3e:	48 89 e5                	mov    rbp,rsp

	struct { char C; int I; double D; } mixA;
	mixA.C = 'a';
    3d41:	c6 45 e0 61             	mov    BYTE PTR [rbp-0x20],0x61
	mixA.I = 3;
    3d45:	c7 45 e4 03 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x3
	mixA.D = 1.618;
    3d4c:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3d54 <structs+0x17>
    3d54:	f2 0f 11 45 e8          	movsd  QWORD PTR [rbp-0x18],xmm0

	// mixB's type is different than mixA's type although they are looking the same
	struct { char C; int I; double D; } mixB = { 'a', 3, 1.618 };
    3d59:	c6 45 d0 61             	mov    BYTE PTR [rbp-0x30],0x61
    3d5d:	c7 45 d4 03 00 00 00    	mov    DWORD PTR [rbp-0x2c],0x3
    3d64:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3d6c <structs+0x2f>
    3d6c:	f2 0f 11 45 d8          	movsd  QWORD PTR [rbp-0x28],xmm0


	// mixA = mixB; // error : incompatible types struct<anonymous>

	PointF.fX = .01F;
    3d71:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3d79 <structs+0x3c>
    3d79:	f3 0f 11 05 00 00 00 00 	movss  DWORD PTR [rip+0x0],xmm0        # 3d81 <structs+0x44>
	PointF.fX = .02F;
    3d81:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3d89 <structs+0x4c>
    3d89:	f3 0f 11 05 00 00 00 00 	movss  DWORD PTR [rip+0x0],xmm0        # 3d91 <structs+0x54>

	Point pointA = { 2, 3 };
    3d91:	c7 45 c8 02 00 00 00    	mov    DWORD PTR [rbp-0x38],0x2
    3d98:	c7 45 cc 03 00 00 00    	mov    DWORD PTR [rbp-0x34],0x3
	Point pointB = { .X = 2, .Y = 3 };
    3d9f:	c7 45 c0 02 00 00 00    	mov    DWORD PTR [rbp-0x40],0x2
    3da6:	c7 45 c4 03 00 00 00    	mov    DWORD PTR [rbp-0x3c],0x3
	Point pointC = { .Y = 4 }; // initializes .X with zero
    3dad:	48 c7 45 b8 00 00 00 00 	mov    QWORD PTR [rbp-0x48],0x0
    3db5:	c7 45 bc 04 00 00 00    	mov    DWORD PTR [rbp-0x44],0x4

	// pointA = { 4,5 }         // error
	pointA = (Point){ 4, 5 };  // ok : "compound literal" assignment
    3dbc:	c7 45 c8 04 00 00 00    	mov    DWORD PTR [rbp-0x38],0x4
    3dc3:	c7 45 cc 05 00 00 00    	mov    DWORD PTR [rbp-0x34],0x5

	// !!
	pointA = (Point){ .Y = 6 }; // !! overrides .X with zero
    3dca:	48 c7 45 c8 00 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
    3dd2:	c7 45 cc 06 00 00 00    	mov    DWORD PTR [rbp-0x34],0x6

	//
	pointA = pointB;
    3dd9:	48 8b 45 c0             	mov    rax,QWORD PTR [rbp-0x40]
    3ddd:	48 89 45 c8             	mov    QWORD PTR [rbp-0x38],rax

	// PointF
    PointF.fY = .1F;
    3de1:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3de9 <structs+0xac>
    3de9:	f3 0f 11 05 00 00 00 00 	movss  DWORD PTR [rip+0x0],xmm0        # 3df1 <structs+0xb4>
    PointF.fY = .2F;
    3df1:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3df9 <structs+0xbc>
    3df9:	f3 0f 11 05 00 00 00 00 	movss  DWORD PTR [rip+0x0],xmm0        # 3e01 <structs+0xc4>

    //global points
    g_pointA.X = 1;
    3e01:	c7 05 00 00 00 00 01 00 	mov    DWORD PTR [rip+0x0],0x1        # 3e0b <structs+0xce>
    3e09:	00 00 
    g_pointA.Y = 2;
    3e0b:	c7 05 00 00 00 00 02 00 	mov    DWORD PTR [rip+0x0],0x2        # 3e15 <structs+0xd8>
    3e13:	00 00 

    g_pointB.X = 10;
    3e15:	c7 05 00 00 00 00 0a 00 	mov    DWORD PTR [rip+0x0],0xa        # 3e1f <structs+0xe2>
    3e1d:	00 00 
    g_pointB.Y = 20;
    3e1f:	c7 05 00 00 00 00 14 00 	mov    DWORD PTR [rip+0x0],0x14        # 3e29 <structs+0xec>
    3e27:	00 00 

    g_pointC.X = 100;
    3e29:	c7 05 00 00 00 00 64 00 	mov    DWORD PTR [rip+0x0],0x64        # 3e33 <structs+0xf6>
    3e31:	00 00 
    g_pointC.Y = 200;
    3e33:	c7 05 00 00 00 00 c8 00 	mov    DWORD PTR [rip+0x0],0xc8        # 3e3d <structs+0x100>
    3e3b:	00 00 

    // assigment (copy)
    g_pointA = g_pointB;
    3e3d:	48 8b 05 00 00 00 00    	mov    rax,QWORD PTR [rip+0x0]        # 3e44 <structs+0x107>
    3e44:	48 89 05 00 00 00 00    	mov    QWORD PTR [rip+0x0],rax        # 3e4b <structs+0x10e>

    // struct member referencing
    g_pointer = &g_pointC;
    3e4b:	48 8d 05 00 00 00 00    	lea    rax,[rip+0x0]        # 3e52 <structs+0x115>
    3e52:	48 89 05 00 00 00 00    	mov    QWORD PTR [rip+0x0],rax        # 3e59 <structs+0x11c>
    (*g_pointer).X = 22;
    3e59:	48 8b 05 00 00 00 00    	mov    rax,QWORD PTR [rip+0x0]        # 3e60 <structs+0x123>
    3e60:	c7 00 16 00 00 00       	mov    DWORD PTR [rax],0x16
    (*g_pointer).Y = 33;
    3e66:	48 8b 05 00 00 00 00    	mov    rax,QWORD PTR [rip+0x0]        # 3e6d <structs+0x130>
    3e6d:	c7 40 04 21 00 00 00    	mov    DWORD PTR [rax+0x4],0x21

    // member dereferencing operator
    g_pointer->X = 44;
    3e74:	48 8b 05 00 00 00 00    	mov    rax,QWORD PTR [rip+0x0]        # 3e7b <structs+0x13e>
    3e7b:	c7 00 2c 00 00 00       	mov    DWORD PTR [rax],0x2c
    g_pointer->Y = 55;
    3e81:	48 8b 05 00 00 00 00    	mov    rax,QWORD PTR [rip+0x0]        # 3e88 <structs+0x14b>
    3e88:	c7 40 04 37 00 00 00    	mov    DWORD PTR [rax+0x4],0x37

    struct PointD pointD1;
    struct PointD pointD2 = { .1, .2 };
    3e8f:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3e97 <structs+0x15a>
    3e97:	f2 0f 11 45 90          	movsd  QWORD PTR [rbp-0x70],xmm0
    3e9c:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3ea4 <structs+0x167>
    3ea4:	f2 0f 11 45 98          	movsd  QWORD PTR [rbp-0x68],xmm0

    //pointD1 = { .1, .2 };              // error
    //pointD1 = (PointD){ .1, .2 };      // error
    pointD1 = (struct PointD){ .1, .2 }; // ok : "compound literal" assignment
    3ea9:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3eb1 <structs+0x174>
    3eb1:	f2 0f 11 45 a0          	movsd  QWORD PTR [rbp-0x60],xmm0
    3eb6:	f2 0f 10 05 00 00 00 00 	movsd  xmm0,QWORD PTR [rip+0x0]        # 3ebe <structs+0x181>
    3ebe:	f2 0f 11 45 a8          	movsd  QWORD PTR [rbp-0x58],xmm0

	size_t position = 0;
    3ec3:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
	position = offsetof(  Point, Y );
    3ecb:	48 c7 45 f8 04 00 00 00 	mov    QWORD PTR [rbp-0x8],0x4

}//structs
    3ed3:	90                      	nop
    3ed4:	5d                      	pop    rbp
    3ed5:	c3                      	ret    

0000000000003ed6 <structs_structArrays>:

//-----------------------------------------------------------------------------

void structs_structArrays( void ) {
    3ed6:	55                      	push   rbp
    3ed7:	48 89 e5                	mov    rbp,rsp
    3eda:	48 83 ec 58             	sub    rsp,0x58

	// see disassembly
	struct TPerson people[ 3 ] = {
    3ede:	48 b8 61 79 68 61 6e 00 	movabs rax,0x6e61687961
    3ee6:	00 00 
    3ee8:	ba 00 00 00 00          	mov    edx,0x0
    3eed:	48 89 85 30 ff ff ff    	mov    QWORD PTR [rbp-0xd0],rax
    3ef4:	48 89 95 38 ff ff ff    	mov    QWORD PTR [rbp-0xc8],rdx
    3efb:	48 c7 85 40 ff ff ff 00 	mov    QWORD PTR [rbp-0xc0],0x0
    3f03:	00 00 00 
    3f06:	48 c7 85 48 ff ff ff 00 	mov    QWORD PTR [rbp-0xb8],0x0
    3f0e:	00 00 00 
    3f11:	48 c7 85 50 ff ff ff 00 	mov    QWORD PTR [rbp-0xb0],0x0
    3f19:	00 00 00 
    3f1c:	48 c7 85 58 ff ff ff 00 	mov    QWORD PTR [rbp-0xa8],0x0
    3f24:	00 00 00 
    3f27:	c7 85 60 ff ff ff 00 00 	mov    DWORD PTR [rbp-0xa0],0x0
    3f2f:	00 00 
    3f31:	66 c7 85 64 ff ff ff 00 	mov    WORD PTR [rbp-0x9c],0x0
    3f39:	00 
    3f3a:	c6 85 66 ff ff ff 00    	mov    BYTE PTR [rbp-0x9a],0x0
    3f41:	c7 85 68 ff ff ff a0 00 	mov    DWORD PTR [rbp-0x98],0xa0
    3f49:	00 00 
    3f4b:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3f53 <structs_structArrays+0x7d>
    3f53:	f3 0f 11 85 6c ff ff ff 	movss  DWORD PTR [rbp-0x94],xmm0
    3f5b:	48 b8 62 65 79 68 61 6e 	movabs rax,0x6e6168796562
    3f63:	00 00 
    3f65:	ba 00 00 00 00          	mov    edx,0x0
    3f6a:	48 89 85 70 ff ff ff    	mov    QWORD PTR [rbp-0x90],rax
    3f71:	48 89 95 78 ff ff ff    	mov    QWORD PTR [rbp-0x88],rdx
    3f78:	48 c7 45 80 00 00 00 00 	mov    QWORD PTR [rbp-0x80],0x0
    3f80:	48 c7 45 88 00 00 00 00 	mov    QWORD PTR [rbp-0x78],0x0
    3f88:	48 c7 45 90 00 00 00 00 	mov    QWORD PTR [rbp-0x70],0x0
    3f90:	48 c7 45 98 00 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0
    3f98:	c7 45 a0 00 00 00 00    	mov    DWORD PTR [rbp-0x60],0x0
    3f9f:	66 c7 45 a4 00 00       	mov    WORD PTR [rbp-0x5c],0x0
    3fa5:	c6 45 a6 00             	mov    BYTE PTR [rbp-0x5a],0x0
    3fa9:	c7 45 a8 96 00 00 00    	mov    DWORD PTR [rbp-0x58],0x96
    3fb0:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 3fb8 <structs_structArrays+0xe2>
    3fb8:	f3 0f 11 45 ac          	movss  DWORD PTR [rbp-0x54],xmm0
    3fbd:	48 b8 63 65 79 68 61 6e 	movabs rax,0x6e6168796563
    3fc5:	00 00 
    3fc7:	ba 00 00 00 00          	mov    edx,0x0
    3fcc:	48 89 45 b0             	mov    QWORD PTR [rbp-0x50],rax
    3fd0:	48 89 55 b8             	mov    QWORD PTR [rbp-0x48],rdx
    3fd4:	48 c7 45 c0 00 00 00 00 	mov    QWORD PTR [rbp-0x40],0x0
    3fdc:	48 c7 45 c8 00 00 00 00 	mov    QWORD PTR [rbp-0x38],0x0
    3fe4:	48 c7 45 d0 00 00 00 00 	mov    QWORD PTR [rbp-0x30],0x0
    3fec:	48 c7 45 d8 00 00 00 00 	mov    QWORD PTR [rbp-0x28],0x0
    3ff4:	c7 45 e0 00 00 00 00    	mov    DWORD PTR [rbp-0x20],0x0
    3ffb:	66 c7 45 e4 00 00       	mov    WORD PTR [rbp-0x1c],0x0
    4001:	c6 45 e6 00             	mov    BYTE PTR [rbp-0x1a],0x0
    4005:	c7 45 e8 aa 00 00 00    	mov    DWORD PTR [rbp-0x18],0xaa
    400c:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 4014 <structs_structArrays+0x13e>
    4014:	f3 0f 11 45 ec          	movss  DWORD PTR [rbp-0x14],xmm0
		{ "ayhan", 160, 65.5F  },
		{ "beyhan", 150, 55.5F },
		{ "ceyhan", 170, 70.5F }
	};

	char *pc = NULL;
    4019:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
	int  i   = 0;
    4021:	c7 45 f4 00 00 00 00    	mov    DWORD PTR [rbp-0xc],0x0
	float f  = .0F;
    4028:	66 0f ef c0             	pxor   xmm0,xmm0
    402c:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0

	pc = people[ 0 ].name;
    4031:	48 8d 85 30 ff ff ff    	lea    rax,[rbp-0xd0]
    4038:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
    i  = people[ 0 ].heigthAsCm;
    403c:	8b 85 68 ff ff ff       	mov    eax,DWORD PTR [rbp-0x98]
    4042:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
	f  = people[ 0 ].weigthAsKg;
    4045:	f3 0f 10 85 6c ff ff ff 	movss  xmm0,DWORD PTR [rbp-0x94]
    404d:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0

	pc = people[ 1 ].name;
    4052:	48 8d 85 30 ff ff ff    	lea    rax,[rbp-0xd0]
    4059:	48 83 c0 40             	add    rax,0x40
    405d:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
    i  = people[ 1 ].heigthAsCm;
    4061:	8b 45 a8                	mov    eax,DWORD PTR [rbp-0x58]
    4064:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
	f  = people[ 1 ].weigthAsKg;
    4067:	f3 0f 10 45 ac          	movss  xmm0,DWORD PTR [rbp-0x54]
    406c:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0

	pc = people[ 2 ].name;
    4071:	48 8d 85 30 ff ff ff    	lea    rax,[rbp-0xd0]
    4078:	48 83 e8 80             	sub    rax,0xffffffffffffff80
    407c:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
    i  = people[ 2 ].heigthAsCm;
    4080:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
    4083:	89 45 f4                	mov    DWORD PTR [rbp-0xc],eax
	f  = people[ 2 ].weigthAsKg;
    4086:	f3 0f 10 45 ec          	movss  xmm0,DWORD PTR [rbp-0x14]
    408b:	f3 0f 11 45 f0          	movss  DWORD PTR [rbp-0x10],xmm0

	strcpy( people[ 0 ].name, "ayda" );
    4090:	48 8d 85 30 ff ff ff    	lea    rax,[rbp-0xd0]
    4097:	c7 00 61 79 64 61       	mov    DWORD PTR [rax],0x61647961
    409d:	c6 40 04 00             	mov    BYTE PTR [rax+0x4],0x0
	people[ 0 ].heigthAsCm = 152;
    40a1:	c7 85 68 ff ff ff 98 00 	mov    DWORD PTR [rbp-0x98],0x98
    40a9:	00 00 
	people[ 0 ].weigthAsKg = 67.5F;
    40ab:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 40b3 <structs_structArrays+0x1dd>
    40b3:	f3 0f 11 85 6c ff ff ff 	movss  DWORD PTR [rbp-0x94],xmm0

	strcpy( people[ 1 ].name, "beyda" );
    40bb:	48 8d 85 30 ff ff ff    	lea    rax,[rbp-0xd0]
    40c2:	48 83 c0 40             	add    rax,0x40
    40c6:	c7 00 62 65 79 64       	mov    DWORD PTR [rax],0x64796562
    40cc:	66 c7 40 04 61 00       	mov    WORD PTR [rax+0x4],0x61
	people[ 1 ].heigthAsCm = 162;
    40d2:	c7 45 a8 a2 00 00 00    	mov    DWORD PTR [rbp-0x58],0xa2
	people[ 1 ].weigthAsKg = 57.5F;
    40d9:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 40e1 <structs_structArrays+0x20b>
    40e1:	f3 0f 11 45 ac          	movss  DWORD PTR [rbp-0x54],xmm0

	strcpy( people[ 2 ].name, "ceyda" );
    40e6:	48 8d 85 30 ff ff ff    	lea    rax,[rbp-0xd0]
    40ed:	48 83 e8 80             	sub    rax,0xffffffffffffff80
    40f1:	c7 00 63 65 79 64       	mov    DWORD PTR [rax],0x64796563
    40f7:	66 c7 40 04 61 00       	mov    WORD PTR [rax+0x4],0x61
	people[ 2 ].heigthAsCm = 162;
    40fd:	c7 45 e8 a2 00 00 00    	mov    DWORD PTR [rbp-0x18],0xa2
	people[ 2 ].weigthAsKg = 72.5F;
    4104:	f3 0f 10 05 00 00 00 00 	movss  xmm0,DWORD PTR [rip+0x0]        # 410c <structs_structArrays+0x236>
    410c:	f3 0f 11 45 ec          	movss  DWORD PTR [rbp-0x14],xmm0

}//structs_structArrays
    4111:	90                      	nop
    4112:	c9                      	leave  
    4113:	c3                      	ret    

0000000000004114 <structs_flexibleArrayMember>:
	unsigned int length;
	long double values[];

};

void structs_flexibleArrayMember( int measurementCount ) {
    4114:	55                      	push   rbp
    4115:	48 89 e5                	mov    rbp,rsp
    4118:	48 83 ec 30             	sub    rsp,0x30
    411c:	89 7d dc                	mov    DWORD PTR [rbp-0x24],edi

   // refer: https://en.wikipedia.org/wiki/Flexible_array_member

   struct TMeasurements* pMsr;

   size_t bytesAllocated = sizeof(struct TMeasurements) + measurementCount * sizeof(long double);
    411f:	8b 45 dc                	mov    eax,DWORD PTR [rbp-0x24]
    4122:	48 98                   	cdqe   
    4124:	48 83 c0 01             	add    rax,0x1
    4128:	48 c1 e0 04             	shl    rax,0x4
    412c:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
   pMsr = (struct TMeasurements*) malloc( bytesAllocated );
    4130:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    4134:	48 89 c7                	mov    rdi,rax
    4137:	e8 00 00 00 00          	call   413c <structs_flexibleArrayMember+0x28>
    413c:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
   pMsr->length = measurementCount;
    4140:	8b 55 dc                	mov    edx,DWORD PTR [rbp-0x24]
    4143:	48 8b 45 e8             	mov    rax,QWORD PTR [rbp-0x18]
    4147:	89 10                   	mov    DWORD PTR [rax],edx

   const int upperLimit = 10;
    4149:	c7 45 e4 0a 00 00 00    	mov    DWORD PTR [rbp-0x1c],0xa
   int loop = measurementCount;
    4150:	8b 45 dc                	mov    eax,DWORD PTR [rbp-0x24]
    4153:	89 45 fc                	mov    DWORD PTR [rbp-0x4],eax

   while ( loop-- )
    4156:	eb 21                   	jmp    4179 <structs_flexibleArrayMember+0x65>
	   pMsr->values[ loop ] = (long double)rand();
    4158:	e8 00 00 00 00          	call   415d <structs_flexibleArrayMember+0x49>
    415d:	89 45 d8                	mov    DWORD PTR [rbp-0x28],eax
    4160:	db 45 d8                	fild   DWORD PTR [rbp-0x28]
    4163:	48 8b 55 e8             	mov    rdx,QWORD PTR [rbp-0x18]
    4167:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    416a:	48 98                   	cdqe   
    416c:	48 83 c0 01             	add    rax,0x1
    4170:	48 c1 e0 04             	shl    rax,0x4
    4174:	48 01 d0                	add    rax,rdx
    4177:	db 38                   	fstp   TBYTE PTR [rax]
   while ( loop-- )
    4179:	8b 45 fc                	mov    eax,DWORD PTR [rbp-0x4]
    417c:	8d 50 ff                	lea    edx,[rax-0x1]
    417f:	89 55 fc                	mov    DWORD PTR [rbp-0x4],edx
    4182:	85 c0                   	test   eax,eax
    4184:	75 d2                   	jne    4158 <structs_flexibleArrayMember+0x44>

}//structs_flexibleArrayMember
    4186:	90                      	nop
    4187:	90                      	nop
    4188:	c9                      	leave  
    4189:	c3                      	ret    

000000000000418a <memoryManagement_alloc_calloc_realloc_free>:

//-----------------------------------------------------------------------------

void memoryManagement_alloc_calloc_realloc_free( void ) {
    418a:	55                      	push   rbp
    418b:	48 89 e5                	mov    rbp,rsp
    418e:	48 83 ec 30             	sub    rsp,0x30

	char *textA = NULL;
    4192:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0

	//textA = "lorem ipsum";// !! DON'T it's risky

	// returned memory block contains "garbage" values.
	textA = (char *) malloc( 12 );
    419a:	bf 0c 00 00 00          	mov    edi,0xc
    419f:	e8 00 00 00 00          	call   41a4 <memoryManagement_alloc_calloc_realloc_free+0x1a>
    41a4:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
	if ( NULL == textA )
    41a8:	48 83 7d f8 00          	cmp    QWORD PTR [rbp-0x8],0x0
    41ad:	0f 84 b2 00 00 00       	je     4265 <memoryManagement_alloc_calloc_realloc_free+0xdb>
	   goto EXIT;

   strcpy( textA, "lorem ipsum" );
    41b3:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    41b7:	48 b9 6c 6f 72 65 6d 20 	movabs rcx,0x7069206d65726f6c
    41bf:	69 70 
    41c1:	48 89 08                	mov    QWORD PTR [rax],rcx
    41c4:	c7 40 08 73 75 6d 00    	mov    DWORD PTR [rax+0x8],0x6d7573

	char *textB = NULL;
    41cb:	48 c7 45 f0 00 00 00 00 	mov    QWORD PTR [rbp-0x10],0x0

	// returned memory block contains "zeroed" values.
	textB = (char *) calloc( 16, 1 );
    41d3:	be 01 00 00 00          	mov    esi,0x1
    41d8:	bf 10 00 00 00          	mov    edi,0x10
    41dd:	e8 00 00 00 00          	call   41e2 <memoryManagement_alloc_calloc_realloc_free+0x58>
    41e2:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax
	if ( NULL == textB )
    41e6:	48 83 7d f0 00          	cmp    QWORD PTR [rbp-0x10],0x0
    41eb:	74 7b                   	je     4268 <memoryManagement_alloc_calloc_realloc_free+0xde>
	   goto EXIT;

    strcpy( textB, " dolor sit amet" );
    41ed:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    41f1:	48 be 20 64 6f 6c 6f 72 	movabs rsi,0x7320726f6c6f6420
    41f9:	20 73 
    41fb:	48 bf 69 74 20 61 6d 65 	movabs rdi,0x74656d61207469
    4203:	74 00 
    4205:	48 89 30                	mov    QWORD PTR [rax],rsi
    4208:	48 89 78 08             	mov    QWORD PTR [rax+0x8],rdi

	size_t sizeA = strlen( textA );
    420c:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    4210:	48 89 c7                	mov    rdi,rax
    4213:	e8 00 00 00 00          	call   4218 <memoryManagement_alloc_calloc_realloc_free+0x8e>
    4218:	48 89 45 e8             	mov    QWORD PTR [rbp-0x18],rax
	size_t sizeB = strlen( textB );
    421c:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    4220:	48 89 c7                	mov    rdi,rax
    4223:	e8 00 00 00 00          	call   4228 <memoryManagement_alloc_calloc_realloc_free+0x9e>
    4228:	48 89 45 e0             	mov    QWORD PTR [rbp-0x20],rax

	// after successful realloc, previously malloced-buffer passed as first argument
	// is no longer valid and should not be "freed()".
	void* newBlock = realloc( textA, sizeA + sizeB + 1 );
    422c:	48 8b 55 e8             	mov    rdx,QWORD PTR [rbp-0x18]
    4230:	48 8b 45 e0             	mov    rax,QWORD PTR [rbp-0x20]
    4234:	48 01 d0                	add    rax,rdx
    4237:	48 8d 50 01             	lea    rdx,[rax+0x1]
    423b:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    423f:	48 89 d6                	mov    rsi,rdx
    4242:	48 89 c7                	mov    rdi,rax
    4245:	e8 00 00 00 00          	call   424a <memoryManagement_alloc_calloc_realloc_free+0xc0>
    424a:	48 89 45 d8             	mov    QWORD PTR [rbp-0x28],rax
   textA = newBlock ? (char*) newBlock : textA;
    424e:	48 83 7d d8 00          	cmp    QWORD PTR [rbp-0x28],0x0
    4253:	74 06                   	je     425b <memoryManagement_alloc_calloc_realloc_free+0xd1>
    4255:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    4259:	eb 04                   	jmp    425f <memoryManagement_alloc_calloc_realloc_free+0xd5>
    425b:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    425f:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
    4263:	eb 04                   	jmp    4269 <memoryManagement_alloc_calloc_realloc_free+0xdf>
	   goto EXIT;
    4265:	90                      	nop
    4266:	eb 01                   	jmp    4269 <memoryManagement_alloc_calloc_realloc_free+0xdf>
	   goto EXIT;
    4268:	90                      	nop

EXIT:
	textA ? 0 : free( textA );
    4269:	48 83 7d f8 00          	cmp    QWORD PTR [rbp-0x8],0x0
    426e:	75 0c                   	jne    427c <memoryManagement_alloc_calloc_realloc_free+0xf2>
    4270:	48 8b 45 f8             	mov    rax,QWORD PTR [rbp-0x8]
    4274:	48 89 c7                	mov    rdi,rax
    4277:	e8 00 00 00 00          	call   427c <memoryManagement_alloc_calloc_realloc_free+0xf2>
	textB ? 0 : free( textB );
    427c:	48 83 7d f0 00          	cmp    QWORD PTR [rbp-0x10],0x0
    4281:	75 0c                   	jne    428f <memoryManagement_alloc_calloc_realloc_free+0x105>
    4283:	48 8b 45 f0             	mov    rax,QWORD PTR [rbp-0x10]
    4287:	48 89 c7                	mov    rdi,rax
    428a:	e8 00 00 00 00          	call   428f <memoryManagement_alloc_calloc_realloc_free+0x105>

}//memoryManagement_alloc_calloc_realloc_free
    428f:	90                      	nop
    4290:	c9                      	leave  
    4291:	c3                      	ret    

0000000000004292 <implicitFunDec>:
//-----------------------------------------------------------------------------

implicitlyTypedVariableA;
impTVB = 2;

implicitFunDec( value ) {
    4292:	55                      	push   rbp
    4293:	48 89 e5                	mov    rbp,rsp
    4296:	89 7d ec                	mov    DWORD PTR [rbp-0x14],edi

   unsigned impTVC = 3;
    4299:	c7 45 fc 03 00 00 00    	mov    DWORD PTR [rbp-0x4],0x3

}//implicitFunDec
    42a0:	90                      	nop
    42a1:	5d                      	pop    rbp
    42a2:	c3                      	ret    

00000000000042a3 <main>:

//-----------------------------------------------------------------------------

int main( int argc, char** argv ) {
    42a3:	55                      	push   rbp
    42a4:	48 89 e5                	mov    rbp,rsp
    42a7:	48 83 ec 50             	sub    rsp,0x50
    42ab:	89 7d bc                	mov    DWORD PTR [rbp-0x44],edi
    42ae:	48 89 75 b0             	mov    QWORD PTR [rbp-0x50],rsi
   
   //pathCombineTester();

   implicitFunDec( 2 );
    42b2:	bf 02 00 00 00          	mov    edi,0x2
    42b7:	b8 00 00 00 00          	mov    eax,0x0
    42bc:	e8 00 00 00 00          	call   42c1 <main+0x1e>

	pointers6();
    42c1:	e8 00 00 00 00          	call   42c6 <main+0x23>

	initializationOfArrays();
    42c6:	e8 00 00 00 00          	call   42cb <main+0x28>

	pointers5();
    42cb:	e8 00 00 00 00          	call   42d0 <main+0x2d>

	memoryManagement_alloc_calloc_realloc_free();
    42d0:	e8 00 00 00 00          	call   42d5 <main+0x32>

	structs_flexibleArrayMember( 4 );
    42d5:	bf 04 00 00 00          	mov    edi,0x4
    42da:	e8 00 00 00 00          	call   42df <main+0x3c>

	arrays_variableSize( 3 );
    42df:	bf 03 00 00 00          	mov    edi,0x3
    42e4:	e8 00 00 00 00          	call   42e9 <main+0x46>

	unions();
    42e9:	e8 00 00 00 00          	call   42ee <main+0x4b>

	arrays_multiDimensionalJaggedvsFlat();
    42ee:	b8 00 00 00 00          	mov    eax,0x0
    42f3:	e8 00 00 00 00          	call   42f8 <main+0x55>
	arrays_multiDimensionalJagged();
    42f8:	b8 00 00 00 00          	mov    eax,0x0
    42fd:	e8 00 00 00 00          	call   4302 <main+0x5f>
	arrays_multiDimensional();
    4302:	b8 00 00 00 00          	mov    eax,0x0
    4307:	e8 00 00 00 00          	call   430c <main+0x69>

	long long int sum = 0;
    430c:	48 c7 45 f8 00 00 00 00 	mov    QWORD PTR [rbp-0x8],0x0
	sum = functions_sum( 3 , 2, 4, 6 );
    4314:	b9 06 00 00 00          	mov    ecx,0x6
    4319:	ba 04 00 00 00          	mov    edx,0x4
    431e:	be 02 00 00 00          	mov    esi,0x2
    4323:	bf 03 00 00 00          	mov    edi,0x3
    4328:	b8 00 00 00 00          	mov    eax,0x0
    432d:	e8 00 00 00 00          	call   4332 <main+0x8f>
    4332:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax
	sum = functions_sum( 4 , 1, 3, 5, 7 );
    4336:	41 b8 07 00 00 00       	mov    r8d,0x7
    433c:	b9 05 00 00 00          	mov    ecx,0x5
    4341:	ba 03 00 00 00          	mov    edx,0x3
    4346:	be 01 00 00 00          	mov    esi,0x1
    434b:	bf 04 00 00 00          	mov    edi,0x4
    4350:	b8 00 00 00 00          	mov    eax,0x0
    4355:	e8 00 00 00 00          	call   435a <main+0xb7>
    435a:	48 89 45 f8             	mov    QWORD PTR [rbp-0x8],rax


	long long int factorial = functions_recursiveFactorial( 5 );
    435e:	bf 05 00 00 00          	mov    edi,0x5
    4363:	e8 00 00 00 00          	call   4368 <main+0xc5>
    4368:	48 89 45 f0             	mov    QWORD PTR [rbp-0x10],rax

	functions_recursiveFunction();
    436c:	e8 00 00 00 00          	call   4371 <main+0xce>

	sinus( 120 );
    4371:	bf 78 00 00 00          	mov    edi,0x78
    4376:	e8 00 00 00 00          	call   437b <main+0xd8>

	arrays();
    437b:	e8 00 00 00 00          	call   4380 <main+0xdd>

	structs();
    4380:	e8 00 00 00 00          	call   4385 <main+0xe2>

	literals();
    4385:	e8 00 00 00 00          	call   438a <main+0xe7>

	operators_conditionalExpression();
    438a:	e8 00 00 00 00          	call   438f <main+0xec>
	operators_additive();
    438f:	e8 00 00 00 00          	call   4394 <main+0xf1>
	operators_multiplicative();
    4394:	e8 00 00 00 00          	call   4399 <main+0xf6>

	functionPointers();
    4399:	e8 00 00 00 00          	call   439e <main+0xfb>

   everyIdentifierHasAnAddress();
    439e:	e8 00 00 00 00          	call   43a3 <main+0x100>

   arrays();
    43a3:	e8 00 00 00 00          	call   43a8 <main+0x105>
   arrays_multiDimensional();
    43a8:	b8 00 00 00 00          	mov    eax,0x0
    43ad:	e8 00 00 00 00          	call   43b2 <main+0x10f>
	initializationOfVariables();
    43b2:	e8 00 00 00 00          	call   43b7 <main+0x114>
	sequentialEvaluation();
    43b7:	e8 00 00 00 00          	call   43bc <main+0x119>
	bitManipulation();
    43bc:	b8 00 00 00 00          	mov    eax,0x0
    43c1:	e8 00 00 00 00          	call   43c6 <main+0x123>

    int a = 1;
    43c6:	c7 45 d0 01 00 00 00    	mov    DWORD PTR [rbp-0x30],0x1

    int x = 1;
    43cd:	c7 45 ec 01 00 00 00    	mov    DWORD PTR [rbp-0x14],0x1
    int y = 1;
    43d4:	c7 45 e8 01 00 00 00    	mov    DWORD PTR [rbp-0x18],0x1
	 int z = 0;
    43db:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0


    // conditional evaluation of y
    x && y++;
    43e2:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
    43e6:	74 0b                   	je     43f3 <main+0x150>
    43e8:	8b 45 e8                	mov    eax,DWORD PTR [rbp-0x18]
    43eb:	8d 50 01                	lea    edx,[rax+0x1]
    43ee:	89 55 e8                	mov    DWORD PTR [rbp-0x18],edx
    43f1:	85 c0                   	test   eax,eax

    //x == 0 ? x += 1: x += 2;
    (x == 0) ? (x += 1) : (x += 2);
    43f3:	83 7d ec 00             	cmp    DWORD PTR [rbp-0x14],0x0
    43f7:	75 06                   	jne    43ff <main+0x15c>
    43f9:	83 45 ec 01             	add    DWORD PTR [rbp-0x14],0x1
    43fd:	eb 04                   	jmp    4403 <main+0x160>
    43ff:	83 45 ec 02             	add    DWORD PTR [rbp-0x14],0x2

	z = !a++;
    4403:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    4406:	8d 50 01                	lea    edx,[rax+0x1]
    4409:	89 55 d0                	mov    DWORD PTR [rbp-0x30],edx
    440c:	85 c0                   	test   eax,eax
    440e:	0f 94 c0                	sete   al
    4411:	0f b6 c0                	movzx  eax,al
    4414:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax


	z = ( 0, 1, 2, 3 + 4 );
    4417:	c7 45 e4 07 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x7

	z = 0;
    441e:	c7 45 e4 00 00 00 00    	mov    DWORD PTR [rbp-0x1c],0x0
	a = 0;
    4425:	c7 45 d0 00 00 00 00    	mov    DWORD PTR [rbp-0x30],0x0

	z = !(a++);
    442c:	8b 45 d0                	mov    eax,DWORD PTR [rbp-0x30]
    442f:	8d 50 01                	lea    edx,[rax+0x1]
    4432:	89 55 d0                	mov    DWORD PTR [rbp-0x30],edx
    4435:	85 c0                   	test   eax,eax
    4437:	0f 94 c0                	sete   al
    443a:	0f b6 c0                	movzx  eax,al
    443d:	89 45 e4                	mov    DWORD PTR [rbp-0x1c],eax

	division();
    4440:	e8 00 00 00 00          	call   4445 <main+0x1a2>

	typePromotionPromoteToInt();
    4445:	e8 00 00 00 00          	call   444a <main+0x1a7>

	// precedence of post increment
   int i[] = {3, 5};
    444a:	c7 45 c8 03 00 00 00    	mov    DWORD PTR [rbp-0x38],0x3
    4451:	c7 45 cc 05 00 00 00    	mov    DWORD PTR [rbp-0x34],0x5
   int *p = i;
    4458:	48 8d 45 c8             	lea    rax,[rbp-0x38]
    445c:	48 89 45 d8             	mov    QWORD PTR [rbp-0x28],rax
   int j = --*p++;
    4460:	48 8b 45 d8             	mov    rax,QWORD PTR [rbp-0x28]
    4464:	48 8d 50 04             	lea    rdx,[rax+0x4]
    4468:	48 89 55 d8             	mov    QWORD PTR [rbp-0x28],rdx
    446c:	8b 10                   	mov    edx,DWORD PTR [rax]
    446e:	83 ea 01                	sub    edx,0x1
    4471:	89 10                   	mov    DWORD PTR [rax],edx
    4473:	8b 00                   	mov    eax,DWORD PTR [rax]
    4475:	89 45 d4                	mov    DWORD PTR [rbp-0x2c],eax

	typePromotion();
    4478:	e8 00 00 00 00          	call   447d <main+0x1da>
	modulus();
    447d:	e8 00 00 00 00          	call   4482 <main+0x1df>
	//SameWidthTypePromotion();


	expressionEvaluationOrder();
    4482:	e8 00 00 00 00          	call   4487 <main+0x1e4>

	literals();
    4487:	e8 00 00 00 00          	call   448c <main+0x1e9>

   bitFields();
    448c:	e8 00 00 00 00          	call   4491 <main+0x1ee>


	int b = 5;
    4491:	c7 45 c4 05 00 00 00    	mov    DWORD PTR [rbp-0x3c],0x5
	swap( &a, &b );
    4498:	48 8d 55 c4             	lea    rdx,[rbp-0x3c]
    449c:	48 8d 45 d0             	lea    rax,[rbp-0x30]
    44a0:	48 89 d6                	mov    rsi,rdx
    44a3:	48 89 c7                	mov    rdi,rax
    44a6:	e8 0e ec ff ff          	call   30b9 <swap>

	return EXIT_SUCCESS;
    44ab:	b8 00 00 00 00          	mov    eax,0x0

}//main
    44b0:	c9                      	leave  
    44b1:	c3                      	ret    
