arm-none-eabi-gcc (Arm GNU Toolchain 12.2.MPACBTI-Bet1 (Build arm-12-mpacbti.16)) 12.2.0
Using: -std=gnu99 -g3 -O0 -mcpu=cortex-m4 -mfpu=fpv4-sp-d16 -mfloat-abi=hard -mthumb -ffunction-sections -fdata-sections --specs=nano.specs -c

main.o:     file format elf32-littlearm


Disassembly of section .text.literals:

00000000 <literals>:

#include <time.h>

//-----------------------------------------------------------------------------

void literals( void ) {
   0:	b580      	push	{r7, lr}
   2:	b0ca      	sub	sp, #296	; 0x128
   4:	af00      	add	r7, sp, #0

   // size as multiples of char
   size_t size = 0;
   6:	2300      	movs	r3, #0
   8:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124

   // GCC -std=c99 komut satırı parametresi ve #include<stdbool.h> gerekli
   _Bool result = false;
   c:	2300      	movs	r3, #0
   e:	f887 3123 	strb.w	r3, [r7, #291]	; 0x123
   Decimal: 97
   Hex    : 0x61
   Binary : 0b01100001
   Octal  : 0141
   */
   char c = 0;
  12:	2300      	movs	r3, #0
  14:	f887 3122 	strb.w	r3, [r7, #290]	; 0x122

   c = 97;   // decimal (base 10) literal
  18:	2361      	movs	r3, #97	; 0x61
  1a:	f887 3122 	strb.w	r3, [r7, #290]	; 0x122
   c = 0x61; // hexadecimal (base 16) literal
  1e:	2361      	movs	r3, #97	; 0x61
  20:	f887 3122 	strb.w	r3, [r7, #290]	; 0x122
   c = 0141; // octal (base 8) literal
  24:	2361      	movs	r3, #97	; 0x61
  26:	f887 3122 	strb.w	r3, [r7, #290]	; 0x122
   c = 'a';  // character literal
  2a:	2361      	movs	r3, #97	; 0x61
  2c:	f887 3122 	strb.w	r3, [r7, #290]	; 0x122

   // binary literal, gcc specific
   c = 0b01100001;
  30:	2361      	movs	r3, #97	; 0x61
  32:	f887 3122 	strb.w	r3, [r7, #290]	; 0x122

   // single char literals (ASCII)
   char c01 = 'a';
  36:	2361      	movs	r3, #97	; 0x61
  38:	f887 3121 	strb.w	r3, [r7, #289]	; 0x121
   char c02 = -67;
  3c:	23bd      	movs	r3, #189	; 0xbd
  3e:	f887 3120 	strb.w	r3, [r7, #288]	; 0x120
   char c03 = '\0';
  42:	2300      	movs	r3, #0
  44:	f887 311f 	strb.w	r3, [r7, #287]	; 0x11f
   char c04 = 0;
  48:	2300      	movs	r3, #0
  4a:	f887 311e 	strb.w	r3, [r7, #286]	; 0x11e

   char c05 = ' ';
  4e:	2320      	movs	r3, #32
  50:	f887 311d 	strb.w	r3, [r7, #285]	; 0x11d
   char c06 = '\\';
  54:	235c      	movs	r3, #92	; 0x5c
  56:	f887 311c 	strb.w	r3, [r7, #284]	; 0x11c
   //char c07 = ''';

   // non printable chars (escape sequence)
   char c08 = '"';
  5a:	2322      	movs	r3, #34	; 0x22
  5c:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
   char c09 = '\a';
  60:	2307      	movs	r3, #7
  62:	f887 311a 	strb.w	r3, [r7, #282]	; 0x11a
   char c10 = '\b';
  66:	2308      	movs	r3, #8
  68:	f887 3119 	strb.w	r3, [r7, #281]	; 0x119
   char c11 = '\f';
  6c:	230c      	movs	r3, #12
  6e:	f887 3118 	strb.w	r3, [r7, #280]	; 0x118
   char c12 = '\n';
  72:	230a      	movs	r3, #10
  74:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117
   char c13 = '\r';
  78:	230d      	movs	r3, #13
  7a:	f887 3116 	strb.w	r3, [r7, #278]	; 0x116
   char c14 = '\t';
  7e:	2309      	movs	r3, #9
  80:	f887 3115 	strb.w	r3, [r7, #277]	; 0x115
   char c15 = '\v';
  84:	230b      	movs	r3, #11
  86:	f887 3114 	strb.w	r3, [r7, #276]	; 0x114

   char c16 = '\456'; // octal
  8a:	232e      	movs	r3, #46	; 0x2e
  8c:	f887 3113 	strb.w	r3, [r7, #275]	; 0x113
   char c17 = '\xAF'; // hex
  90:	23af      	movs	r3, #175	; 0xaf
  92:	f887 3112 	strb.w	r3, [r7, #274]	; 0x112

   //unsigned short     c18 = '\u20AC';
   //unsigned short int c19 = '\u20AC';
   //unsigned int       c20 = '\U40FFAA11';

   signed int si1 = -3;
  96:	f06f 0302 	mvn.w	r3, #2
  9a:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
   int        si2 = -3;
  9e:	f06f 0302 	mvn.w	r3, #2
  a2:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

   long int liA = 10L;
  a6:	230a      	movs	r3, #10
  a8:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
   long     liB = 10L;
  ac:	230a      	movs	r3, #10
  ae:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

   long long int  lliA = 10LL;
  b2:	f04f 020a 	mov.w	r2, #10
  b6:	f04f 0300 	mov.w	r3, #0
  ba:	e9c7 233e 	strd	r2, r3, [r7, #248]	; 0xf8
   long long      lliB = 10LL;
  be:	f04f 020a 	mov.w	r2, #10
  c2:	f04f 0300 	mov.w	r3, #0
  c6:	e9c7 233c 	strd	r2, r3, [r7, #240]	; 0xf0

   unsigned long long int ulliA = 10ULL;
  ca:	f04f 020a 	mov.w	r2, #10
  ce:	f04f 0300 	mov.w	r3, #0
  d2:	e9c7 233a 	strd	r2, r3, [r7, #232]	; 0xe8
   unsigned long long     ulliB = 10ULL;
  d6:	f04f 020a 	mov.w	r2, #10
  da:	f04f 0300 	mov.w	r3, #0
  de:	e9c7 2338 	strd	r2, r3, [r7, #224]	; 0xe0

   char text01[] = "hello";
  e2:	4a4b      	ldr	r2, [pc, #300]	; (210 <literals+0x210>)
  e4:	f107 0348 	add.w	r3, r7, #72	; 0x48
  e8:	e892 0003 	ldmia.w	r2, {r0, r1}
  ec:	6018      	str	r0, [r3, #0]
  ee:	3304      	adds	r3, #4
  f0:	8019      	strh	r1, [r3, #0]
   //char text03[] = "C:\Windows\System32\drivers\";
   //char text04[] = "he said "hello"";
   //char text05[] = "he said "hello"";

   // UNICODE char literal
   wchar_t wc01 = L'ç';
  f2:	23e7      	movs	r3, #231	; 0xe7
  f4:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
   size = sizeof( wc01 );
  f8:	2304      	movs	r3, #4
  fa:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124

   // UNICODE string literal
   wchar_t text06[] = L"ĞÜŞİÖÇ ğüşiöç Iı";
  fe:	f507 7394 	add.w	r3, r7, #296	; 0x128
 102:	f5a3 7392 	sub.w	r3, r3, #292	; 0x124
 106:	4a43      	ldr	r2, [pc, #268]	; (214 <literals+0x214>)
 108:	4618      	mov	r0, r3
 10a:	4611      	mov	r1, r2
 10c:	2344      	movs	r3, #68	; 0x44
 10e:	461a      	mov	r2, r3
 110:	f7ff fffe 	bl	0 <memcpy>
   size = sizeof( text06 );
 114:	2344      	movs	r3, #68	; 0x44
 116:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124

   // IEEE 754 single precision floating point number (4 Byte)
   float f01 = 0;
 11a:	f04f 0300 	mov.w	r3, #0
 11e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
   float f02 = .0;
 122:	f04f 0300 	mov.w	r3, #0
 126:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
   float f03 = .0F;
 12a:	f04f 0300 	mov.w	r3, #0
 12e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
   float f04 = 3.14F;
 132:	4b39      	ldr	r3, [pc, #228]	; (218 <literals+0x218>)
 134:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
   float f05 = FLT_EPSILON;
 138:	f04f 5350 	mov.w	r3, #872415232	; 0x34000000
 13c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

   float pi          = 3.14159;
 140:	4b36      	ldr	r3, [pc, #216]	; (21c <literals+0x21c>)
 142:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   float aMole       = 6.02E23;
 146:	4b36      	ldr	r3, [pc, #216]	; (220 <literals+0x220>)
 148:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
   float anotherMole = 6.022e23;
 14c:	4b35      	ldr	r3, [pc, #212]	; (224 <literals+0x224>)
 14e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

   float electronCharge = 1.60217657e-19;
 152:	4b35      	ldr	r3, [pc, #212]	; (228 <literals+0x228>)
 154:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   float protonMass     = 1.67262178e-27;
 158:	4b34      	ldr	r3, [pc, #208]	; (22c <literals+0x22c>)
 15a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

   // IEEE 754 double precision floating point number (8 Byte)
   double d01 = .0;
 15e:	f04f 0200 	mov.w	r2, #0
 162:	f04f 0300 	mov.w	r3, #0
 166:	e9c7 232a 	strd	r2, r3, [r7, #168]	; 0xa8
   double d02 = .456;
 16a:	a31f      	add	r3, pc, #124	; (adr r3, 1e8 <literals+0x1e8>)
 16c:	e9d3 2300 	ldrd	r2, r3, [r3]
 170:	e9c7 2328 	strd	r2, r3, [r7, #160]	; 0xa0
   double d03 = DBL_EPSILON;
 174:	f04f 0200 	mov.w	r2, #0
 178:	4b2d      	ldr	r3, [pc, #180]	; (230 <literals+0x230>)
 17a:	e9c7 2326 	strd	r2, r3, [r7, #152]	; 0x98

   // intel specific extended 80bit (10 Byte)
   long double ldGR = 1.618L;
 17e:	a31c      	add	r3, pc, #112	; (adr r3, 1f0 <literals+0x1f0>)
 180:	e9d3 2300 	ldrd	r2, r3, [r3]
 184:	e9c7 2324 	strd	r2, r3, [r7, #144]	; 0x90
   long double ldPI = 3.14159265358979323846264338328L;
 188:	a31b      	add	r3, pc, #108	; (adr r3, 1f8 <literals+0x1f8>)
 18a:	e9d3 2300 	ldrd	r2, r3, [r3]
 18e:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
   long double ld01 = LDBL_EPSILON;
 192:	f04f 0200 	mov.w	r2, #0
 196:	4b26      	ldr	r3, [pc, #152]	; (230 <literals+0x230>)
 198:	e9c7 2320 	strd	r2, r3, [r7, #128]	; 0x80
            13 hexadecimal digits       (P - decimal)
   (0x1) . (999999999999A)              P(-4)
   */
   // C99 specific IEEE 754 double precision floating point HEXADECIMAL (base 16) literal
   // 1.100110011001100110011001100110011001100110011001101 x 2^(-4).
   double d04 = 0x1.999999999999Ap-4;
 19c:	a318      	add	r3, pc, #96	; (adr r3, 200 <literals+0x200>)
 19e:	e9d3 2300 	ldrd	r2, r3, [r3]
 1a2:	e9c7 231e 	strd	r2, r3, [r7, #120]	; 0x78

   double d05 = 0xF.999999999999aP-4;
 1a6:	a318      	add	r3, pc, #96	; (adr r3, 208 <literals+0x208>)
 1a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 1ac:	e9c7 231c 	strd	r2, r3, [r7, #112]	; 0x70
   double d06 = 0xF.FFFFFFFFFFFFFP-4;
 1b0:	f04f 0200 	mov.w	r2, #0
 1b4:	4b1f      	ldr	r3, [pc, #124]	; (234 <literals+0x234>)
 1b6:	e9c7 231a 	strd	r2, r3, [r7, #104]	; 0x68
   double d07 = 0x1p-1;
 1ba:	f04f 0200 	mov.w	r2, #0
 1be:	4b1e      	ldr	r3, [pc, #120]	; (238 <literals+0x238>)
 1c0:	e9c7 2318 	strd	r2, r3, [r7, #96]	; 0x60
   double d08 = 0x2p-1;
 1c4:	f04f 0200 	mov.w	r2, #0
 1c8:	4b1a      	ldr	r3, [pc, #104]	; (234 <literals+0x234>)
 1ca:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
   double d09 = 0x3p-1;
 1ce:	f04f 0200 	mov.w	r2, #0
 1d2:	4b1a      	ldr	r3, [pc, #104]	; (23c <literals+0x23c>)
 1d4:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50

}//literals
 1d8:	bf00      	nop
 1da:	f507 7794 	add.w	r7, r7, #296	; 0x128
 1de:	46bd      	mov	sp, r7
 1e0:	bd80      	pop	{r7, pc}
 1e2:	bf00      	nop
 1e4:	f3af 8000 	nop.w
 1e8:	9fbe76c9 	.word	0x9fbe76c9
 1ec:	3fdd2f1a 	.word	0x3fdd2f1a
 1f0:	f7ced917 	.word	0xf7ced917
 1f4:	3ff9e353 	.word	0x3ff9e353
 1f8:	54442d18 	.word	0x54442d18
 1fc:	400921fb 	.word	0x400921fb
 200:	9999999a 	.word	0x9999999a
 204:	3fb99999 	.word	0x3fb99999
 208:	33333333 	.word	0x33333333
 20c:	3fef3333 	.word	0x3fef3333
 210:	00000000 	.word	0x00000000
 214:	00000008 	.word	0x00000008
 218:	4048f5c3 	.word	0x4048f5c3
 21c:	40490fd0 	.word	0x40490fd0
 220:	66fef4f9 	.word	0x66fef4f9
 224:	66ff0aa8 	.word	0x66ff0aa8
 228:	203d26d1 	.word	0x203d26d1
 22c:	130484cd 	.word	0x130484cd
 230:	3cb00000 	.word	0x3cb00000
 234:	3ff00000 	.word	0x3ff00000
 238:	3fe00000 	.word	0x3fe00000
 23c:	3ff80000 	.word	0x3ff80000

Disassembly of section .text.integers:

00000000 <integers>:

//-----------------------------------------------------------------------------

itX;     // implicitly typed int
itY = 0; // implicitly typed int
void integers( void ) {
   0:	b480      	push	{r7}
   2:	b09d      	sub	sp, #116	; 0x74
   4:	af00      	add	r7, sp, #0
    
	// char's signedness is implementation specific
	char          c  = 0;
   6:	2300      	movs	r3, #0
   8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	signed char   sc = 0;
   c:	2300      	movs	r3, #0
   e:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
	unsigned char uc = 0;
  12:	2300      	movs	r3, #0
  14:	f887 306d 	strb.w	r3, [r7, #109]	; 0x6d

	short          s  = 0;
  18:	2300      	movs	r3, #0
  1a:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
	signed short   ss = 0;
  1e:	2300      	movs	r3, #0
  20:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
	unsigned short us = 0;
  24:	2300      	movs	r3, #0
  26:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

	int          i  = 0;
  2a:	2300      	movs	r3, #0
  2c:	663b      	str	r3, [r7, #96]	; 0x60
	signed int   si = 0;
  2e:	2300      	movs	r3, #0
  30:	65fb      	str	r3, [r7, #92]	; 0x5c
	unsigned int ui = 0;
  32:	2300      	movs	r3, #0
  34:	65bb      	str	r3, [r7, #88]	; 0x58

	signed   sn = 0; // int
  36:	2300      	movs	r3, #0
  38:	657b      	str	r3, [r7, #84]	; 0x54
	unsigned un = 0; // int
  3a:	2300      	movs	r3, #0
  3c:	653b      	str	r3, [r7, #80]	; 0x50

	long          l  = 0;
  3e:	2300      	movs	r3, #0
  40:	64fb      	str	r3, [r7, #76]	; 0x4c
	signed long   sl = 1;
  42:	2301      	movs	r3, #1
  44:	64bb      	str	r3, [r7, #72]	; 0x48
	unsigned long ul = 1;
  46:	2301      	movs	r3, #1
  48:	647b      	str	r3, [r7, #68]	; 0x44

	long long          ll  = 0;
  4a:	f04f 0200 	mov.w	r2, #0
  4e:	f04f 0300 	mov.w	r3, #0
  52:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	signed long long  sll  = 1;
  56:	f04f 0201 	mov.w	r2, #1
  5a:	f04f 0300 	mov.w	r3, #0
  5e:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
	unsigned long long ull = 1;
  62:	f04f 0201 	mov.w	r2, #1
  66:	f04f 0300 	mov.w	r3, #0
  6a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

	// fixed length across platforms (  stdint.h or inttypes.h )
	int16_t  i16  = 0;
  6e:	2300      	movs	r3, #0
  70:	84fb      	strh	r3, [r7, #38]	; 0x26
	uint16_t ui16 = 0;
  72:	2300      	movs	r3, #0
  74:	84bb      	strh	r3, [r7, #36]	; 0x24

	int32_t  i32  = 0;
  76:	2300      	movs	r3, #0
  78:	623b      	str	r3, [r7, #32]
	uint32_t ui32 = 0;
  7a:	2300      	movs	r3, #0
  7c:	61fb      	str	r3, [r7, #28]

	size_t size = 0;
  7e:	2300      	movs	r3, #0
  80:	61bb      	str	r3, [r7, #24]

   // platform dependant and may vary platform to platform ( limits.h )
	int bitCount = CHAR_BIT;
  82:	2308      	movs	r3, #8
  84:	617b      	str	r3, [r7, #20]
	int value = CHAR_MIN;
  86:	2300      	movs	r3, #0
  88:	613b      	str	r3, [r7, #16]
	value     = CHAR_MAX;
  8a:	23ff      	movs	r3, #255	; 0xff
  8c:	613b      	str	r3, [r7, #16]

	size = sizeof( char );
  8e:	2301      	movs	r3, #1
  90:	61bb      	str	r3, [r7, #24]
    //size = sizeof int;  //syntax error
    size = sizeof value;  // ok
  92:	2304      	movs	r3, #4
  94:	61bb      	str	r3, [r7, #24]

    size = sizeof( c );
  96:	2301      	movs	r3, #1
  98:	61bb      	str	r3, [r7, #24]
    size = sizeof( 0 );
  9a:	2304      	movs	r3, #4
  9c:	61bb      	str	r3, [r7, #24]
	size = sizeof( 0L );
  9e:	2304      	movs	r3, #4
  a0:	61bb      	str	r3, [r7, #24]
    size = sizeof( 0LL );
  a2:	2308      	movs	r3, #8
  a4:	61bb      	str	r3, [r7, #24]

	size = sizeof( int );
  a6:	2304      	movs	r3, #4
  a8:	61bb      	str	r3, [r7, #24]
	size = sizeof( unsigned int );
  aa:	2304      	movs	r3, #4
  ac:	61bb      	str	r3, [r7, #24]
	bitCount = CHAR_BIT * sizeof( unsigned int );
  ae:	2320      	movs	r3, #32
  b0:	617b      	str	r3, [r7, #20]

	size = sizeof( i );
  b2:	2304      	movs	r3, #4
  b4:	61bb      	str	r3, [r7, #24]
	size = sizeof( ui );
  b6:	2304      	movs	r3, #4
  b8:	61bb      	str	r3, [r7, #24]

	ui = (unsigned) 0xFFFFFFFF;
  ba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  be:	65bb      	str	r3, [r7, #88]	; 0x58
	i  = (signed) ui;
  c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  c2:	663b      	str	r3, [r7, #96]	; 0x60
    ui = 0xFFFFFFFF;
  c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  c8:	65bb      	str	r3, [r7, #88]	; 0x58

    // !
    // i = ui / ( i + 1 );

    int x = -1;
  ca:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  ce:	60fb      	str	r3, [r7, #12]
    int y = 4294967295;
  d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  d4:	60bb      	str	r3, [r7, #8]
    _Bool result = x == y;
  d6:	68fa      	ldr	r2, [r7, #12]
  d8:	68bb      	ldr	r3, [r7, #8]
  da:	429a      	cmp	r2, r3
  dc:	bf0c      	ite	eq
  de:	2301      	moveq	r3, #1
  e0:	2300      	movne	r3, #0
  e2:	71fb      	strb	r3, [r7, #7]
	
}//integers
  e4:	bf00      	nop
  e6:	3774      	adds	r7, #116	; 0x74
  e8:	46bd      	mov	sp, r7
  ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  ee:	4770      	bx	lr

Disassembly of section .text.decimals_Float:

00000000 <decimals_Float>:


// refer: www.stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number
// refer: www.en.wikipedia.org/wiki/Subnormal_number
// https://observablehq.com/@rreusser/half-precision-floating-point-visualized
void decimals_Float( void ) {
   0:	b580      	push	{r7, lr}
   2:	b08a      	sub	sp, #40	; 0x28
   4:	af00      	add	r7, sp, #0

   float fA = .0F;
   6:	f04f 0300 	mov.w	r3, #0
   a:	627b      	str	r3, [r7, #36]	; 0x24
   float fB = .0F;
   c:	f04f 0300 	mov.w	r3, #0
  10:	623b      	str	r3, [r7, #32]

   unsigned int count = 0;
  12:	2300      	movs	r3, #0
  14:	61fb      	str	r3, [r7, #28]
   int value = 0;
  16:	2300      	movs	r3, #0
  18:	61bb      	str	r3, [r7, #24]
   size_t size = 0;
  1a:	2300      	movs	r3, #0
  1c:	617b      	str	r3, [r7, #20]

   // size in memory as bytes
   size = sizeof( float );
  1e:	2304      	movs	r3, #4
  20:	617b      	str	r3, [r7, #20]
   size = sizeof( fA );
  22:	2304      	movs	r3, #4
  24:	617b      	str	r3, [r7, #20]

   // bit count
   size = CHAR_BIT * sizeof( float );
  26:	2320      	movs	r3, #32
  28:	617b      	str	r3, [r7, #20]

   // include float.h
   fA = FLT_MIN;
  2a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  2e:	627b      	str	r3, [r7, #36]	; 0x24
   fA = FLT_MAX;
  30:	4b2c      	ldr	r3, [pc, #176]	; (e4 <decimals_Float+0xe4>)
  32:	627b      	str	r3, [r7, #36]	; 0x24

   // mantissa, precision  0.000000
   count = FLT_DIG;
  34:	2306      	movs	r3, #6
  36:	61fb      	str	r3, [r7, #28]

   // base 10 of the exponent part of a float.
   value = FLT_MIN_10_EXP;
  38:	f06f 0324 	mvn.w	r3, #36	; 0x24
  3c:	61bb      	str	r3, [r7, #24]
   value = FLT_MAX_10_EXP;
  3e:	2326      	movs	r3, #38	; 0x26
  40:	61bb      	str	r3, [r7, #24]

   float epsilon = FLT_EPSILON;
  42:	f04f 5350 	mov.w	r3, #872415232	; 0x34000000
  46:	613b      	str	r3, [r7, #16]

   fA = .0F / .0F;
  48:	eddf 7a27 	vldr	s15, [pc, #156]	; e8 <decimals_Float+0xe8>
  4c:	ee87 7aa7 	vdiv.f32	s14, s15, s15
  50:	ed87 7a09 	vstr	s14, [r7, #36]	; 0x24

   fB = sqrtf( -1.00F ); // math.h
  54:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
  58:	f7ff fffe 	bl	0 <sqrtf>
  5c:	ed87 0a08 	vstr	s0, [r7, #32]
   fB = 1.0F / .00F;
  60:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  64:	ed9f 7a20 	vldr	s14, [pc, #128]	; e8 <decimals_Float+0xe8>
  68:	eec6 7a87 	vdiv.f32	s15, s13, s14
  6c:	edc7 7a08 	vstr	s15, [r7, #32]
   fB = INFINITY;
  70:	f04f 43ff 	mov.w	r3, #2139095040	; 0x7f800000
  74:	623b      	str	r3, [r7, #32]

   float posInf =  1.0F / 0.0F;
  76:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  7a:	ed9f 7a1b 	vldr	s14, [pc, #108]	; e8 <decimals_Float+0xe8>
  7e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  82:	edc7 7a03 	vstr	s15, [r7, #12]
   float negInf = -1.0F / 0.0F;
  86:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
  8a:	ed9f 7a17 	vldr	s14, [pc, #92]	; e8 <decimals_Float+0xe8>
  8e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  92:	edc7 7a02 	vstr	s15, [r7, #8]

   _Bool result = true;
  96:	2301      	movs	r3, #1
  98:	71fb      	strb	r3, [r7, #7]

   fA = NAN;
  9a:	4b14      	ldr	r3, [pc, #80]	; (ec <decimals_Float+0xec>)
  9c:	627b      	str	r3, [r7, #36]	; 0x24

   result = fA == NAN;
  9e:	2300      	movs	r3, #0
  a0:	71fb      	strb	r3, [r7, #7]
   result = fA == fA;
  a2:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
  a6:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  aa:	eeb4 7a67 	vcmp.f32	s14, s15
  ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  b2:	bf0c      	ite	eq
  b4:	2301      	moveq	r3, #1
  b6:	2300      	movne	r3, #0
  b8:	71fb      	strb	r3, [r7, #7]

   result = NAN == NAN;
  ba:	2300      	movs	r3, #0
  bc:	71fb      	strb	r3, [r7, #7]
   result = NAN != NAN;
  be:	2301      	movs	r3, #1
  c0:	71fb      	strb	r3, [r7, #7]

   // include math.h
   result = isnan( fA );
  c2:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
  c6:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  ca:	eeb4 7a67 	vcmp.f32	s14, s15
  ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  d2:	bf6c      	ite	vs
  d4:	2301      	movvs	r3, #1
  d6:	2300      	movvc	r3, #0
  d8:	71fb      	strb	r3, [r7, #7]

}//decimals_Float
  da:	bf00      	nop
  dc:	3728      	adds	r7, #40	; 0x28
  de:	46bd      	mov	sp, r7
  e0:	bd80      	pop	{r7, pc}
  e2:	bf00      	nop
  e4:	7f7fffff 	.word	0x7f7fffff
  e8:	00000000 	.word	0x00000000
  ec:	7fc00000 	.word	0x7fc00000

Disassembly of section .text.decimals_Double:

00000000 <decimals_Double>:

//-----------------------------------------------------------------------------

void decimals_Double( void ) {
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0

   // TODO : implement the same aspects of floats as in decimals_Float() for the "double" type   

}//decimals_Double
   4:	bf00      	nop
   6:	46bd      	mov	sp, r7
   8:	f85d 7b04 	ldr.w	r7, [sp], #4
   c:	4770      	bx	lr

Disassembly of section .text.floatQuirks:

00000000 <floatQuirks>:

//-----------------------------------------------------------------------------

void floatQuirks( void ) {
   0:	b590      	push	{r4, r7, lr}
   2:	b095      	sub	sp, #84	; 0x54
   4:	af00      	add	r7, sp, #0

	float x = 1.1;
   6:	4bb6      	ldr	r3, [pc, #728]	; (2e0 <floatQuirks+0x2e0>)
   8:	637b      	str	r3, [r7, #52]	; 0x34
	_Bool result = x != 1.1;
   a:	6b78      	ldr	r0, [r7, #52]	; 0x34
   c:	f7ff fffe 	bl	0 <__aeabi_f2d>
  10:	2301      	movs	r3, #1
  12:	461c      	mov	r4, r3
  14:	a3aa      	add	r3, pc, #680	; (adr r3, 2c0 <floatQuirks+0x2c0>)
  16:	e9d3 2300 	ldrd	r2, r3, [r3]
  1a:	f7ff fffe 	bl	0 <__aeabi_dcmpeq>
  1e:	4603      	mov	r3, r0
  20:	2b00      	cmp	r3, #0
  22:	d001      	beq.n	28 <floatQuirks+0x28>
  24:	2300      	movs	r3, #0
  26:	461c      	mov	r4, r3
  28:	f887 4033 	strb.w	r4, [r7, #51]	; 0x33

    result = (float)x != (double)1.1;
  2c:	6b78      	ldr	r0, [r7, #52]	; 0x34
  2e:	f7ff fffe 	bl	0 <__aeabi_f2d>
  32:	2301      	movs	r3, #1
  34:	461c      	mov	r4, r3
  36:	a3a2      	add	r3, pc, #648	; (adr r3, 2c0 <floatQuirks+0x2c0>)
  38:	e9d3 2300 	ldrd	r2, r3, [r3]
  3c:	f7ff fffe 	bl	0 <__aeabi_dcmpeq>
  40:	4603      	mov	r3, r0
  42:	2b00      	cmp	r3, #0
  44:	d001      	beq.n	4a <floatQuirks+0x4a>
  46:	2300      	movs	r3, #0
  48:	461c      	mov	r4, r3
  4a:	f887 4033 	strb.w	r4, [r7, #51]	; 0x33
    result = x != 1.1F;
  4e:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
  52:	ed9f 7aa4 	vldr	s14, [pc, #656]	; 2e4 <floatQuirks+0x2e4>
  56:	eef4 7a47 	vcmp.f32	s15, s14
  5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  5e:	bf14      	ite	ne
  60:	2301      	movne	r3, #1
  62:	2300      	moveq	r3, #0
  64:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

   float f = 0.1F;
  68:	4b9f      	ldr	r3, [pc, #636]	; (2e8 <floatQuirks+0x2e8>)
  6a:	64fb      	str	r3, [r7, #76]	; 0x4c

   // runtime calculations of values
   f = 0.0F;
  6c:	f04f 0300 	mov.w	r3, #0
  70:	64fb      	str	r3, [r7, #76]	; 0x4c
   f += 0.2F;
  72:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  76:	ed9f 7a9d 	vldr	s14, [pc, #628]	; 2ec <floatQuirks+0x2ec>
  7a:	ee77 7a87 	vadd.f32	s15, s15, s14
  7e:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   f += 0.2F;
  82:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  86:	ed9f 7a99 	vldr	s14, [pc, #612]	; 2ec <floatQuirks+0x2ec>
  8a:	ee77 7a87 	vadd.f32	s15, s15, s14
  8e:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c

   f += 0.2F;
  92:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  96:	ed9f 7a95 	vldr	s14, [pc, #596]	; 2ec <floatQuirks+0x2ec>
  9a:	ee77 7a87 	vadd.f32	s15, s15, s14
  9e:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   f += 0.2F;
  a2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  a6:	ed9f 7a91 	vldr	s14, [pc, #580]	; 2ec <floatQuirks+0x2ec>
  aa:	ee77 7a87 	vadd.f32	s15, s15, s14
  ae:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   f += 0.2F;
  b2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  b6:	ed9f 7a8d 	vldr	s14, [pc, #564]	; 2ec <floatQuirks+0x2ec>
  ba:	ee77 7a87 	vadd.f32	s15, s15, s14
  be:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c

   f += 0.2F;
  c2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  c6:	ed9f 7a89 	vldr	s14, [pc, #548]	; 2ec <floatQuirks+0x2ec>
  ca:	ee77 7a87 	vadd.f32	s15, s15, s14
  ce:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   f += 0.2F;
  d2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  d6:	ed9f 7a85 	vldr	s14, [pc, #532]	; 2ec <floatQuirks+0x2ec>
  da:	ee77 7a87 	vadd.f32	s15, s15, s14
  de:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c

   f += 0.2F;
  e2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  e6:	ed9f 7a81 	vldr	s14, [pc, #516]	; 2ec <floatQuirks+0x2ec>
  ea:	ee77 7a87 	vadd.f32	s15, s15, s14
  ee:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   f += 0.2F;
  f2:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  f6:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 2ec <floatQuirks+0x2ec>
  fa:	ee77 7a87 	vadd.f32	s15, s15, s14
  fe:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   f += 0.2F;
 102:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 106:	ed9f 7a79 	vldr	s14, [pc, #484]	; 2ec <floatQuirks+0x2ec>
 10a:	ee77 7a87 	vadd.f32	s15, s15, s14
 10e:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c

   // compile time calculations of values
   float ft = 0.2F * 10;
 112:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 116:	62fb      	str	r3, [r7, #44]	; 0x2c
   float fs = 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F + 0.2F;
 118:	4b75      	ldr	r3, [pc, #468]	; (2f0 <floatQuirks+0x2f0>)
 11a:	62bb      	str	r3, [r7, #40]	; 0x28

   float fk = 0.5F;
 11c:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 120:	627b      	str	r3, [r7, #36]	; 0x24
   fk = 2.5F;
 122:	4b74      	ldr	r3, [pc, #464]	; (2f4 <floatQuirks+0x2f4>)
 124:	627b      	str	r3, [r7, #36]	; 0x24
   float fk1 = 0;
 126:	f04f 0300 	mov.w	r3, #0
 12a:	623b      	str	r3, [r7, #32]

   // runtime calculations of values
   fk1 += 2.6F;
 12c:	edd7 7a08 	vldr	s15, [r7, #32]
 130:	ed9f 7a71 	vldr	s14, [pc, #452]	; 2f8 <floatQuirks+0x2f8>
 134:	ee77 7a87 	vadd.f32	s15, s15, s14
 138:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 13c:	edd7 7a08 	vldr	s15, [r7, #32]
 140:	ed9f 7a6d 	vldr	s14, [pc, #436]	; 2f8 <floatQuirks+0x2f8>
 144:	ee77 7a87 	vadd.f32	s15, s15, s14
 148:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 14c:	edd7 7a08 	vldr	s15, [r7, #32]
 150:	ed9f 7a69 	vldr	s14, [pc, #420]	; 2f8 <floatQuirks+0x2f8>
 154:	ee77 7a87 	vadd.f32	s15, s15, s14
 158:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 15c:	edd7 7a08 	vldr	s15, [r7, #32]
 160:	ed9f 7a65 	vldr	s14, [pc, #404]	; 2f8 <floatQuirks+0x2f8>
 164:	ee77 7a87 	vadd.f32	s15, s15, s14
 168:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 16c:	edd7 7a08 	vldr	s15, [r7, #32]
 170:	ed9f 7a61 	vldr	s14, [pc, #388]	; 2f8 <floatQuirks+0x2f8>
 174:	ee77 7a87 	vadd.f32	s15, s15, s14
 178:	edc7 7a08 	vstr	s15, [r7, #32]

   fk1 += 2.6F;
 17c:	edd7 7a08 	vldr	s15, [r7, #32]
 180:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 2f8 <floatQuirks+0x2f8>
 184:	ee77 7a87 	vadd.f32	s15, s15, s14
 188:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 18c:	edd7 7a08 	vldr	s15, [r7, #32]
 190:	ed9f 7a59 	vldr	s14, [pc, #356]	; 2f8 <floatQuirks+0x2f8>
 194:	ee77 7a87 	vadd.f32	s15, s15, s14
 198:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 19c:	edd7 7a08 	vldr	s15, [r7, #32]
 1a0:	ed9f 7a55 	vldr	s14, [pc, #340]	; 2f8 <floatQuirks+0x2f8>
 1a4:	ee77 7a87 	vadd.f32	s15, s15, s14
 1a8:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 1ac:	edd7 7a08 	vldr	s15, [r7, #32]
 1b0:	ed9f 7a51 	vldr	s14, [pc, #324]	; 2f8 <floatQuirks+0x2f8>
 1b4:	ee77 7a87 	vadd.f32	s15, s15, s14
 1b8:	edc7 7a08 	vstr	s15, [r7, #32]
   fk1 += 2.6F;
 1bc:	edd7 7a08 	vldr	s15, [r7, #32]
 1c0:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 2f8 <floatQuirks+0x2f8>
 1c4:	ee77 7a87 	vadd.f32	s15, s15, s14
 1c8:	edc7 7a08 	vstr	s15, [r7, #32]

   float fk2 = 2.6F * 10;
 1cc:	4b4b      	ldr	r3, [pc, #300]	; (2fc <floatQuirks+0x2fc>)
 1ce:	61fb      	str	r3, [r7, #28]

   result = fk1 == fk2;
 1d0:	ed97 7a08 	vldr	s14, [r7, #32]
 1d4:	edd7 7a07 	vldr	s15, [r7, #28]
 1d8:	eeb4 7a67 	vcmp.f32	s14, s15
 1dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 1e0:	bf0c      	ite	eq
 1e2:	2301      	moveq	r3, #1
 1e4:	2300      	movne	r3, #0
 1e6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

   int loop = 10;
 1ea:	230a      	movs	r3, #10
 1ec:	64bb      	str	r3, [r7, #72]	; 0x48
   f = 0.0F;
 1ee:	f04f 0300 	mov.w	r3, #0
 1f2:	64fb      	str	r3, [r7, #76]	; 0x4c

   double value = .02;
 1f4:	a334      	add	r3, pc, #208	; (adr r3, 2c8 <floatQuirks+0x2c8>)
 1f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 1fa:	e9c7 2304 	strd	r2, r3, [r7, #16]
   double diff = value - value;
 1fe:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 202:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 206:	f7ff fffe 	bl	0 <__aeabi_dsub>
 20a:	4602      	mov	r2, r0
 20c:	460b      	mov	r3, r1
 20e:	e9c7 2302 	strd	r2, r3, [r7, #8]
   result = diff == NAN;
 212:	2300      	movs	r3, #0
 214:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33


   while ( loop-- ) {
 218:	e007      	b.n	22a <floatQuirks+0x22a>
      f += 0.1F;
 21a:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 21e:	ed9f 7a38 	vldr	s14, [pc, #224]	; 300 <floatQuirks+0x300>
 222:	ee77 7a87 	vadd.f32	s15, s15, s14
 226:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   while ( loop-- ) {
 22a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 22c:	1e5a      	subs	r2, r3, #1
 22e:	64ba      	str	r2, [r7, #72]	; 0x48
 230:	2b00      	cmp	r3, #0
 232:	d1f2      	bne.n	21a <floatQuirks+0x21a>
   }


   f = 0.0F;
 234:	f04f 0300 	mov.w	r3, #0
 238:	64fb      	str	r3, [r7, #76]	; 0x4c
   for ( int j = 0 ; j < 10; j++ ){
 23a:	2300      	movs	r3, #0
 23c:	647b      	str	r3, [r7, #68]	; 0x44
 23e:	e00a      	b.n	256 <floatQuirks+0x256>
      f += 0.1F;
 240:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 244:	ed9f 7a2e 	vldr	s14, [pc, #184]	; 300 <floatQuirks+0x300>
 248:	ee77 7a87 	vadd.f32	s15, s15, s14
 24c:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
   for ( int j = 0 ; j < 10; j++ ){
 250:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 252:	3301      	adds	r3, #1
 254:	647b      	str	r3, [r7, #68]	; 0x44
 256:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 258:	2b09      	cmp	r3, #9
 25a:	ddf1      	ble.n	240 <floatQuirks+0x240>
   }

   result = f == ( 10 * 0.1F );
 25c:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
 260:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 264:	eef4 7a47 	vcmp.f32	s15, s14
 268:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 26c:	bf0c      	ite	eq
 26e:	2301      	moveq	r3, #1
 270:	2300      	movne	r3, #0
 272:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

   float secondFromStart = nextafterf( FLT_EPSILON, INFINITY );
 276:	4b23      	ldr	r3, [pc, #140]	; (304 <floatQuirks+0x304>)
 278:	607b      	str	r3, [r7, #4]

   // round(256.49999) == 256;
   // roundf(256.49999) == 257;

   // for(ever) : http://www.youtube.com/watch?v=IJNR2EpS0jw
   for( double d = 0; d != 0.3; d += 0.1 );
 27a:	f04f 0200 	mov.w	r2, #0
 27e:	f04f 0300 	mov.w	r3, #0
 282:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 286:	e00a      	b.n	29e <floatQuirks+0x29e>
 288:	a311      	add	r3, pc, #68	; (adr r3, 2d0 <floatQuirks+0x2d0>)
 28a:	e9d3 2300 	ldrd	r2, r3, [r3]
 28e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 292:	f7ff fffe 	bl	0 <__aeabi_dadd>
 296:	4602      	mov	r2, r0
 298:	460b      	mov	r3, r1
 29a:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
 29e:	a30e      	add	r3, pc, #56	; (adr r3, 2d8 <floatQuirks+0x2d8>)
 2a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 2a4:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 2a8:	f7ff fffe 	bl	0 <__aeabi_dcmpeq>
 2ac:	4603      	mov	r3, r0
 2ae:	2b00      	cmp	r3, #0
 2b0:	d0ea      	beq.n	288 <floatQuirks+0x288>

}//floatQuirks
 2b2:	bf00      	nop
 2b4:	bf00      	nop
 2b6:	3754      	adds	r7, #84	; 0x54
 2b8:	46bd      	mov	sp, r7
 2ba:	bd90      	pop	{r4, r7, pc}
 2bc:	f3af 8000 	nop.w
 2c0:	9999999a 	.word	0x9999999a
 2c4:	3ff19999 	.word	0x3ff19999
 2c8:	47ae147b 	.word	0x47ae147b
 2cc:	3f947ae1 	.word	0x3f947ae1
 2d0:	9999999a 	.word	0x9999999a
 2d4:	3fb99999 	.word	0x3fb99999
 2d8:	33333333 	.word	0x33333333
 2dc:	3fd33333 	.word	0x3fd33333
 2e0:	3f8ccccd 	.word	0x3f8ccccd
 2e4:	3f8ccccd 	.word	0x3f8ccccd
 2e8:	3dcccccd 	.word	0x3dcccccd
 2ec:	3e4ccccd 	.word	0x3e4ccccd
 2f0:	40000001 	.word	0x40000001
 2f4:	40200000 	.word	0x40200000
 2f8:	40266666 	.word	0x40266666
 2fc:	41d00000 	.word	0x41d00000
 300:	3dcccccd 	.word	0x3dcccccd
 304:	34000001 	.word	0x34000001

Disassembly of section .text.operators_equality:

00000000 <operators_equality>:

//-----------------------------------------------------------------------------


void operators_equality(void){
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int a = 2;
   6:	2302      	movs	r3, #2
   8:	60fb      	str	r3, [r7, #12]
   int b = 3;
   a:	2303      	movs	r3, #3
   c:	60bb      	str	r3, [r7, #8]
   int c = 2;
   e:	2302      	movs	r3, #2
  10:	607b      	str	r3, [r7, #4]

   _Bool result = 0;
  12:	2300      	movs	r3, #0
  14:	70fb      	strb	r3, [r7, #3]

   // equality
   result = a == a;
  16:	2301      	movs	r3, #1
  18:	70fb      	strb	r3, [r7, #3]

   result = a == b;
  1a:	68fa      	ldr	r2, [r7, #12]
  1c:	68bb      	ldr	r3, [r7, #8]
  1e:	429a      	cmp	r2, r3
  20:	bf0c      	ite	eq
  22:	2301      	moveq	r3, #1
  24:	2300      	movne	r3, #0
  26:	70fb      	strb	r3, [r7, #3]

   result = a == c;
  28:	68fa      	ldr	r2, [r7, #12]
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	429a      	cmp	r2, r3
  2e:	bf0c      	ite	eq
  30:	2301      	moveq	r3, #1
  32:	2300      	movne	r3, #0
  34:	70fb      	strb	r3, [r7, #3]

   result = c == b;
  36:	687a      	ldr	r2, [r7, #4]
  38:	68bb      	ldr	r3, [r7, #8]
  3a:	429a      	cmp	r2, r3
  3c:	bf0c      	ite	eq
  3e:	2301      	moveq	r3, #1
  40:	2300      	movne	r3, #0
  42:	70fb      	strb	r3, [r7, #3]


   // inequality
   result = a != a;
  44:	2300      	movs	r3, #0
  46:	70fb      	strb	r3, [r7, #3]

   result = a != b;
  48:	68fa      	ldr	r2, [r7, #12]
  4a:	68bb      	ldr	r3, [r7, #8]
  4c:	429a      	cmp	r2, r3
  4e:	bf14      	ite	ne
  50:	2301      	movne	r3, #1
  52:	2300      	moveq	r3, #0
  54:	70fb      	strb	r3, [r7, #3]

   result = a != c;
  56:	68fa      	ldr	r2, [r7, #12]
  58:	687b      	ldr	r3, [r7, #4]
  5a:	429a      	cmp	r2, r3
  5c:	bf14      	ite	ne
  5e:	2301      	movne	r3, #1
  60:	2300      	moveq	r3, #0
  62:	70fb      	strb	r3, [r7, #3]

   result = c != b;
  64:	687a      	ldr	r2, [r7, #4]
  66:	68bb      	ldr	r3, [r7, #8]
  68:	429a      	cmp	r2, r3
  6a:	bf14      	ite	ne
  6c:	2301      	movne	r3, #1
  6e:	2300      	moveq	r3, #0
  70:	70fb      	strb	r3, [r7, #3]

}//operators_equality
  72:	bf00      	nop
  74:	3714      	adds	r7, #20
  76:	46bd      	mov	sp, r7
  78:	f85d 7b04 	ldr.w	r7, [sp], #4
  7c:	4770      	bx	lr

Disassembly of section .text.operators_relational:

00000000 <operators_relational>:

//-----------------------------------------------------------------------------

void operators_relational( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

  // see disassembly
  int a = 2;
   6:	2302      	movs	r3, #2
   8:	60fb      	str	r3, [r7, #12]
  int b = 3;
   a:	2303      	movs	r3, #3
   c:	60bb      	str	r3, [r7, #8]
  int c = 0;
   e:	2300      	movs	r3, #0
  10:	607b      	str	r3, [r7, #4]

  _Bool result = 0;
  12:	2300      	movs	r3, #0
  14:	70fb      	strb	r3, [r7, #3]

  result = a > b;
  16:	68fa      	ldr	r2, [r7, #12]
  18:	68bb      	ldr	r3, [r7, #8]
  1a:	429a      	cmp	r2, r3
  1c:	bfcc      	ite	gt
  1e:	2301      	movgt	r3, #1
  20:	2300      	movle	r3, #0
  22:	70fb      	strb	r3, [r7, #3]

  result = a >= b;
  24:	68fa      	ldr	r2, [r7, #12]
  26:	68bb      	ldr	r3, [r7, #8]
  28:	429a      	cmp	r2, r3
  2a:	bfac      	ite	ge
  2c:	2301      	movge	r3, #1
  2e:	2300      	movlt	r3, #0
  30:	70fb      	strb	r3, [r7, #3]

  result = a < b;
  32:	68fa      	ldr	r2, [r7, #12]
  34:	68bb      	ldr	r3, [r7, #8]
  36:	429a      	cmp	r2, r3
  38:	bfb4      	ite	lt
  3a:	2301      	movlt	r3, #1
  3c:	2300      	movge	r3, #0
  3e:	70fb      	strb	r3, [r7, #3]

  result = a <= b;
  40:	68fa      	ldr	r2, [r7, #12]
  42:	68bb      	ldr	r3, [r7, #8]
  44:	429a      	cmp	r2, r3
  46:	bfd4      	ite	le
  48:	2301      	movle	r3, #1
  4a:	2300      	movgt	r3, #0
  4c:	70fb      	strb	r3, [r7, #3]

}//operators_relational
  4e:	bf00      	nop
  50:	3714      	adds	r7, #20
  52:	46bd      	mov	sp, r7
  54:	f85d 7b04 	ldr.w	r7, [sp], #4
  58:	4770      	bx	lr

Disassembly of section .text.operators_logical:

00000000 <operators_logical>:

//-----------------------------------------------------------------------------

void operators_logical( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

  // see disassembly
  int a = 2;
   6:	2302      	movs	r3, #2
   8:	60fb      	str	r3, [r7, #12]
  int b = 3;
   a:	2303      	movs	r3, #3
   c:	60bb      	str	r3, [r7, #8]
  int c = 0;
   e:	2300      	movs	r3, #0
  10:	607b      	str	r3, [r7, #4]

  _Bool result = 0;
  12:	2300      	movs	r3, #0
  14:	70fb      	strb	r3, [r7, #3]

  // equality
  result = a == a;
  16:	2301      	movs	r3, #1
  18:	70fb      	strb	r3, [r7, #3]
  result = !( a != b );
  1a:	68fa      	ldr	r2, [r7, #12]
  1c:	68bb      	ldr	r3, [r7, #8]
  1e:	429a      	cmp	r2, r3
  20:	bf0c      	ite	eq
  22:	2301      	moveq	r3, #1
  24:	2300      	movne	r3, #0
  26:	70fb      	strb	r3, [r7, #3]

  // inequality
  result = a != b;
  28:	68fa      	ldr	r2, [r7, #12]
  2a:	68bb      	ldr	r3, [r7, #8]
  2c:	429a      	cmp	r2, r3
  2e:	bf14      	ite	ne
  30:	2301      	movne	r3, #1
  32:	2300      	moveq	r3, #0
  34:	70fb      	strb	r3, [r7, #3]
  result = !( a == b );
  36:	68fa      	ldr	r2, [r7, #12]
  38:	68bb      	ldr	r3, [r7, #8]
  3a:	429a      	cmp	r2, r3
  3c:	bf14      	ite	ne
  3e:	2301      	movne	r3, #1
  40:	2300      	moveq	r3, #0
  42:	70fb      	strb	r3, [r7, #3]

  // logical and
  result = ( a > b ) && ( b > c );
  44:	68fa      	ldr	r2, [r7, #12]
  46:	68bb      	ldr	r3, [r7, #8]
  48:	429a      	cmp	r2, r3
  4a:	dd05      	ble.n	58 <operators_logical+0x58>
  4c:	68ba      	ldr	r2, [r7, #8]
  4e:	687b      	ldr	r3, [r7, #4]
  50:	429a      	cmp	r2, r3
  52:	dd01      	ble.n	58 <operators_logical+0x58>
  54:	2301      	movs	r3, #1
  56:	e000      	b.n	5a <operators_logical+0x5a>
  58:	2300      	movs	r3, #0
  5a:	70fb      	strb	r3, [r7, #3]
  5c:	78fb      	ldrb	r3, [r7, #3]
  5e:	f003 0301 	and.w	r3, r3, #1
  62:	70fb      	strb	r3, [r7, #3]

  // logical inclusive or
  result = ( a > b ) || ( b > c );
  64:	68fa      	ldr	r2, [r7, #12]
  66:	68bb      	ldr	r3, [r7, #8]
  68:	429a      	cmp	r2, r3
  6a:	dc03      	bgt.n	74 <operators_logical+0x74>
  6c:	68ba      	ldr	r2, [r7, #8]
  6e:	687b      	ldr	r3, [r7, #4]
  70:	429a      	cmp	r2, r3
  72:	dd01      	ble.n	78 <operators_logical+0x78>
  74:	2301      	movs	r3, #1
  76:	e000      	b.n	7a <operators_logical+0x7a>
  78:	2300      	movs	r3, #0
  7a:	70fb      	strb	r3, [r7, #3]
  7c:	78fb      	ldrb	r3, [r7, #3]
  7e:	f003 0301 	and.w	r3, r3, #1
  82:	70fb      	strb	r3, [r7, #3]

  // logical exclusive or (equivalent)
  result = ( a > b ) != ( b > c );
  84:	68fa      	ldr	r2, [r7, #12]
  86:	68bb      	ldr	r3, [r7, #8]
  88:	429a      	cmp	r2, r3
  8a:	bfcc      	ite	gt
  8c:	2301      	movgt	r3, #1
  8e:	2300      	movle	r3, #0
  90:	b2da      	uxtb	r2, r3
  92:	68b9      	ldr	r1, [r7, #8]
  94:	687b      	ldr	r3, [r7, #4]
  96:	4299      	cmp	r1, r3
  98:	bfcc      	ite	gt
  9a:	2301      	movgt	r3, #1
  9c:	2300      	movle	r3, #0
  9e:	b2db      	uxtb	r3, r3
  a0:	4053      	eors	r3, r2
  a2:	b2db      	uxtb	r3, r3
  a4:	70fb      	strb	r3, [r7, #3]
  a6:	78fb      	ldrb	r3, [r7, #3]
  a8:	f003 0301 	and.w	r3, r3, #1
  ac:	70fb      	strb	r3, [r7, #3]

  // bool normalized exclusive or (equivalent)
  result = !a != !c;
  ae:	68fb      	ldr	r3, [r7, #12]
  b0:	2b00      	cmp	r3, #0
  b2:	bf0c      	ite	eq
  b4:	2301      	moveq	r3, #1
  b6:	2300      	movne	r3, #0
  b8:	b2da      	uxtb	r2, r3
  ba:	687b      	ldr	r3, [r7, #4]
  bc:	2b00      	cmp	r3, #0
  be:	bf0c      	ite	eq
  c0:	2301      	moveq	r3, #1
  c2:	2300      	movne	r3, #0
  c4:	b2db      	uxtb	r3, r3
  c6:	4053      	eors	r3, r2
  c8:	b2db      	uxtb	r3, r3
  ca:	70fb      	strb	r3, [r7, #3]
  cc:	78fb      	ldrb	r3, [r7, #3]
  ce:	f003 0301 	and.w	r3, r3, #1
  d2:	70fb      	strb	r3, [r7, #3]
  result = (_Bool)a != (_Bool)c;
  d4:	68fb      	ldr	r3, [r7, #12]
  d6:	2b00      	cmp	r3, #0
  d8:	bf14      	ite	ne
  da:	2301      	movne	r3, #1
  dc:	2300      	moveq	r3, #0
  de:	b2da      	uxtb	r2, r3
  e0:	687b      	ldr	r3, [r7, #4]
  e2:	2b00      	cmp	r3, #0
  e4:	bf14      	ite	ne
  e6:	2301      	movne	r3, #1
  e8:	2300      	moveq	r3, #0
  ea:	b2db      	uxtb	r3, r3
  ec:	4053      	eors	r3, r2
  ee:	b2db      	uxtb	r3, r3
  f0:	70fb      	strb	r3, [r7, #3]
  f2:	78fb      	ldrb	r3, [r7, #3]
  f4:	f003 0301 	and.w	r3, r3, #1
  f8:	70fb      	strb	r3, [r7, #3]

  result = a >= b;
  fa:	68fa      	ldr	r2, [r7, #12]
  fc:	68bb      	ldr	r3, [r7, #8]
  fe:	429a      	cmp	r2, r3
 100:	bfac      	ite	ge
 102:	2301      	movge	r3, #1
 104:	2300      	movlt	r3, #0
 106:	70fb      	strb	r3, [r7, #3]
  result = !( a < b );
 108:	68fa      	ldr	r2, [r7, #12]
 10a:	68bb      	ldr	r3, [r7, #8]
 10c:	429a      	cmp	r2, r3
 10e:	bfac      	ite	ge
 110:	2301      	movge	r3, #1
 112:	2300      	movlt	r3, #0
 114:	70fb      	strb	r3, [r7, #3]

  result = a < b;
 116:	68fa      	ldr	r2, [r7, #12]
 118:	68bb      	ldr	r3, [r7, #8]
 11a:	429a      	cmp	r2, r3
 11c:	bfb4      	ite	lt
 11e:	2301      	movlt	r3, #1
 120:	2300      	movge	r3, #0
 122:	70fb      	strb	r3, [r7, #3]
  result = !( a >= b );
 124:	68fa      	ldr	r2, [r7, #12]
 126:	68bb      	ldr	r3, [r7, #8]
 128:	429a      	cmp	r2, r3
 12a:	bfb4      	ite	lt
 12c:	2301      	movlt	r3, #1
 12e:	2300      	movge	r3, #0
 130:	70fb      	strb	r3, [r7, #3]

  result = a <= b;
 132:	68fa      	ldr	r2, [r7, #12]
 134:	68bb      	ldr	r3, [r7, #8]
 136:	429a      	cmp	r2, r3
 138:	bfd4      	ite	le
 13a:	2301      	movle	r3, #1
 13c:	2300      	movgt	r3, #0
 13e:	70fb      	strb	r3, [r7, #3]
  result = !( a > b );
 140:	68fa      	ldr	r2, [r7, #12]
 142:	68bb      	ldr	r3, [r7, #8]
 144:	429a      	cmp	r2, r3
 146:	bfd4      	ite	le
 148:	2301      	movle	r3, #1
 14a:	2300      	movgt	r3, #0
 14c:	70fb      	strb	r3, [r7, #3]

}//operators_logical
 14e:	bf00      	nop
 150:	3714      	adds	r7, #20
 152:	46bd      	mov	sp, r7
 154:	f85d 7b04 	ldr.w	r7, [sp], #4
 158:	4770      	bx	lr

Disassembly of section .text.operators_assignment:

00000000 <operators_assignment>:

//-----------------------------------------------------------------------------

void operators_assignment( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int a = 2;
   6:	2302      	movs	r3, #2
   8:	60fb      	str	r3, [r7, #12]
   int b = 3;
   a:	2303      	movs	r3, #3
   c:	60bb      	str	r3, [r7, #8]
   int r = 0;
   e:	2300      	movs	r3, #0
  10:	607b      	str	r3, [r7, #4]

   r = r + 1;
  12:	687b      	ldr	r3, [r7, #4]
  14:	3301      	adds	r3, #1
  16:	607b      	str	r3, [r7, #4]
   r += 1;
  18:	687b      	ldr	r3, [r7, #4]
  1a:	3301      	adds	r3, #1
  1c:	607b      	str	r3, [r7, #4]

   r = r - 1;
  1e:	687b      	ldr	r3, [r7, #4]
  20:	3b01      	subs	r3, #1
  22:	607b      	str	r3, [r7, #4]
   r -= 1;
  24:	687b      	ldr	r3, [r7, #4]
  26:	3b01      	subs	r3, #1
  28:	607b      	str	r3, [r7, #4]

   r = 1;
  2a:	2301      	movs	r3, #1
  2c:	607b      	str	r3, [r7, #4]
   r = r * a;
  2e:	687b      	ldr	r3, [r7, #4]
  30:	68fa      	ldr	r2, [r7, #12]
  32:	fb02 f303 	mul.w	r3, r2, r3
  36:	607b      	str	r3, [r7, #4]
   r *= a;
  38:	687b      	ldr	r3, [r7, #4]
  3a:	68fa      	ldr	r2, [r7, #12]
  3c:	fb02 f303 	mul.w	r3, r2, r3
  40:	607b      	str	r3, [r7, #4]

   r = r / 2;
  42:	687b      	ldr	r3, [r7, #4]
  44:	0fda      	lsrs	r2, r3, #31
  46:	4413      	add	r3, r2
  48:	105b      	asrs	r3, r3, #1
  4a:	607b      	str	r3, [r7, #4]
   r /= 2;
  4c:	687b      	ldr	r3, [r7, #4]
  4e:	0fda      	lsrs	r2, r3, #31
  50:	4413      	add	r3, r2
  52:	105b      	asrs	r3, r3, #1
  54:	607b      	str	r3, [r7, #4]

   r = 5;
  56:	2305      	movs	r3, #5
  58:	607b      	str	r3, [r7, #4]
   r = r % 2;
  5a:	687b      	ldr	r3, [r7, #4]
  5c:	2b00      	cmp	r3, #0
  5e:	f003 0301 	and.w	r3, r3, #1
  62:	bfb8      	it	lt
  64:	425b      	neglt	r3, r3
  66:	607b      	str	r3, [r7, #4]

   r = 5;
  68:	2305      	movs	r3, #5
  6a:	607b      	str	r3, [r7, #4]
   r %=  2;
  6c:	687b      	ldr	r3, [r7, #4]
  6e:	2b00      	cmp	r3, #0
  70:	f003 0301 	and.w	r3, r3, #1
  74:	bfb8      	it	lt
  76:	425b      	neglt	r3, r3
  78:	607b      	str	r3, [r7, #4]

   // TODO : diğer "compound assignment" operatörleri

}//operators_assignment
  7a:	bf00      	nop
  7c:	3714      	adds	r7, #20
  7e:	46bd      	mov	sp, r7
  80:	f85d 7b04 	ldr.w	r7, [sp], #4
  84:	4770      	bx	lr

Disassembly of section .text.operators_conditionalExpression:

00000000 <operators_conditionalExpression>:

//-----------------------------------------------------------------------------

void operators_conditionalExpression( void ) {
   0:	b480      	push	{r7}
   2:	b089      	sub	sp, #36	; 0x24
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int a = 2;
   6:	2302      	movs	r3, #2
   8:	61fb      	str	r3, [r7, #28]
   int b = 3;
   a:	2303      	movs	r3, #3
   c:	61bb      	str	r3, [r7, #24]

   int min = 0;
   e:	2300      	movs	r3, #0
  10:	617b      	str	r3, [r7, #20]
   int max = 0;
  12:	2300      	movs	r3, #0
  14:	613b      	str	r3, [r7, #16]

   min =  a < b ? a : b;
  16:	69ba      	ldr	r2, [r7, #24]
  18:	69fb      	ldr	r3, [r7, #28]
  1a:	4293      	cmp	r3, r2
  1c:	bfa8      	it	ge
  1e:	4613      	movge	r3, r2
  20:	617b      	str	r3, [r7, #20]
   max =  a > b ? a : b;
  22:	69ba      	ldr	r2, [r7, #24]
  24:	69fb      	ldr	r3, [r7, #28]
  26:	4293      	cmp	r3, r2
  28:	bfb8      	it	lt
  2a:	4613      	movlt	r3, r2
  2c:	613b      	str	r3, [r7, #16]

   if ( a < b ) {
  2e:	69fa      	ldr	r2, [r7, #28]
  30:	69bb      	ldr	r3, [r7, #24]
  32:	429a      	cmp	r2, r3
  34:	da02      	bge.n	3c <operators_conditionalExpression+0x3c>
      min = a;
  36:	69fb      	ldr	r3, [r7, #28]
  38:	617b      	str	r3, [r7, #20]
  3a:	e001      	b.n	40 <operators_conditionalExpression+0x40>
   } else {
      min = b;
  3c:	69bb      	ldr	r3, [r7, #24]
  3e:	617b      	str	r3, [r7, #20]
   };

   if ( a > b ) {
  40:	69fa      	ldr	r2, [r7, #28]
  42:	69bb      	ldr	r3, [r7, #24]
  44:	429a      	cmp	r2, r3
  46:	dd02      	ble.n	4e <operators_conditionalExpression+0x4e>
      max = a;
  48:	69fb      	ldr	r3, [r7, #28]
  4a:	613b      	str	r3, [r7, #16]
  4c:	e001      	b.n	52 <operators_conditionalExpression+0x52>
   } else {
      max = b;
  4e:	69bb      	ldr	r3, [r7, #24]
  50:	613b      	str	r3, [r7, #16]
   };

   int  x    = 0;
  52:	2300      	movs	r3, #0
  54:	60fb      	str	r3, [r7, #12]
   char sign = '.';
  56:	232e      	movs	r3, #46	; 0x2e
  58:	72fb      	strb	r3, [r7, #11]

   x = 0;
  5a:	2300      	movs	r3, #0
  5c:	60fb      	str	r3, [r7, #12]
   sign = x < 0 ? '-' :
  5e:	68fb      	ldr	r3, [r7, #12]
  60:	2b00      	cmp	r3, #0
  62:	db06      	blt.n	72 <operators_conditionalExpression+0x72>
  64:	68fb      	ldr	r3, [r7, #12]
  66:	2b00      	cmp	r3, #0
  68:	dd01      	ble.n	6e <operators_conditionalExpression+0x6e>
  6a:	232b      	movs	r3, #43	; 0x2b
  6c:	e002      	b.n	74 <operators_conditionalExpression+0x74>
  6e:	232e      	movs	r3, #46	; 0x2e
  70:	e000      	b.n	74 <operators_conditionalExpression+0x74>
  72:	232d      	movs	r3, #45	; 0x2d
  74:	72fb      	strb	r3, [r7, #11]
          x > 0 ? '+' :
          '.';

   x = -5;
  76:	f06f 0304 	mvn.w	r3, #4
  7a:	60fb      	str	r3, [r7, #12]
   sign = x < 0 ? '-' :
  7c:	68fb      	ldr	r3, [r7, #12]
  7e:	2b00      	cmp	r3, #0
  80:	db06      	blt.n	90 <operators_conditionalExpression+0x90>
  82:	68fb      	ldr	r3, [r7, #12]
  84:	2b00      	cmp	r3, #0
  86:	dd01      	ble.n	8c <operators_conditionalExpression+0x8c>
  88:	232b      	movs	r3, #43	; 0x2b
  8a:	e002      	b.n	92 <operators_conditionalExpression+0x92>
  8c:	232e      	movs	r3, #46	; 0x2e
  8e:	e000      	b.n	92 <operators_conditionalExpression+0x92>
  90:	232d      	movs	r3, #45	; 0x2d
  92:	72fb      	strb	r3, [r7, #11]
          x > 0 ? '+' :
          '.';

   x = +5;
  94:	2305      	movs	r3, #5
  96:	60fb      	str	r3, [r7, #12]
   sign = x < 0 ? '-' :
  98:	68fb      	ldr	r3, [r7, #12]
  9a:	2b00      	cmp	r3, #0
  9c:	db06      	blt.n	ac <operators_conditionalExpression+0xac>
  9e:	68fb      	ldr	r3, [r7, #12]
  a0:	2b00      	cmp	r3, #0
  a2:	dd01      	ble.n	a8 <operators_conditionalExpression+0xa8>
  a4:	232b      	movs	r3, #43	; 0x2b
  a6:	e002      	b.n	ae <operators_conditionalExpression+0xae>
  a8:	232e      	movs	r3, #46	; 0x2e
  aa:	e000      	b.n	ae <operators_conditionalExpression+0xae>
  ac:	232d      	movs	r3, #45	; 0x2d
  ae:	72fb      	strb	r3, [r7, #11]
          x > 0 ? '+' :
          '.';

   enum { colder, cold, warm, hot, hotter } climate = colder;
  b0:	2300      	movs	r3, #0
  b2:	72bb      	strb	r3, [r7, #10]

   int c = 18;
  b4:	2312      	movs	r3, #18
  b6:	607b      	str	r3, [r7, #4]
   climate = ( c <= -10 ) ? colder :
  b8:	687b      	ldr	r3, [r7, #4]
  ba:	f113 0f09 	cmn.w	r3, #9
  be:	db1a      	blt.n	f6 <operators_conditionalExpression+0xf6>
  c0:	687b      	ldr	r3, [r7, #4]
  c2:	f113 0f09 	cmn.w	r3, #9
  c6:	db02      	blt.n	ce <operators_conditionalExpression+0xce>
             ( c > -10 ) && ( c <= 10 ) ? cold :
  c8:	687b      	ldr	r3, [r7, #4]
  ca:	2b0a      	cmp	r3, #10
  cc:	dd11      	ble.n	f2 <operators_conditionalExpression+0xf2>
   climate = ( c <= -10 ) ? colder :
  ce:	687b      	ldr	r3, [r7, #4]
  d0:	2b0a      	cmp	r3, #10
  d2:	dd02      	ble.n	da <operators_conditionalExpression+0xda>
             ( c >  10 ) && ( c <= 25 ) ? warm :
  d4:	687b      	ldr	r3, [r7, #4]
  d6:	2b19      	cmp	r3, #25
  d8:	dd09      	ble.n	ee <operators_conditionalExpression+0xee>
   climate = ( c <= -10 ) ? colder :
  da:	687b      	ldr	r3, [r7, #4]
  dc:	2b19      	cmp	r3, #25
  de:	dd04      	ble.n	ea <operators_conditionalExpression+0xea>
             ( c >  25 ) && ( c <= 35 ) ? hot  :
  e0:	687b      	ldr	r3, [r7, #4]
  e2:	2b23      	cmp	r3, #35	; 0x23
  e4:	dc01      	bgt.n	ea <operators_conditionalExpression+0xea>
   climate = ( c <= -10 ) ? colder :
  e6:	2303      	movs	r3, #3
  e8:	e006      	b.n	f8 <operators_conditionalExpression+0xf8>
  ea:	2304      	movs	r3, #4
  ec:	e004      	b.n	f8 <operators_conditionalExpression+0xf8>
  ee:	2302      	movs	r3, #2
  f0:	e002      	b.n	f8 <operators_conditionalExpression+0xf8>
  f2:	2301      	movs	r3, #1
  f4:	e000      	b.n	f8 <operators_conditionalExpression+0xf8>
  f6:	2300      	movs	r3, #0
  f8:	72bb      	strb	r3, [r7, #10]
             hotter;

}//operators_conditionalExpression
  fa:	bf00      	nop
  fc:	3724      	adds	r7, #36	; 0x24
  fe:	46bd      	mov	sp, r7
 100:	f85d 7b04 	ldr.w	r7, [sp], #4
 104:	4770      	bx	lr

Disassembly of section .text.operators_multiplicative:

00000000 <operators_multiplicative>:

//-----------------------------------------------------------------------------

void operators_multiplicative( void ) {
   0:	b480      	push	{r7}
   2:	b08f      	sub	sp, #60	; 0x3c
   4:	af00      	add	r7, sp, #0

   // see disassembly
   char ca = 2;
   6:	2302      	movs	r3, #2
   8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
   char cb = 3;
   c:	2303      	movs	r3, #3
   e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
   char cc = 0;
  12:	2300      	movs	r3, #0
  14:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35

   int ia = 2;
  18:	2302      	movs	r3, #2
  1a:	633b      	str	r3, [r7, #48]	; 0x30
   int ib = 3;
  1c:	2303      	movs	r3, #3
  1e:	62fb      	str	r3, [r7, #44]	; 0x2c
   int ic = 0;
  20:	2300      	movs	r3, #0
  22:	62bb      	str	r3, [r7, #40]	; 0x28

   unsigned int ua = 2;
  24:	2302      	movs	r3, #2
  26:	627b      	str	r3, [r7, #36]	; 0x24
   unsigned int ub = 3;
  28:	2303      	movs	r3, #3
  2a:	623b      	str	r3, [r7, #32]
   unsigned int uc = 0;
  2c:	2300      	movs	r3, #0
  2e:	61fb      	str	r3, [r7, #28]

   float fa = .2F;
  30:	4b32      	ldr	r3, [pc, #200]	; (fc <operators_multiplicative+0xfc>)
  32:	61bb      	str	r3, [r7, #24]
   float fb = .3F;
  34:	4b32      	ldr	r3, [pc, #200]	; (100 <operators_multiplicative+0x100>)
  36:	617b      	str	r3, [r7, #20]
   float fc = .0F;
  38:	f04f 0300 	mov.w	r3, #0
  3c:	613b      	str	r3, [r7, #16]

   cc = ca * cb;
  3e:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
  42:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
  46:	fb12 f303 	smulbb	r3, r2, r3
  4a:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
   cc = cc / ca;
  4e:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
  52:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  56:	fbb2 f3f3 	udiv	r3, r2, r3
  5a:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
   cc = cb % ca;
  5e:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
  62:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
  66:	fbb3 f1f2 	udiv	r1, r3, r2
  6a:	fb01 f202 	mul.w	r2, r1, r2
  6e:	1a9b      	subs	r3, r3, r2
  70:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35

   ic = ia * ib;
  74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  76:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  78:	fb02 f303 	mul.w	r3, r2, r3
  7c:	62bb      	str	r3, [r7, #40]	; 0x28
   ic = ic / ia;
  7e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  82:	fb92 f3f3 	sdiv	r3, r2, r3
  86:	62bb      	str	r3, [r7, #40]	; 0x28
   ic = ib % ia;
  88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  8a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  8c:	fb93 f2f2 	sdiv	r2, r3, r2
  90:	6b39      	ldr	r1, [r7, #48]	; 0x30
  92:	fb01 f202 	mul.w	r2, r1, r2
  96:	1a9b      	subs	r3, r3, r2
  98:	62bb      	str	r3, [r7, #40]	; 0x28

   uc = ua * ub;
  9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  9c:	6a3a      	ldr	r2, [r7, #32]
  9e:	fb02 f303 	mul.w	r3, r2, r3
  a2:	61fb      	str	r3, [r7, #28]
   uc = uc / ua;
  a4:	69fa      	ldr	r2, [r7, #28]
  a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  a8:	fbb2 f3f3 	udiv	r3, r2, r3
  ac:	61fb      	str	r3, [r7, #28]
   uc = ub % ua; // remainder
  ae:	6a3b      	ldr	r3, [r7, #32]
  b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  b2:	fbb3 f2f2 	udiv	r2, r3, r2
  b6:	6a79      	ldr	r1, [r7, #36]	; 0x24
  b8:	fb01 f202 	mul.w	r2, r1, r2
  bc:	1a9b      	subs	r3, r3, r2
  be:	61fb      	str	r3, [r7, #28]

   fc = fa * fb;
  c0:	ed97 7a06 	vldr	s14, [r7, #24]
  c4:	edd7 7a05 	vldr	s15, [r7, #20]
  c8:	ee67 7a27 	vmul.f32	s15, s14, s15
  cc:	edc7 7a04 	vstr	s15, [r7, #16]
   fc = fc / fa;
  d0:	edd7 6a04 	vldr	s13, [r7, #16]
  d4:	ed97 7a06 	vldr	s14, [r7, #24]
  d8:	eec6 7a87 	vdiv.f32	s15, s13, s14
  dc:	edc7 7a04 	vstr	s15, [r7, #16]

   //fc = fc % fa; // ?
   //fc = fc % ia; // ?

   // remainder
   int a =  3 % -2;
  e0:	2301      	movs	r3, #1
  e2:	60fb      	str	r3, [r7, #12]
   int b = -3 %  2;
  e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  e8:	60bb      	str	r3, [r7, #8]
   int c = -3 % -2;
  ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  ee:	607b      	str	r3, [r7, #4]
	
}//operators_multiplicative
  f0:	bf00      	nop
  f2:	373c      	adds	r7, #60	; 0x3c
  f4:	46bd      	mov	sp, r7
  f6:	f85d 7b04 	ldr.w	r7, [sp], #4
  fa:	4770      	bx	lr
  fc:	3e4ccccd 	.word	0x3e4ccccd
 100:	3e99999a 	.word	0x3e99999a

Disassembly of section .text.Remainder:

00000000 <Remainder>:

//-----------------------------------------------------------------------------

// remainder: causes conflict 
int Remainder( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

   return a - (a / b) * b;
   a:	687b      	ldr	r3, [r7, #4]
   c:	683a      	ldr	r2, [r7, #0]
   e:	fb93 f2f2 	sdiv	r2, r3, r2
  12:	6839      	ldr	r1, [r7, #0]
  14:	fb01 f202 	mul.w	r2, r1, r2
  18:	1a9b      	subs	r3, r3, r2

}
  1a:	4618      	mov	r0, r3
  1c:	370c      	adds	r7, #12
  1e:	46bd      	mov	sp, r7
  20:	f85d 7b04 	ldr.w	r7, [sp], #4
  24:	4770      	bx	lr

Disassembly of section .text.modulo:

00000000 <modulo>:

//-----------------------------------------------------------------------------

int modulo( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

   int r = a % b;
   a:	687b      	ldr	r3, [r7, #4]
   c:	683a      	ldr	r2, [r7, #0]
   e:	fb93 f2f2 	sdiv	r2, r3, r2
  12:	6839      	ldr	r1, [r7, #0]
  14:	fb01 f202 	mul.w	r2, r1, r2
  18:	1a9b      	subs	r3, r3, r2
  1a:	60fb      	str	r3, [r7, #12]
   return r < 0 ? r + b : r;
  1c:	68fb      	ldr	r3, [r7, #12]
  1e:	2b00      	cmp	r3, #0
  20:	da03      	bge.n	2a <modulo+0x2a>
  22:	68fa      	ldr	r2, [r7, #12]
  24:	683b      	ldr	r3, [r7, #0]
  26:	4413      	add	r3, r2
  28:	e000      	b.n	2c <modulo+0x2c>
  2a:	68fb      	ldr	r3, [r7, #12]

}
  2c:	4618      	mov	r0, r3
  2e:	3714      	adds	r7, #20
  30:	46bd      	mov	sp, r7
  32:	f85d 7b04 	ldr.w	r7, [sp], #4
  36:	4770      	bx	lr

Disassembly of section .text.operators_additive:

00000000 <operators_additive>:

//-----------------------------------------------------------------------------

void operators_additive( void ) {
   0:	b480      	push	{r7}
   2:	b08d      	sub	sp, #52	; 0x34
   4:	af00      	add	r7, sp, #0

   // see disassembly
   char ca = 2;
   6:	2302      	movs	r3, #2
   8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   char cb = 3;
   c:	2303      	movs	r3, #3
   e:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
   char cc = 0;
  12:	2300      	movs	r3, #0
  14:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d

   short sa = 2;
  18:	2302      	movs	r3, #2
  1a:	857b      	strh	r3, [r7, #42]	; 0x2a
   short sb = 3;
  1c:	2303      	movs	r3, #3
  1e:	853b      	strh	r3, [r7, #40]	; 0x28
   short sc = 0;
  20:	2300      	movs	r3, #0
  22:	84fb      	strh	r3, [r7, #38]	; 0x26

   int ia = 2;
  24:	2302      	movs	r3, #2
  26:	623b      	str	r3, [r7, #32]
   int ib = 3;
  28:	2303      	movs	r3, #3
  2a:	61fb      	str	r3, [r7, #28]
   int ic = 0;
  2c:	2300      	movs	r3, #0
  2e:	61bb      	str	r3, [r7, #24]

   unsigned int ua = 2;
  30:	2302      	movs	r3, #2
  32:	617b      	str	r3, [r7, #20]
   unsigned int ub = 3;
  34:	2303      	movs	r3, #3
  36:	613b      	str	r3, [r7, #16]
   unsigned int uc = 0;
  38:	2300      	movs	r3, #0
  3a:	60fb      	str	r3, [r7, #12]

   float fa = .2F;
  3c:	4b30      	ldr	r3, [pc, #192]	; (100 <operators_additive+0x100>)
  3e:	60bb      	str	r3, [r7, #8]
   float fb = .3F;
  40:	4b30      	ldr	r3, [pc, #192]	; (104 <operators_additive+0x104>)
  42:	607b      	str	r3, [r7, #4]
   float fc = .0F;
  44:	f04f 0300 	mov.w	r3, #0
  48:	603b      	str	r3, [r7, #0]

   cc = ca + cb;
  4a:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
  4e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  52:	4413      	add	r3, r2
  54:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
   cc = cb - ca;
  58:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
  5c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  60:	1ad3      	subs	r3, r2, r3
  62:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
   cc = ca - cb;
  66:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
  6a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  6e:	1ad3      	subs	r3, r2, r3
  70:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d

   sc = sa + sb;
  74:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  76:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  78:	4413      	add	r3, r2
  7a:	b29b      	uxth	r3, r3
  7c:	84fb      	strh	r3, [r7, #38]	; 0x26
   sc = sb - sa;
  7e:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  80:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  82:	1ad3      	subs	r3, r2, r3
  84:	b29b      	uxth	r3, r3
  86:	84fb      	strh	r3, [r7, #38]	; 0x26
   sc = sa - sb;
  88:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  8a:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  8c:	1ad3      	subs	r3, r2, r3
  8e:	b29b      	uxth	r3, r3
  90:	84fb      	strh	r3, [r7, #38]	; 0x26

   ic = ia + ib;
  92:	6a3a      	ldr	r2, [r7, #32]
  94:	69fb      	ldr	r3, [r7, #28]
  96:	4413      	add	r3, r2
  98:	61bb      	str	r3, [r7, #24]
   ic = ib - ia;
  9a:	69fa      	ldr	r2, [r7, #28]
  9c:	6a3b      	ldr	r3, [r7, #32]
  9e:	1ad3      	subs	r3, r2, r3
  a0:	61bb      	str	r3, [r7, #24]
   ic = ia - ib;
  a2:	6a3a      	ldr	r2, [r7, #32]
  a4:	69fb      	ldr	r3, [r7, #28]
  a6:	1ad3      	subs	r3, r2, r3
  a8:	61bb      	str	r3, [r7, #24]

   uc = ua + ub;
  aa:	697a      	ldr	r2, [r7, #20]
  ac:	693b      	ldr	r3, [r7, #16]
  ae:	4413      	add	r3, r2
  b0:	60fb      	str	r3, [r7, #12]
   uc = ub - ua;
  b2:	693a      	ldr	r2, [r7, #16]
  b4:	697b      	ldr	r3, [r7, #20]
  b6:	1ad3      	subs	r3, r2, r3
  b8:	60fb      	str	r3, [r7, #12]
   uc = ua - ub;
  ba:	697a      	ldr	r2, [r7, #20]
  bc:	693b      	ldr	r3, [r7, #16]
  be:	1ad3      	subs	r3, r2, r3
  c0:	60fb      	str	r3, [r7, #12]

   fc = fa + fb;
  c2:	ed97 7a02 	vldr	s14, [r7, #8]
  c6:	edd7 7a01 	vldr	s15, [r7, #4]
  ca:	ee77 7a27 	vadd.f32	s15, s14, s15
  ce:	edc7 7a00 	vstr	s15, [r7]
   fc = fb - fa;
  d2:	ed97 7a01 	vldr	s14, [r7, #4]
  d6:	edd7 7a02 	vldr	s15, [r7, #8]
  da:	ee77 7a67 	vsub.f32	s15, s14, s15
  de:	edc7 7a00 	vstr	s15, [r7]
   fc = fa - fb;
  e2:	ed97 7a02 	vldr	s14, [r7, #8]
  e6:	edd7 7a01 	vldr	s15, [r7, #4]
  ea:	ee77 7a67 	vsub.f32	s15, s14, s15
  ee:	edc7 7a00 	vstr	s15, [r7]

}//operators_additive
  f2:	bf00      	nop
  f4:	3734      	adds	r7, #52	; 0x34
  f6:	46bd      	mov	sp, r7
  f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  fc:	4770      	bx	lr
  fe:	bf00      	nop
 100:	3e4ccccd 	.word	0x3e4ccccd
 104:	3e99999a 	.word	0x3e99999a

Disassembly of section .text.operators_binary:

00000000 <operators_binary>:

//-----------------------------------------------------------------------------

void operators_binary( void ) {
   0:	b480      	push	{r7}
   2:	b08b      	sub	sp, #44	; 0x2c
   4:	af00      	add	r7, sp, #0

   // see disassembly
   char ca = 2;
   6:	2302      	movs	r3, #2
   8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   char cb = 3;
   c:	2303      	movs	r3, #3
   e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
   char cc = 0;
  12:	2300      	movs	r3, #0
  14:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

   short sa = 2;
  18:	2302      	movs	r3, #2
  1a:	847b      	strh	r3, [r7, #34]	; 0x22
   short sb = 3;
  1c:	2303      	movs	r3, #3
  1e:	843b      	strh	r3, [r7, #32]
   short sc = 0;
  20:	2300      	movs	r3, #0
  22:	83fb      	strh	r3, [r7, #30]

   int ia = 2;
  24:	2302      	movs	r3, #2
  26:	61bb      	str	r3, [r7, #24]
   int ib = 3;
  28:	2303      	movs	r3, #3
  2a:	617b      	str	r3, [r7, #20]
   int ic = 0;
  2c:	2300      	movs	r3, #0
  2e:	613b      	str	r3, [r7, #16]

   unsigned int ua = 2;
  30:	2302      	movs	r3, #2
  32:	60fb      	str	r3, [r7, #12]
   unsigned int ub = 3;
  34:	2303      	movs	r3, #3
  36:	60bb      	str	r3, [r7, #8]
   unsigned int uc = 0;
  38:	2300      	movs	r3, #0
  3a:	607b      	str	r3, [r7, #4]

   cc = ca & cb;
  3c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  40:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  44:	4013      	ands	r3, r2
  46:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
   cc = ca | cb;
  4a:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  4e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  52:	4313      	orrs	r3, r2
  54:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
   cc = ca ^ cb;
  58:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  5c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  60:	4053      	eors	r3, r2
  62:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
   cc = ~ca;
  66:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  6a:	43db      	mvns	r3, r3
  6c:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

   cc = ca << 1;
  70:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  74:	005b      	lsls	r3, r3, #1
  76:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
   cc = ca << 2;
  7a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  7e:	009b      	lsls	r3, r3, #2
  80:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

   sc = sa & sb;
  84:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
  86:	8c3b      	ldrh	r3, [r7, #32]
  88:	4013      	ands	r3, r2
  8a:	83fb      	strh	r3, [r7, #30]
   sc = sa | sb;
  8c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
  8e:	8c3b      	ldrh	r3, [r7, #32]
  90:	4313      	orrs	r3, r2
  92:	83fb      	strh	r3, [r7, #30]
   sc = sa ^ sb;
  94:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
  96:	8c3b      	ldrh	r3, [r7, #32]
  98:	4053      	eors	r3, r2
  9a:	83fb      	strh	r3, [r7, #30]
   sc = ~sa;
  9c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  9e:	43db      	mvns	r3, r3
  a0:	83fb      	strh	r3, [r7, #30]

   sc = sa << 1;
  a2:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
  a6:	005b      	lsls	r3, r3, #1
  a8:	83fb      	strh	r3, [r7, #30]
   sc = sa << 2;
  aa:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
  ae:	009b      	lsls	r3, r3, #2
  b0:	83fb      	strh	r3, [r7, #30]

   sc = -3;
  b2:	f64f 73fd 	movw	r3, #65533	; 0xfffd
  b6:	83fb      	strh	r3, [r7, #30]
   sc = sc << 1;
  b8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
  bc:	005b      	lsls	r3, r3, #1
  be:	83fb      	strh	r3, [r7, #30]
   sc = -3;
  c0:	f64f 73fd 	movw	r3, #65533	; 0xfffd
  c4:	83fb      	strh	r3, [r7, #30]
   sc = sc >> 1;
  c6:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
  ca:	105b      	asrs	r3, r3, #1
  cc:	83fb      	strh	r3, [r7, #30]

   ic = ia & ib;
  ce:	69ba      	ldr	r2, [r7, #24]
  d0:	697b      	ldr	r3, [r7, #20]
  d2:	4013      	ands	r3, r2
  d4:	613b      	str	r3, [r7, #16]
   ic = ia | ib;
  d6:	69ba      	ldr	r2, [r7, #24]
  d8:	697b      	ldr	r3, [r7, #20]
  da:	4313      	orrs	r3, r2
  dc:	613b      	str	r3, [r7, #16]
   ic = ia ^ ib;
  de:	69ba      	ldr	r2, [r7, #24]
  e0:	697b      	ldr	r3, [r7, #20]
  e2:	4053      	eors	r3, r2
  e4:	613b      	str	r3, [r7, #16]
   ic = ~ia;
  e6:	69bb      	ldr	r3, [r7, #24]
  e8:	43db      	mvns	r3, r3
  ea:	613b      	str	r3, [r7, #16]

   ic = -3;
  ec:	f06f 0302 	mvn.w	r3, #2
  f0:	613b      	str	r3, [r7, #16]
   ic = ic << 1;
  f2:	693b      	ldr	r3, [r7, #16]
  f4:	005b      	lsls	r3, r3, #1
  f6:	613b      	str	r3, [r7, #16]
   ic = -3;
  f8:	f06f 0302 	mvn.w	r3, #2
  fc:	613b      	str	r3, [r7, #16]
   ic = ic >> 1;
  fe:	693b      	ldr	r3, [r7, #16]
 100:	105b      	asrs	r3, r3, #1
 102:	613b      	str	r3, [r7, #16]

   uc = ua & ub;
 104:	68fa      	ldr	r2, [r7, #12]
 106:	68bb      	ldr	r3, [r7, #8]
 108:	4013      	ands	r3, r2
 10a:	607b      	str	r3, [r7, #4]
   uc = ua | ub;
 10c:	68fa      	ldr	r2, [r7, #12]
 10e:	68bb      	ldr	r3, [r7, #8]
 110:	4313      	orrs	r3, r2
 112:	607b      	str	r3, [r7, #4]
   uc = ua ^ ub;
 114:	68fa      	ldr	r2, [r7, #12]
 116:	68bb      	ldr	r3, [r7, #8]
 118:	4053      	eors	r3, r2
 11a:	607b      	str	r3, [r7, #4]
   uc = ~ua;
 11c:	68fb      	ldr	r3, [r7, #12]
 11e:	43db      	mvns	r3, r3
 120:	607b      	str	r3, [r7, #4]

   uc = 8;
 122:	2308      	movs	r3, #8
 124:	607b      	str	r3, [r7, #4]
   uc = uc << 1;
 126:	687b      	ldr	r3, [r7, #4]
 128:	005b      	lsls	r3, r3, #1
 12a:	607b      	str	r3, [r7, #4]
   uc = 8;
 12c:	2308      	movs	r3, #8
 12e:	607b      	str	r3, [r7, #4]
   uc = uc >> 1;
 130:	687b      	ldr	r3, [r7, #4]
 132:	085b      	lsrs	r3, r3, #1
 134:	607b      	str	r3, [r7, #4]

}//operators_binary
 136:	bf00      	nop
 138:	372c      	adds	r7, #44	; 0x2c
 13a:	46bd      	mov	sp, r7
 13c:	f85d 7b04 	ldr.w	r7, [sp], #4
 140:	4770      	bx	lr

Disassembly of section .text.pointers1:

00000000 <pointers1>:

//-----------------------------------------------------------------------------

void pointers1( void ) {
   0:	b480      	push	{r7}
   2:	b08d      	sub	sp, #52	; 0x34
   4:	af00      	add	r7, sp, #0

   int a = 0;
   6:	2300      	movs	r3, #0
   8:	613b      	str	r3, [r7, #16]
   int b = 0;
   a:	2300      	movs	r3, #0
   c:	62fb      	str	r3, [r7, #44]	; 0x2c


   unsigned int addressX = 0;
   e:	2300      	movs	r3, #0
  10:	62bb      	str	r3, [r7, #40]	; 0x28
   unsigned int addressY = 0;
  12:	2300      	movs	r3, #0
  14:	627b      	str	r3, [r7, #36]	; 0x24

   char ar[] = "vwxyz";
  16:	4a2e      	ldr	r2, [pc, #184]	; (d0 <pointers1+0xd0>)
  18:	f107 0308 	add.w	r3, r7, #8
  1c:	e892 0003 	ldmia.w	r2, {r0, r1}
  20:	6018      	str	r0, [r3, #0]
  22:	3304      	adds	r3, #4
  24:	8019      	strh	r1, [r3, #0]
   int  *pi;
   int* piA = NULL;
  26:	2300      	movs	r3, #0
  28:	623b      	str	r3, [r7, #32]
   int* piB = NULL;
  2a:	2300      	movs	r3, #0
  2c:	61fb      	str	r3, [r7, #28]

   pi = 0;
  2e:	2300      	movs	r3, #0
  30:	61bb      	str	r3, [r7, #24]
   pi = '\0';
  32:	2300      	movs	r3, #0
  34:	61bb      	str	r3, [r7, #24]
   pi = NULL;
  36:	2300      	movs	r3, #0
  38:	61bb      	str	r3, [r7, #24]

   pi  = &a;
  3a:	f107 0310 	add.w	r3, r7, #16
  3e:	61bb      	str	r3, [r7, #24]
   *pi = 3;
  40:	69bb      	ldr	r3, [r7, #24]
  42:	2203      	movs	r2, #3
  44:	601a      	str	r2, [r3, #0]

   addressX = &a;
  46:	f107 0310 	add.w	r3, r7, #16
  4a:	62bb      	str	r3, [r7, #40]	; 0x28
   addressY = pi;
  4c:	69bb      	ldr	r3, [r7, #24]
  4e:	627b      	str	r3, [r7, #36]	; 0x24

   a = 5;
  50:	2305      	movs	r3, #5
  52:	613b      	str	r3, [r7, #16]
   b = *pi;
  54:	69bb      	ldr	r3, [r7, #24]
  56:	681b      	ldr	r3, [r3, #0]
  58:	62fb      	str	r3, [r7, #44]	; 0x2c

   pi++;
  5a:	69bb      	ldr	r3, [r7, #24]
  5c:	3304      	adds	r3, #4
  5e:	61bb      	str	r3, [r7, #24]
   *pi = 7;
  60:	69bb      	ldr	r3, [r7, #24]
  62:	2207      	movs	r2, #7
  64:	601a      	str	r2, [r3, #0]

   pi  = ar;
  66:	f107 0308 	add.w	r3, r7, #8
  6a:	61bb      	str	r3, [r7, #24]
   *pi = 1684234849;
  6c:	69bb      	ldr	r3, [r7, #24]
  6e:	4a19      	ldr	r2, [pc, #100]	; (d4 <pointers1+0xd4>)
  70:	601a      	str	r2, [r3, #0]

   a   = 3;
  72:	2303      	movs	r3, #3
  74:	613b      	str	r3, [r7, #16]
   piA = &a;
  76:	f107 0310 	add.w	r3, r7, #16
  7a:	623b      	str	r3, [r7, #32]
   piB = &a;
  7c:	f107 0310 	add.w	r3, r7, #16
  80:	61fb      	str	r3, [r7, #28]

   int c = 0;
  82:	2300      	movs	r3, #0
  84:	617b      	str	r3, [r7, #20]
   c = *piA;
  86:	6a3b      	ldr	r3, [r7, #32]
  88:	681b      	ldr	r3, [r3, #0]
  8a:	617b      	str	r3, [r7, #20]
   c = *piB;
  8c:	69fb      	ldr	r3, [r7, #28]
  8e:	681b      	ldr	r3, [r3, #0]
  90:	617b      	str	r3, [r7, #20]

   c = 4;
  92:	2304      	movs	r3, #4
  94:	617b      	str	r3, [r7, #20]
   *piB = c;
  96:	69fb      	ldr	r3, [r7, #28]
  98:	697a      	ldr	r2, [r7, #20]
  9a:	601a      	str	r2, [r3, #0]
   c = a + *piA + *piB;
  9c:	6a3b      	ldr	r3, [r7, #32]
  9e:	681a      	ldr	r2, [r3, #0]
  a0:	693b      	ldr	r3, [r7, #16]
  a2:	441a      	add	r2, r3
  a4:	69fb      	ldr	r3, [r7, #28]
  a6:	681b      	ldr	r3, [r3, #0]
  a8:	4413      	add	r3, r2
  aa:	617b      	str	r3, [r7, #20]

   char d[] = "efgh";
  ac:	4a0a      	ldr	r2, [pc, #40]	; (d8 <pointers1+0xd8>)
  ae:	463b      	mov	r3, r7
  b0:	e892 0003 	ldmia.w	r2, {r0, r1}
  b4:	6018      	str	r0, [r3, #0]
  b6:	3304      	adds	r3, #4
  b8:	7019      	strb	r1, [r3, #0]
   *pi = *(int*)d;
  ba:	463b      	mov	r3, r7
  bc:	681a      	ldr	r2, [r3, #0]
  be:	69bb      	ldr	r3, [r7, #24]
  c0:	601a      	str	r2, [r3, #0]

}//pointers1
  c2:	bf00      	nop
  c4:	3734      	adds	r7, #52	; 0x34
  c6:	46bd      	mov	sp, r7
  c8:	f85d 7b04 	ldr.w	r7, [sp], #4
  cc:	4770      	bx	lr
  ce:	bf00      	nop
  d0:	0000004c 	.word	0x0000004c
  d4:	64636261 	.word	0x64636261
  d8:	00000054 	.word	0x00000054

Disassembly of section .text.pointers2:

00000000 <pointers2>:

//-----------------------------------------------------------------------------

void pointers2( void ) {
   0:	b480      	push	{r7}
   2:	b08d      	sub	sp, #52	; 0x34
   4:	af00      	add	r7, sp, #0

   int a = 0;
   6:	2300      	movs	r3, #0
   8:	62fb      	str	r3, [r7, #44]	; 0x2c
   int b = 0;
   a:	2300      	movs	r3, #0
   c:	62bb      	str	r3, [r7, #40]	; 0x28
   int c = 0;
   e:	2300      	movs	r3, #0
  10:	61fb      	str	r3, [r7, #28]
   int d = 0;
  12:	2300      	movs	r3, #0
  14:	627b      	str	r3, [r7, #36]	; 0x24
   int e = 0;
  16:	2300      	movs	r3, #0
  18:	623b      	str	r3, [r7, #32]

   int* pi  = NULL;
  1a:	2300      	movs	r3, #0
  1c:	61bb      	str	r3, [r7, #24]

   int arr[] = { 0, 0, 0, 0, 0 };
  1e:	1d3b      	adds	r3, r7, #4
  20:	2200      	movs	r2, #0
  22:	601a      	str	r2, [r3, #0]
  24:	605a      	str	r2, [r3, #4]
  26:	609a      	str	r2, [r3, #8]
  28:	60da      	str	r2, [r3, #12]
  2a:	611a      	str	r2, [r3, #16]

   pi = &arr[0];
  2c:	1d3b      	adds	r3, r7, #4
  2e:	61bb      	str	r3, [r7, #24]
   *pi = 15;
  30:	69bb      	ldr	r3, [r7, #24]
  32:	220f      	movs	r2, #15
  34:	601a      	str	r2, [r3, #0]

   pi = pi + 1;
  36:	69bb      	ldr	r3, [r7, #24]
  38:	3304      	adds	r3, #4
  3a:	61bb      	str	r3, [r7, #24]
   *pi = 20;
  3c:	69bb      	ldr	r3, [r7, #24]
  3e:	2214      	movs	r2, #20
  40:	601a      	str	r2, [r3, #0]

   pi += 1;
  42:	69bb      	ldr	r3, [r7, #24]
  44:	3304      	adds	r3, #4
  46:	61bb      	str	r3, [r7, #24]
   *pi = 25;
  48:	69bb      	ldr	r3, [r7, #24]
  4a:	2219      	movs	r2, #25
  4c:	601a      	str	r2, [r3, #0]

   pi++;
  4e:	69bb      	ldr	r3, [r7, #24]
  50:	3304      	adds	r3, #4
  52:	61bb      	str	r3, [r7, #24]
   *pi = 30;
  54:	69bb      	ldr	r3, [r7, #24]
  56:	221e      	movs	r2, #30
  58:	601a      	str	r2, [r3, #0]

   *pi++ = 35;
  5a:	69bb      	ldr	r3, [r7, #24]
  5c:	1d1a      	adds	r2, r3, #4
  5e:	61ba      	str	r2, [r7, #24]
  60:	2223      	movs	r2, #35	; 0x23
  62:	601a      	str	r2, [r3, #0]

   *pi = 40;
  64:	69bb      	ldr	r3, [r7, #24]
  66:	2228      	movs	r2, #40	; 0x28
  68:	601a      	str	r2, [r3, #0]

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
  6a:	2300      	movs	r3, #0
  6c:	617b      	str	r3, [r7, #20]
  6e:	697b      	ldr	r3, [r7, #20]
  70:	613b      	str	r3, [r7, #16]
  72:	693b      	ldr	r3, [r7, #16]
  74:	60fb      	str	r3, [r7, #12]
  76:	68fb      	ldr	r3, [r7, #12]
  78:	60bb      	str	r3, [r7, #8]
  7a:	68bb      	ldr	r3, [r7, #8]
  7c:	607b      	str	r3, [r7, #4]

   pi = &arr[0];
  7e:	1d3b      	adds	r3, r7, #4
  80:	61bb      	str	r3, [r7, #24]
   *(pi + 0) = 2;
  82:	69bb      	ldr	r3, [r7, #24]
  84:	2202      	movs	r2, #2
  86:	601a      	str	r2, [r3, #0]
   *(pi + 1) = 4;
  88:	69bb      	ldr	r3, [r7, #24]
  8a:	3304      	adds	r3, #4
  8c:	2204      	movs	r2, #4
  8e:	601a      	str	r2, [r3, #0]
   *(pi + 2) = 6;
  90:	69bb      	ldr	r3, [r7, #24]
  92:	3308      	adds	r3, #8
  94:	2206      	movs	r2, #6
  96:	601a      	str	r2, [r3, #0]
   *(pi + 3) = 8;
  98:	69bb      	ldr	r3, [r7, #24]
  9a:	330c      	adds	r3, #12
  9c:	2208      	movs	r2, #8
  9e:	601a      	str	r2, [r3, #0]
   *(pi + 4) = 10;
  a0:	69bb      	ldr	r3, [r7, #24]
  a2:	3310      	adds	r3, #16
  a4:	220a      	movs	r2, #10
  a6:	601a      	str	r2, [r3, #0]

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
  a8:	2300      	movs	r3, #0
  aa:	617b      	str	r3, [r7, #20]
  ac:	697b      	ldr	r3, [r7, #20]
  ae:	613b      	str	r3, [r7, #16]
  b0:	693b      	ldr	r3, [r7, #16]
  b2:	60fb      	str	r3, [r7, #12]
  b4:	68fb      	ldr	r3, [r7, #12]
  b6:	60bb      	str	r3, [r7, #8]
  b8:	68bb      	ldr	r3, [r7, #8]
  ba:	607b      	str	r3, [r7, #4]

   pi = &arr[0];
  bc:	1d3b      	adds	r3, r7, #4
  be:	61bb      	str	r3, [r7, #24]
   pi[0] = 3;
  c0:	69bb      	ldr	r3, [r7, #24]
  c2:	2203      	movs	r2, #3
  c4:	601a      	str	r2, [r3, #0]
   pi[1] = 5;
  c6:	69bb      	ldr	r3, [r7, #24]
  c8:	3304      	adds	r3, #4
  ca:	2205      	movs	r2, #5
  cc:	601a      	str	r2, [r3, #0]
   pi[2] = 7;
  ce:	69bb      	ldr	r3, [r7, #24]
  d0:	3308      	adds	r3, #8
  d2:	2207      	movs	r2, #7
  d4:	601a      	str	r2, [r3, #0]
   pi[3] = 9;
  d6:	69bb      	ldr	r3, [r7, #24]
  d8:	330c      	adds	r3, #12
  da:	2209      	movs	r2, #9
  dc:	601a      	str	r2, [r3, #0]
   pi[4] = 11;
  de:	69bb      	ldr	r3, [r7, #24]
  e0:	3310      	adds	r3, #16
  e2:	220b      	movs	r2, #11
  e4:	601a      	str	r2, [r3, #0]

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
  e6:	2300      	movs	r3, #0
  e8:	617b      	str	r3, [r7, #20]
  ea:	697b      	ldr	r3, [r7, #20]
  ec:	613b      	str	r3, [r7, #16]
  ee:	693b      	ldr	r3, [r7, #16]
  f0:	60fb      	str	r3, [r7, #12]
  f2:	68fb      	ldr	r3, [r7, #12]
  f4:	60bb      	str	r3, [r7, #8]
  f6:	68bb      	ldr	r3, [r7, #8]
  f8:	607b      	str	r3, [r7, #4]

   *arr = 111;
  fa:	236f      	movs	r3, #111	; 0x6f
  fc:	607b      	str	r3, [r7, #4]
   *(arr + 0) = 100;
  fe:	2364      	movs	r3, #100	; 0x64
 100:	607b      	str	r3, [r7, #4]
   *(arr + 1) = 200;
 102:	23c8      	movs	r3, #200	; 0xc8
 104:	60bb      	str	r3, [r7, #8]
   *(arr + 2) = 300;
 106:	f44f 7396 	mov.w	r3, #300	; 0x12c
 10a:	60fb      	str	r3, [r7, #12]
   *(arr + 3) = 400;
 10c:	f44f 73c8 	mov.w	r3, #400	; 0x190
 110:	613b      	str	r3, [r7, #16]
   *(arr + 4) = 500;
 112:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 116:	617b      	str	r3, [r7, #20]


   pi = &arr[4];
 118:	1d3b      	adds	r3, r7, #4
 11a:	3310      	adds	r3, #16
 11c:	61bb      	str	r3, [r7, #24]
   pi[-4] = 10;
 11e:	69bb      	ldr	r3, [r7, #24]
 120:	3b10      	subs	r3, #16
 122:	220a      	movs	r2, #10
 124:	601a      	str	r2, [r3, #0]
   pi[-3] = 20;
 126:	69bb      	ldr	r3, [r7, #24]
 128:	3b0c      	subs	r3, #12
 12a:	2214      	movs	r2, #20
 12c:	601a      	str	r2, [r3, #0]
   pi[-2] = 30;
 12e:	69bb      	ldr	r3, [r7, #24]
 130:	3b08      	subs	r3, #8
 132:	221e      	movs	r2, #30
 134:	601a      	str	r2, [r3, #0]
   pi[-1] = 40;
 136:	69bb      	ldr	r3, [r7, #24]
 138:	3b04      	subs	r3, #4
 13a:	2228      	movs	r2, #40	; 0x28
 13c:	601a      	str	r2, [r3, #0]
   pi[ 0] = 50;
 13e:	69bb      	ldr	r3, [r7, #24]
 140:	2232      	movs	r2, #50	; 0x32
 142:	601a      	str	r2, [r3, #0]


   pi = &c;
 144:	f107 031c 	add.w	r3, r7, #28
 148:	61bb      	str	r3, [r7, #24]

   // !! danger
   *(pi - 1) = 22;
 14a:	69bb      	ldr	r3, [r7, #24]
 14c:	3b04      	subs	r3, #4
 14e:	2216      	movs	r2, #22
 150:	601a      	str	r2, [r3, #0]
   *(pi - 2) = 11;
 152:	69bb      	ldr	r3, [r7, #24]
 154:	3b08      	subs	r3, #8
 156:	220b      	movs	r2, #11
 158:	601a      	str	r2, [r3, #0]

   *(pi + 1) = 44;
 15a:	69bb      	ldr	r3, [r7, #24]
 15c:	3304      	adds	r3, #4
 15e:	222c      	movs	r2, #44	; 0x2c
 160:	601a      	str	r2, [r3, #0]
   *(pi + 2) = 55;
 162:	69bb      	ldr	r3, [r7, #24]
 164:	3308      	adds	r3, #8
 166:	2237      	movs	r2, #55	; 0x37
 168:	601a      	str	r2, [r3, #0]

   *(pi + 3) = 66;
 16a:	69bb      	ldr	r3, [r7, #24]
 16c:	330c      	adds	r3, #12
 16e:	2242      	movs	r2, #66	; 0x42
 170:	601a      	str	r2, [r3, #0]
   *(pi + 4) = 77;
 172:	69bb      	ldr	r3, [r7, #24]
 174:	3310      	adds	r3, #16
 176:	224d      	movs	r2, #77	; 0x4d
 178:	601a      	str	r2, [r3, #0]

   a = b = c = d = e;
 17a:	6a3b      	ldr	r3, [r7, #32]
 17c:	627b      	str	r3, [r7, #36]	; 0x24
 17e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 180:	61fb      	str	r3, [r7, #28]
 182:	69fb      	ldr	r3, [r7, #28]
 184:	62bb      	str	r3, [r7, #40]	; 0x28
 186:	6abb      	ldr	r3, [r7, #40]	; 0x28
 188:	62fb      	str	r3, [r7, #44]	; 0x2c

   pi = (int*)&pi;
 18a:	f107 0318 	add.w	r3, r7, #24
 18e:	61bb      	str	r3, [r7, #24]

   // !! danger
   pi[-1] = 8;
 190:	69bb      	ldr	r3, [r7, #24]
 192:	3b04      	subs	r3, #4
 194:	2208      	movs	r2, #8
 196:	601a      	str	r2, [r3, #0]
   pi[-2] = 7;
 198:	69bb      	ldr	r3, [r7, #24]
 19a:	3b08      	subs	r3, #8
 19c:	2207      	movs	r2, #7
 19e:	601a      	str	r2, [r3, #0]
   pi[-3] = 6;
 1a0:	69bb      	ldr	r3, [r7, #24]
 1a2:	3b0c      	subs	r3, #12
 1a4:	2206      	movs	r2, #6
 1a6:	601a      	str	r2, [r3, #0]
   pi[-4] = 5;
 1a8:	69bb      	ldr	r3, [r7, #24]
 1aa:	3b10      	subs	r3, #16
 1ac:	2205      	movs	r2, #5
 1ae:	601a      	str	r2, [r3, #0]
   pi[-5] = 4;
 1b0:	69bb      	ldr	r3, [r7, #24]
 1b2:	3b14      	subs	r3, #20
 1b4:	2204      	movs	r2, #4
 1b6:	601a      	str	r2, [r3, #0]

   arr[0] = arr[1] = arr[2] = arr[3] = arr[4] = 0;
 1b8:	2300      	movs	r3, #0
 1ba:	617b      	str	r3, [r7, #20]
 1bc:	697b      	ldr	r3, [r7, #20]
 1be:	613b      	str	r3, [r7, #16]
 1c0:	693b      	ldr	r3, [r7, #16]
 1c2:	60fb      	str	r3, [r7, #12]
 1c4:	68fb      	ldr	r3, [r7, #12]
 1c6:	60bb      	str	r3, [r7, #8]
 1c8:	68bb      	ldr	r3, [r7, #8]
 1ca:	607b      	str	r3, [r7, #4]

   0[arr] = 7;
 1cc:	2307      	movs	r3, #7
 1ce:	607b      	str	r3, [r7, #4]
   1[arr] = 6;
 1d0:	2306      	movs	r3, #6
 1d2:	60bb      	str	r3, [r7, #8]
   2[arr] = 5;
 1d4:	2305      	movs	r3, #5
 1d6:	60fb      	str	r3, [r7, #12]
   3[arr] = 4;
 1d8:	2304      	movs	r3, #4
 1da:	613b      	str	r3, [r7, #16]
   4[arr] = 2;
 1dc:	2302      	movs	r3, #2
 1de:	617b      	str	r3, [r7, #20]

   // http://www.youtube.com/watch?v=IJNR2EpS0jw
   *(pi + 5) = 88;
 1e0:	69bb      	ldr	r3, [r7, #24]
 1e2:	3314      	adds	r3, #20
 1e4:	2258      	movs	r2, #88	; 0x58
 1e6:	601a      	str	r2, [r3, #0]
   *(pi + 6) = 99;
 1e8:	69bb      	ldr	r3, [r7, #24]
 1ea:	3318      	adds	r3, #24
 1ec:	2263      	movs	r2, #99	; 0x63
 1ee:	601a      	str	r2, [r3, #0]

}//pointers2
 1f0:	bf00      	nop
 1f2:	3734      	adds	r7, #52	; 0x34
 1f4:	46bd      	mov	sp, r7
 1f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 1fa:	4770      	bx	lr

Disassembly of section .text.pointers3:

00000000 <pointers3>:

//-----------------------------------------------------------------------------

void pointers3( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

	// see disassembly
	int    a =  3;
   6:	2303      	movs	r3, #3
   8:	60bb      	str	r3, [r7, #8]
	int   *b = &a;
   a:	f107 0308 	add.w	r3, r7, #8
   e:	607b      	str	r3, [r7, #4]
	int  **c = &b;
  10:	1d3b      	adds	r3, r7, #4
  12:	603b      	str	r3, [r7, #0]
	int ***d = &c;
  14:	463b      	mov	r3, r7
  16:	60fb      	str	r3, [r7, #12]

	   a = 2;
  18:	2302      	movs	r3, #2
  1a:	60bb      	str	r3, [r7, #8]
	  *b = 3;
  1c:	687b      	ldr	r3, [r7, #4]
  1e:	2203      	movs	r2, #3
  20:	601a      	str	r2, [r3, #0]
     **c = 4;
  22:	683b      	ldr	r3, [r7, #0]
  24:	681b      	ldr	r3, [r3, #0]
  26:	2204      	movs	r2, #4
  28:	601a      	str	r2, [r3, #0]
	***d = 5;
  2a:	68fb      	ldr	r3, [r7, #12]
  2c:	681b      	ldr	r3, [r3, #0]
  2e:	681b      	ldr	r3, [r3, #0]
  30:	2205      	movs	r2, #5
  32:	601a      	str	r2, [r3, #0]

}//pointers3
  34:	bf00      	nop
  36:	3714      	adds	r7, #20
  38:	46bd      	mov	sp, r7
  3a:	f85d 7b04 	ldr.w	r7, [sp], #4
  3e:	4770      	bx	lr

Disassembly of section .text.pointers4:

00000000 <pointers4>:

//-----------------------------------------------------------------------------

void pointers4( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b097      	sub	sp, #92	; 0x5c
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int arrI[ 5 ] = { 10, 20, 30, 40, 50 };
   6:	4b1f      	ldr	r3, [pc, #124]	; (84 <pointers4+0x84>)
   8:	f107 042c 	add.w	r4, r7, #44	; 0x2c
   c:	461d      	mov	r5, r3
   e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  12:	682b      	ldr	r3, [r5, #0]
  14:	6023      	str	r3, [r4, #0]

   int *piA = NULL;
  16:	2300      	movs	r3, #0
  18:	657b      	str	r3, [r7, #84]	; 0x54
   int *piB = NULL;
  1a:	2300      	movs	r3, #0
  1c:	653b      	str	r3, [r7, #80]	; 0x50

   long double arrLD[ 5 ] = { .10L, .20L, .30L, .40L, .50L };
  1e:	4b1a      	ldr	r3, [pc, #104]	; (88 <pointers4+0x88>)
  20:	463c      	mov	r4, r7
  22:	461d      	mov	r5, r3
  24:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  26:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  28:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  2a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  2c:	e895 0003 	ldmia.w	r5, {r0, r1}
  30:	e884 0003 	stmia.w	r4, {r0, r1}

   long double *pldA = NULL;
  34:	2300      	movs	r3, #0
  36:	64fb      	str	r3, [r7, #76]	; 0x4c
   long double *pldB = NULL;
  38:	2300      	movs	r3, #0
  3a:	64bb      	str	r3, [r7, #72]	; 0x48

   size_t        size = 0;
  3c:	2300      	movs	r3, #0
  3e:	647b      	str	r3, [r7, #68]	; 0x44
   ptrdiff_t distance = 0;
  40:	2300      	movs	r3, #0
  42:	643b      	str	r3, [r7, #64]	; 0x40

   piA = &arrI[ 0 ];
  44:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  48:	657b      	str	r3, [r7, #84]	; 0x54
   piB = &arrI[ 1 ];
  4a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  4e:	3304      	adds	r3, #4
  50:	653b      	str	r3, [r7, #80]	; 0x50

   size = sizeof( int );
  52:	2304      	movs	r3, #4
  54:	647b      	str	r3, [r7, #68]	; 0x44
   distance = piA - piB;
  56:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  58:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  5a:	1ad3      	subs	r3, r2, r3
  5c:	109b      	asrs	r3, r3, #2
  5e:	643b      	str	r3, [r7, #64]	; 0x40


   pldA = &arrLD[ 0 ];
  60:	463b      	mov	r3, r7
  62:	64fb      	str	r3, [r7, #76]	; 0x4c
   pldB = &arrLD[ 1 ];
  64:	463b      	mov	r3, r7
  66:	3308      	adds	r3, #8
  68:	64bb      	str	r3, [r7, #72]	; 0x48

   size = sizeof( long double );
  6a:	2308      	movs	r3, #8
  6c:	647b      	str	r3, [r7, #68]	; 0x44
   distance = pldA - pldB;
  6e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  72:	1ad3      	subs	r3, r2, r3
  74:	10db      	asrs	r3, r3, #3
  76:	643b      	str	r3, [r7, #64]	; 0x40

}//pointers4
  78:	bf00      	nop
  7a:	375c      	adds	r7, #92	; 0x5c
  7c:	46bd      	mov	sp, r7
  7e:	bcb0      	pop	{r4, r5, r7}
  80:	4770      	bx	lr
  82:	bf00      	nop
  84:	0000005c 	.word	0x0000005c
  88:	00000070 	.word	0x00000070

Disassembly of section .text.pointers5:

00000000 <pointers5>:

//-----------------------------------------------------------------------------

void pointers5( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int arr[ 5 ] = { 10, 20, 30, 40, 50 };
   6:	4b25      	ldr	r3, [pc, #148]	; (9c <pointers5+0x9c>)
   8:	463c      	mov	r4, r7
   a:	461d      	mov	r5, r3
   c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  10:	682b      	ldr	r3, [r5, #0]
  12:	6023      	str	r3, [r4, #0]

   int *pi = NULL;
  14:	2300      	movs	r3, #0
  16:	617b      	str	r3, [r7, #20]

   pi = arr;
  18:	463b      	mov	r3, r7
  1a:	617b      	str	r3, [r7, #20]

   arr[ 0 ]   = 11;
  1c:	230b      	movs	r3, #11
  1e:	603b      	str	r3, [r7, #0]
   *(arr + 0) = 12;
  20:	230c      	movs	r3, #12
  22:	603b      	str	r3, [r7, #0]
   pi[ 0 ]    = 13;
  24:	697b      	ldr	r3, [r7, #20]
  26:	220d      	movs	r2, #13
  28:	601a      	str	r2, [r3, #0]
   *(pi + 0)  = 14;
  2a:	697b      	ldr	r3, [r7, #20]
  2c:	220e      	movs	r2, #14
  2e:	601a      	str	r2, [r3, #0]

   arr[ 1 ]   = 22;
  30:	2316      	movs	r3, #22
  32:	607b      	str	r3, [r7, #4]
   *(arr + 1) = 23;
  34:	2317      	movs	r3, #23
  36:	607b      	str	r3, [r7, #4]
   pi[ 1 ]    = 24;
  38:	697b      	ldr	r3, [r7, #20]
  3a:	3304      	adds	r3, #4
  3c:	2218      	movs	r2, #24
  3e:	601a      	str	r2, [r3, #0]
   *(pi + 1)  = 25;
  40:	697b      	ldr	r3, [r7, #20]
  42:	3304      	adds	r3, #4
  44:	2219      	movs	r2, #25
  46:	601a      	str	r2, [r3, #0]

   arr[ 2 ]   = 33;
  48:	2321      	movs	r3, #33	; 0x21
  4a:	60bb      	str	r3, [r7, #8]
   *(arr + 2) = 34;
  4c:	2322      	movs	r3, #34	; 0x22
  4e:	60bb      	str	r3, [r7, #8]
   pi[ 2 ]    = 35;
  50:	697b      	ldr	r3, [r7, #20]
  52:	3308      	adds	r3, #8
  54:	2223      	movs	r2, #35	; 0x23
  56:	601a      	str	r2, [r3, #0]
   *(pi + 2)  = 36;
  58:	697b      	ldr	r3, [r7, #20]
  5a:	3308      	adds	r3, #8
  5c:	2224      	movs	r2, #36	; 0x24
  5e:	601a      	str	r2, [r3, #0]

   arr[ 3 ]   = 44;
  60:	232c      	movs	r3, #44	; 0x2c
  62:	60fb      	str	r3, [r7, #12]
   *(arr + 3) = 45;
  64:	232d      	movs	r3, #45	; 0x2d
  66:	60fb      	str	r3, [r7, #12]
   pi[ 3 ]    = 46;
  68:	697b      	ldr	r3, [r7, #20]
  6a:	330c      	adds	r3, #12
  6c:	222e      	movs	r2, #46	; 0x2e
  6e:	601a      	str	r2, [r3, #0]
   *(pi + 3)  = 47;
  70:	697b      	ldr	r3, [r7, #20]
  72:	330c      	adds	r3, #12
  74:	222f      	movs	r2, #47	; 0x2f
  76:	601a      	str	r2, [r3, #0]

   arr[ 4 ]   = 55;
  78:	2337      	movs	r3, #55	; 0x37
  7a:	613b      	str	r3, [r7, #16]
   *(arr + 4) = 56;
  7c:	2338      	movs	r3, #56	; 0x38
  7e:	613b      	str	r3, [r7, #16]
   pi[ 4 ]    = 57;
  80:	697b      	ldr	r3, [r7, #20]
  82:	3310      	adds	r3, #16
  84:	2239      	movs	r2, #57	; 0x39
  86:	601a      	str	r2, [r3, #0]
   *(pi + 4)  = 58;
  88:	697b      	ldr	r3, [r7, #20]
  8a:	3310      	adds	r3, #16
  8c:	223a      	movs	r2, #58	; 0x3a
  8e:	601a      	str	r2, [r3, #0]

}//pointers5
  90:	bf00      	nop
  92:	371c      	adds	r7, #28
  94:	46bd      	mov	sp, r7
  96:	bcb0      	pop	{r4, r5, r7}
  98:	4770      	bx	lr
  9a:	bf00      	nop
  9c:	0000005c 	.word	0x0000005c

Disassembly of section .text.pointers6:

00000000 <pointers6>:

//-----------------------------------------------------------------------------

void pointers6( void ) {
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int *arr = NULL;
   6:	2300      	movs	r3, #0
   8:	607b      	str	r3, [r7, #4]

   arr = malloc( 5 * sizeof(int) );
   a:	2014      	movs	r0, #20
   c:	f7ff fffe 	bl	0 <malloc>
  10:	4603      	mov	r3, r0
  12:	607b      	str	r3, [r7, #4]

   arr[ 0 ]   = 11;
  14:	687b      	ldr	r3, [r7, #4]
  16:	220b      	movs	r2, #11
  18:	601a      	str	r2, [r3, #0]
   *(arr + 0) = 12;
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	220c      	movs	r2, #12
  1e:	601a      	str	r2, [r3, #0]

   arr[ 1 ]   = 22;
  20:	687b      	ldr	r3, [r7, #4]
  22:	3304      	adds	r3, #4
  24:	2216      	movs	r2, #22
  26:	601a      	str	r2, [r3, #0]
   *(arr + 1) = 23;
  28:	687b      	ldr	r3, [r7, #4]
  2a:	3304      	adds	r3, #4
  2c:	2217      	movs	r2, #23
  2e:	601a      	str	r2, [r3, #0]

   arr[ 2 ]   = 33;
  30:	687b      	ldr	r3, [r7, #4]
  32:	3308      	adds	r3, #8
  34:	2221      	movs	r2, #33	; 0x21
  36:	601a      	str	r2, [r3, #0]
   *(arr + 2) = 34;
  38:	687b      	ldr	r3, [r7, #4]
  3a:	3308      	adds	r3, #8
  3c:	2222      	movs	r2, #34	; 0x22
  3e:	601a      	str	r2, [r3, #0]

   arr[ 3 ]   = 44;
  40:	687b      	ldr	r3, [r7, #4]
  42:	330c      	adds	r3, #12
  44:	222c      	movs	r2, #44	; 0x2c
  46:	601a      	str	r2, [r3, #0]
   *(arr + 3) = 45;
  48:	687b      	ldr	r3, [r7, #4]
  4a:	330c      	adds	r3, #12
  4c:	222d      	movs	r2, #45	; 0x2d
  4e:	601a      	str	r2, [r3, #0]

   arr[ 4 ]   = 55;
  50:	687b      	ldr	r3, [r7, #4]
  52:	3310      	adds	r3, #16
  54:	2237      	movs	r2, #55	; 0x37
  56:	601a      	str	r2, [r3, #0]
   *(arr + 4) = 56;
  58:	687b      	ldr	r3, [r7, #4]
  5a:	3310      	adds	r3, #16
  5c:	2238      	movs	r2, #56	; 0x38
  5e:	601a      	str	r2, [r3, #0]

   free( arr );
  60:	6878      	ldr	r0, [r7, #4]
  62:	f7ff fffe 	bl	0 <free>

}//pointers6
  66:	bf00      	nop
  68:	3708      	adds	r7, #8
  6a:	46bd      	mov	sp, r7
  6c:	bd80      	pop	{r7, pc}

Disassembly of section .text.pointersConstantPointers:

00000000 <pointersConstantPointers>:

//-----------------------------------------------------------------------------

void pointersConstantPointers( void ) {
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0

   int a = 0;
   6:	2300      	movs	r3, #0
   8:	607b      	str	r3, [r7, #4]
   int b = 0;
   a:	2300      	movs	r3, #0
   c:	603b      	str	r3, [r7, #0]

   // both same
   const int *pcA;
   int const *pcB;

   int *const cpi = &a;
   e:	1d3b      	adds	r3, r7, #4
  10:	617b      	str	r3, [r7, #20]

   const int *const cpci = &a;
  12:	1d3b      	adds	r3, r7, #4
  14:	613b      	str	r3, [r7, #16]

   pcA = &a;
  16:	1d3b      	adds	r3, r7, #4
  18:	60fb      	str	r3, [r7, #12]
   pcB = &b;
  1a:	463b      	mov	r3, r7
  1c:	60bb      	str	r3, [r7, #8]
   // *pcA = 3; // error
   // *pcB = 5; // error

   // cpi = &b; // error

}//pointersConstantPointers
  1e:	bf00      	nop
  20:	371c      	adds	r7, #28
  22:	46bd      	mov	sp, r7
  24:	f85d 7b04 	ldr.w	r7, [sp], #4
  28:	4770      	bx	lr

Disassembly of section .text.arrays:

00000000 <arrays>:

//-----------------------------------------------------------------------------

void arrays( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b0b3      	sub	sp, #204	; 0xcc
   4:	af00      	add	r7, sp, #0
   int arrA3[] = {};
   int arrB[ 0 ];
   int arrC[ 5 ];


   char lettersA[] = { 65, 66, 67, 68, 69 };
   6:	4a64      	ldr	r2, [pc, #400]	; (198 <arrays+0x198>)
   8:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
   c:	e892 0003 	ldmia.w	r2, {r0, r1}
  10:	6018      	str	r0, [r3, #0]
  12:	3304      	adds	r3, #4
  14:	7019      	strb	r1, [r3, #0]
   char lettersB[] = { 'A','B','C','D','E' };
  16:	4a60      	ldr	r2, [pc, #384]	; (198 <arrays+0x198>)
  18:	f107 039c 	add.w	r3, r7, #156	; 0x9c
  1c:	e892 0003 	ldmia.w	r2, {r0, r1}
  20:	6018      	str	r0, [r3, #0]
  22:	3304      	adds	r3, #4
  24:	7019      	strb	r1, [r3, #0]

   char stringA[] = { 'A','B','C','D','E', 0 };
  26:	4a5d      	ldr	r2, [pc, #372]	; (19c <arrays+0x19c>)
  28:	f107 0394 	add.w	r3, r7, #148	; 0x94
  2c:	e892 0003 	ldmia.w	r2, {r0, r1}
  30:	6018      	str	r0, [r3, #0]
  32:	3304      	adds	r3, #4
  34:	8019      	strh	r1, [r3, #0]
   char stringB[] = { 'A','B','C','D','E', '\0' };
  36:	4a59      	ldr	r2, [pc, #356]	; (19c <arrays+0x19c>)
  38:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  3c:	e892 0003 	ldmia.w	r2, {r0, r1}
  40:	6018      	str	r0, [r3, #0]
  42:	3304      	adds	r3, #4
  44:	8019      	strh	r1, [r3, #0]
   char stringC[] = { "ABCDE" };
  46:	4a55      	ldr	r2, [pc, #340]	; (19c <arrays+0x19c>)
  48:	f107 0384 	add.w	r3, r7, #132	; 0x84
  4c:	e892 0003 	ldmia.w	r2, {r0, r1}
  50:	6018      	str	r0, [r3, #0]
  52:	3304      	adds	r3, #4
  54:	8019      	strh	r1, [r3, #0]

   wchar_t unicodeA[] = { L'Ğ', L'Ü', L'Ş', L'İ', L'Ö', L'Ç', 0 };
  56:	4b52      	ldr	r3, [pc, #328]	; (1a0 <arrays+0x1a0>)
  58:	f107 0468 	add.w	r4, r7, #104	; 0x68
  5c:	461d      	mov	r5, r3
  5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  60:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  62:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  66:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   wchar_t unicodeB[] = L"ĞÜŞİÖÇ";
  6a:	4b4e      	ldr	r3, [pc, #312]	; (1a4 <arrays+0x1a4>)
  6c:	f107 044c 	add.w	r4, r7, #76	; 0x4c
  70:	461d      	mov	r5, r3
  72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  74:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  76:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  7a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

   int arrQ[ 2 ] = { 1, 2, 3 }; // initialize the first 2, discard the 3rd.
  7e:	4a4a      	ldr	r2, [pc, #296]	; (1a8 <arrays+0x1a8>)
  80:	f107 0344 	add.w	r3, r7, #68	; 0x44
  84:	e892 0003 	ldmia.w	r2, {r0, r1}
  88:	e883 0003 	stmia.w	r3, {r0, r1}
   int arrW[ 3 ] = { 1, 2, 3 }; // initialize all.
  8c:	4a47      	ldr	r2, [pc, #284]	; (1ac <arrays+0x1ac>)
  8e:	f107 0338 	add.w	r3, r7, #56	; 0x38
  92:	ca07      	ldmia	r2, {r0, r1, r2}
  94:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   int arrX[ 4 ] = { 1, 2, 3 }; // initialize the first 3, leave 4th uninitialized.
  98:	f107 0328 	add.w	r3, r7, #40	; 0x28
  9c:	2200      	movs	r2, #0
  9e:	601a      	str	r2, [r3, #0]
  a0:	605a      	str	r2, [r3, #4]
  a2:	609a      	str	r2, [r3, #8]
  a4:	60da      	str	r2, [r3, #12]
  a6:	2301      	movs	r3, #1
  a8:	62bb      	str	r3, [r7, #40]	; 0x28
  aa:	2302      	movs	r3, #2
  ac:	62fb      	str	r3, [r7, #44]	; 0x2c
  ae:	2303      	movs	r3, #3
  b0:	633b      	str	r3, [r7, #48]	; 0x30
   int arrY[ 5 ] = { [2] = 30 };// initialize the 3rd. initialize the rest with zero.
  b2:	f107 0314 	add.w	r3, r7, #20
  b6:	2200      	movs	r2, #0
  b8:	601a      	str	r2, [r3, #0]
  ba:	605a      	str	r2, [r3, #4]
  bc:	609a      	str	r2, [r3, #8]
  be:	60da      	str	r2, [r3, #12]
  c0:	611a      	str	r2, [r3, #16]
  c2:	231e      	movs	r3, #30
  c4:	61fb      	str	r3, [r7, #28]
   int arrZ[ 5 ] = {};          // initialize all with zero.
  c6:	463b      	mov	r3, r7
  c8:	2200      	movs	r2, #0
  ca:	601a      	str	r2, [r3, #0]
  cc:	605a      	str	r2, [r3, #4]
  ce:	609a      	str	r2, [r3, #8]
  d0:	60da      	str	r2, [r3, #12]
  d2:	611a      	str	r2, [r3, #16]

   size_t size = 0;
  d4:	2300      	movs	r3, #0
  d6:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   int count   = 0;
  da:	2300      	movs	r3, #0
  dc:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

   size = sizeof( arrA1 );
  e0:	2300      	movs	r3, #0
  e2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( arrB );
  e6:	2300      	movs	r3, #0
  e8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

   size  = sizeof( arrC );
  ec:	2314      	movs	r3, #20
  ee:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size  = sizeof arrC;
  f2:	2314      	movs	r3, #20
  f4:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   count = sizeof( arrC ) / sizeof( int );
  f8:	2305      	movs	r3, #5
  fa:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

   size = sizeof( lettersA );
  fe:	2305      	movs	r3, #5
 100:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( lettersB );
 104:	2305      	movs	r3, #5
 106:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

   size = sizeof( stringA );
 10a:	2306      	movs	r3, #6
 10c:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( stringB );
 110:	2306      	movs	r3, #6
 112:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( stringC );
 116:	2306      	movs	r3, #6
 118:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

   size = sizeof( wchar_t );
 11c:	2304      	movs	r3, #4
 11e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( unicodeA );
 122:	231c      	movs	r3, #28
 124:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

   size  = sizeof( unicodeB );
 128:	231c      	movs	r3, #28
 12a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   count = sizeof( unicodeB ) / sizeof( wchar_t );
 12e:	2307      	movs	r3, #7
 130:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

   size = sizeof( arrW );
 134:	230c      	movs	r3, #12
 136:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( arrX );
 13a:	2310      	movs	r3, #16
 13c:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( arrY );
 140:	2314      	movs	r3, #20
 142:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

   size = sizeof stringB;
 146:	2306      	movs	r3, #6
 148:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( arrX );
 14c:	2310      	movs	r3, #16
 14e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size = sizeof( arrY );
 152:	2314      	movs	r3, #20
 154:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

   size  = sizeof( arrC );
 158:	2314      	movs	r3, #20
 15a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
   size  = sizeof arrC;
 15e:	2314      	movs	r3, #20
 160:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4


   arrA1[ 0 ] = 1;
 164:	2301      	movs	r3, #1
 166:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
   arrA2[ 0 ] = 2;
 16a:	2302      	movs	r3, #2
 16c:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
   arrA3[ 0 ] = 3;
 170:	2303      	movs	r3, #3
 172:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
   arrB[ 0 ]  = 1;
 176:	2301      	movs	r3, #1
 178:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

   arrC[ 0 ] = 10;
 17c:	230a      	movs	r3, #10
 17e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
   arrC[ 1 ] = 20;
 182:	2314      	movs	r3, #20
 184:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

   stringC[0] = 'F';
 188:	2346      	movs	r3, #70	; 0x46
 18a:	f887 3084 	strb.w	r3, [r7, #132]	; 0x84

}//arrays
 18e:	bf00      	nop
 190:	37cc      	adds	r7, #204	; 0xcc
 192:	46bd      	mov	sp, r7
 194:	bcb0      	pop	{r4, r5, r7}
 196:	4770      	bx	lr
 198:	00000098 	.word	0x00000098
 19c:	000000a0 	.word	0x000000a0
 1a0:	000000a8 	.word	0x000000a8
 1a4:	000000c4 	.word	0x000000c4
 1a8:	000000e0 	.word	0x000000e0
 1ac:	000000e8 	.word	0x000000e8

Disassembly of section .text.everyIdentifierHasAnAddress:

00000000 <everyIdentifierHasAnAddress>:

//-----------------------------------------------------------------------------

void everyIdentifierHasAnAddress( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b097      	sub	sp, #92	; 0x5c
   4:	af00      	add	r7, sp, #0

   int a = 2;
   6:	2302      	movs	r3, #2
   8:	647b      	str	r3, [r7, #68]	; 0x44
   int b = 3;
   a:	2303      	movs	r3, #3
   c:	643b      	str	r3, [r7, #64]	; 0x40
   int c = 0;
   e:	2300      	movs	r3, #0
  10:	657b      	str	r3, [r7, #84]	; 0x54

   int size = sizeof( int );
  12:	2304      	movs	r3, #4
  14:	653b      	str	r3, [r7, #80]	; 0x50
   size = sizeof( c );
  16:	2304      	movs	r3, #4
  18:	653b      	str	r3, [r7, #80]	; 0x50

   int arrA[] = { 10, 20, 30, 40, 50 };
  1a:	4b27      	ldr	r3, [pc, #156]	; (b8 <everyIdentifierHasAnAddress+0xb8>)
  1c:	f107 042c 	add.w	r4, r7, #44	; 0x2c
  20:	461d      	mov	r5, r3
  22:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  24:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  26:	682b      	ldr	r3, [r5, #0]
  28:	6023      	str	r3, [r4, #0]
   int arrB[] = { 10, 20, 30, 40, 50 };
  2a:	4b23      	ldr	r3, [pc, #140]	; (b8 <everyIdentifierHasAnAddress+0xb8>)
  2c:	f107 0418 	add.w	r4, r7, #24
  30:	461d      	mov	r5, r3
  32:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  34:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  36:	682b      	ldr	r3, [r5, #0]
  38:	6023      	str	r3, [r4, #0]
   int arrC[] = { 10, 20, 30, 40, 50 };
  3a:	4b1f      	ldr	r3, [pc, #124]	; (b8 <everyIdentifierHasAnAddress+0xb8>)
  3c:	1d3c      	adds	r4, r7, #4
  3e:	461d      	mov	r5, r3
  40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  44:	682b      	ldr	r3, [r5, #0]
  46:	6023      	str	r3, [r4, #0]

   int *arrD  = { 10, 20, 30, 40, 50 };// !!
  48:	230a      	movs	r3, #10
  4a:	64fb      	str	r3, [r7, #76]	; 0x4c

   size = sizeof( arrC );
  4c:	2314      	movs	r3, #20
  4e:	653b      	str	r3, [r7, #80]	; 0x50
   size = sizeof( arrD );
  50:	2304      	movs	r3, #4
  52:	653b      	str	r3, [r7, #80]	; 0x50

   int i = 2;
  54:	2302      	movs	r3, #2
  56:	64bb      	str	r3, [r7, #72]	; 0x48
   c = arrA[ i ];
  58:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  5a:	009b      	lsls	r3, r3, #2
  5c:	3358      	adds	r3, #88	; 0x58
  5e:	443b      	add	r3, r7
  60:	f853 3c2c 	ldr.w	r3, [r3, #-44]
  64:	657b      	str	r3, [r7, #84]	; 0x54
   c = arrA[ 2 ];
  66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  68:	657b      	str	r3, [r7, #84]	; 0x54
   c = i[ arrA ];
  6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  6c:	009b      	lsls	r3, r3, #2
  6e:	3358      	adds	r3, #88	; 0x58
  70:	443b      	add	r3, r7
  72:	f853 3c2c 	ldr.w	r3, [r3, #-44]
  76:	657b      	str	r3, [r7, #84]	; 0x54
   c = 2[ arrA ];
  78:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  7a:	657b      	str	r3, [r7, #84]	; 0x54

   c = arrA[ 0 ];
  7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  7e:	657b      	str	r3, [r7, #84]	; 0x54
   c = arrD[ 0 ];
  80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  82:	681b      	ldr	r3, [r3, #0]
  84:	657b      	str	r3, [r7, #84]	; 0x54

   c = arrA[ 2 ];
  86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  88:	657b      	str	r3, [r7, #84]	; 0x54
   //c = arrD[ 2 ];//!!

   c = arrays - everyIdentifierHasAnAddress;
  8a:	4a0c      	ldr	r2, [pc, #48]	; (bc <everyIdentifierHasAnAddress+0xbc>)
  8c:	4b0c      	ldr	r3, [pc, #48]	; (c0 <everyIdentifierHasAnAddress+0xc0>)
  8e:	1ad3      	subs	r3, r2, r3
  90:	657b      	str	r3, [r7, #84]	; 0x54
   c = &b - &a;
  92:	f107 0340 	add.w	r3, r7, #64	; 0x40
  96:	f107 0244 	add.w	r2, r7, #68	; 0x44
  9a:	1a9b      	subs	r3, r3, r2
  9c:	109b      	asrs	r3, r3, #2
  9e:	657b      	str	r3, [r7, #84]	; 0x54
   c = (void*)&b - (void*)&a;
  a0:	f107 0240 	add.w	r2, r7, #64	; 0x40
  a4:	f107 0344 	add.w	r3, r7, #68	; 0x44
  a8:	1ad3      	subs	r3, r2, r3
  aa:	657b      	str	r3, [r7, #84]	; 0x54

}//everyIdentifierHasAnAddress
  ac:	bf00      	nop
  ae:	375c      	adds	r7, #92	; 0x5c
  b0:	46bd      	mov	sp, r7
  b2:	bcb0      	pop	{r4, r5, r7}
  b4:	4770      	bx	lr
  b6:	bf00      	nop
  b8:	0000005c 	.word	0x0000005c
	...

Disassembly of section .text.controlFlow_if:

00000000 <controlFlow_if>:

//-----------------------------------------------------------------------------

void controlFlow_if() {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   int a = 2;
   6:	2302      	movs	r3, #2
   8:	60fb      	str	r3, [r7, #12]
   int b = 3;
   a:	2303      	movs	r3, #3
   c:	60bb      	str	r3, [r7, #8]
   int c = 0;
   e:	2300      	movs	r3, #0
  10:	607b      	str	r3, [r7, #4]

   _Bool result = a < b;
  12:	68fa      	ldr	r2, [r7, #12]
  14:	68bb      	ldr	r3, [r7, #8]
  16:	429a      	cmp	r2, r3
  18:	bfb4      	ite	lt
  1a:	2301      	movlt	r3, #1
  1c:	2300      	movge	r3, #0
  1e:	70fb      	strb	r3, [r7, #3]

   if ( result )
  20:	78fb      	ldrb	r3, [r7, #3]
  22:	2b00      	cmp	r3, #0
  24:	d002      	beq.n	2c <controlFlow_if+0x2c>
      c = 1;
  26:	2301      	movs	r3, #1
  28:	607b      	str	r3, [r7, #4]
  2a:	e001      	b.n	30 <controlFlow_if+0x30>
   else
	  c = 0;
  2c:	2300      	movs	r3, #0
  2e:	607b      	str	r3, [r7, #4]

   if ( a < b )
  30:	68fa      	ldr	r2, [r7, #12]
  32:	68bb      	ldr	r3, [r7, #8]
  34:	429a      	cmp	r2, r3
  36:	da02      	bge.n	3e <controlFlow_if+0x3e>
      c = 1;
  38:	2301      	movs	r3, #1
  3a:	607b      	str	r3, [r7, #4]
  3c:	e001      	b.n	42 <controlFlow_if+0x42>
   else
	  c = 0;
  3e:	2300      	movs	r3, #0
  40:	607b      	str	r3, [r7, #4]

   if ( !(a < b) )
  42:	68fa      	ldr	r2, [r7, #12]
  44:	68bb      	ldr	r3, [r7, #8]
  46:	429a      	cmp	r2, r3
  48:	db01      	blt.n	4e <controlFlow_if+0x4e>
      c = 0;
  4a:	2300      	movs	r3, #0
  4c:	607b      	str	r3, [r7, #4]


   enum { colder, cold, warm, hot, hotter } climate = colder;
  4e:	2300      	movs	r3, #0
  50:	70bb      	strb	r3, [r7, #2]

   c = 18;
  52:	2312      	movs	r3, #18
  54:	607b      	str	r3, [r7, #4]

   // if ladder
   if ( c <= -10 ) {
  56:	687b      	ldr	r3, [r7, #4]
  58:	f113 0f09 	cmn.w	r3, #9
  5c:	da02      	bge.n	64 <controlFlow_if+0x64>

	  climate = colder;
  5e:	2300      	movs	r3, #0
  60:	70bb      	strb	r3, [r7, #2]
  62:	e01d      	b.n	a0 <controlFlow_if+0xa0>

   } else if ( ( c > -10 ) && ( c <= 10 ) ) {
  64:	687b      	ldr	r3, [r7, #4]
  66:	f113 0f09 	cmn.w	r3, #9
  6a:	db05      	blt.n	78 <controlFlow_if+0x78>
  6c:	687b      	ldr	r3, [r7, #4]
  6e:	2b0a      	cmp	r3, #10
  70:	dc02      	bgt.n	78 <controlFlow_if+0x78>

	   climate = cold;
  72:	2301      	movs	r3, #1
  74:	70bb      	strb	r3, [r7, #2]
  76:	e013      	b.n	a0 <controlFlow_if+0xa0>

   } else if ( ( c >  10 ) && ( c <= 25 ) ) {
  78:	687b      	ldr	r3, [r7, #4]
  7a:	2b0a      	cmp	r3, #10
  7c:	dd05      	ble.n	8a <controlFlow_if+0x8a>
  7e:	687b      	ldr	r3, [r7, #4]
  80:	2b19      	cmp	r3, #25
  82:	dc02      	bgt.n	8a <controlFlow_if+0x8a>

	   climate = warm;
  84:	2302      	movs	r3, #2
  86:	70bb      	strb	r3, [r7, #2]
  88:	e00a      	b.n	a0 <controlFlow_if+0xa0>

   } else if ( ( c >  25 ) && ( c <= 35 ) ) {
  8a:	687b      	ldr	r3, [r7, #4]
  8c:	2b19      	cmp	r3, #25
  8e:	dd05      	ble.n	9c <controlFlow_if+0x9c>
  90:	687b      	ldr	r3, [r7, #4]
  92:	2b23      	cmp	r3, #35	; 0x23
  94:	dc02      	bgt.n	9c <controlFlow_if+0x9c>

	   climate = hot;
  96:	2303      	movs	r3, #3
  98:	70bb      	strb	r3, [r7, #2]
  9a:	e001      	b.n	a0 <controlFlow_if+0xa0>

   } else {

	   climate = hotter;
  9c:	2304      	movs	r3, #4
  9e:	70bb      	strb	r3, [r7, #2]

   }//if

   // if-ladder switch case alternative
   climate = ( c <= -10 ) ? colder :
  a0:	687b      	ldr	r3, [r7, #4]
  a2:	f113 0f09 	cmn.w	r3, #9
  a6:	db1a      	blt.n	de <controlFlow_if+0xde>
  a8:	687b      	ldr	r3, [r7, #4]
  aa:	f113 0f09 	cmn.w	r3, #9
  ae:	db02      	blt.n	b6 <controlFlow_if+0xb6>
             ( c > -10 ) && ( c <= 10 ) ? cold :
  b0:	687b      	ldr	r3, [r7, #4]
  b2:	2b0a      	cmp	r3, #10
  b4:	dd11      	ble.n	da <controlFlow_if+0xda>
   climate = ( c <= -10 ) ? colder :
  b6:	687b      	ldr	r3, [r7, #4]
  b8:	2b0a      	cmp	r3, #10
  ba:	dd02      	ble.n	c2 <controlFlow_if+0xc2>
             ( c >  10 ) && ( c <= 25 ) ? warm :
  bc:	687b      	ldr	r3, [r7, #4]
  be:	2b19      	cmp	r3, #25
  c0:	dd09      	ble.n	d6 <controlFlow_if+0xd6>
   climate = ( c <= -10 ) ? colder :
  c2:	687b      	ldr	r3, [r7, #4]
  c4:	2b19      	cmp	r3, #25
  c6:	dd04      	ble.n	d2 <controlFlow_if+0xd2>
             ( c >  25 ) && ( c <= 35 ) ? hot  :
  c8:	687b      	ldr	r3, [r7, #4]
  ca:	2b23      	cmp	r3, #35	; 0x23
  cc:	dc01      	bgt.n	d2 <controlFlow_if+0xd2>
   climate = ( c <= -10 ) ? colder :
  ce:	2303      	movs	r3, #3
  d0:	e006      	b.n	e0 <controlFlow_if+0xe0>
  d2:	2304      	movs	r3, #4
  d4:	e004      	b.n	e0 <controlFlow_if+0xe0>
  d6:	2302      	movs	r3, #2
  d8:	e002      	b.n	e0 <controlFlow_if+0xe0>
  da:	2301      	movs	r3, #1
  dc:	e000      	b.n	e0 <controlFlow_if+0xe0>
  de:	2300      	movs	r3, #0
  e0:	70bb      	strb	r3, [r7, #2]
             hotter;


}//controlFlow_if
  e2:	bf00      	nop
  e4:	3714      	adds	r7, #20
  e6:	46bd      	mov	sp, r7
  e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  ec:	4770      	bx	lr

Disassembly of section .text.controlFlow_Switch:

00000000 <controlFlow_Switch>:

//-----------------------------------------------------------------------------

void controlFlow_Switch() {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   int  value = 3;
   6:	2303      	movs	r3, #3
   8:	60fb      	str	r3, [r7, #12]
   char rating = 'X';
   a:	2358      	movs	r3, #88	; 0x58
   c:	72fb      	strb	r3, [r7, #11]

   // fall-through switch
   switch( value ) {
   e:	68fb      	ldr	r3, [r7, #12]
  10:	2b0a      	cmp	r3, #10
  12:	d825      	bhi.n	60 <controlFlow_Switch+0x60>
  14:	a201      	add	r2, pc, #4	; (adr r2, 1c <controlFlow_Switch+0x1c>)
  16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  1a:	bf00      	nop
  1c:	00000049 	.word	0x00000049
  20:	00000049 	.word	0x00000049
  24:	00000049 	.word	0x00000049
  28:	0000004f 	.word	0x0000004f
  2c:	0000004f 	.word	0x0000004f
  30:	0000004f 	.word	0x0000004f
  34:	00000055 	.word	0x00000055
  38:	00000055 	.word	0x00000055
  3c:	00000055 	.word	0x00000055
  40:	0000005b 	.word	0x0000005b
  44:	0000005b 	.word	0x0000005b

	   case 0 :
	   case 1 :
	   case 2 :
		   rating = 'D';
  48:	2344      	movs	r3, #68	; 0x44
  4a:	72fb      	strb	r3, [r7, #11]
		   break;
  4c:	e00a      	b.n	64 <controlFlow_Switch+0x64>

	   case 3 :
	   case 4 :
	   case 5 :
		   rating = 'C';
  4e:	2343      	movs	r3, #67	; 0x43
  50:	72fb      	strb	r3, [r7, #11]
	   break;
  52:	e007      	b.n	64 <controlFlow_Switch+0x64>

	   case 6 :
	   case 7 :
	   case 8 :
		   rating = 'B';
  54:	2342      	movs	r3, #66	; 0x42
  56:	72fb      	strb	r3, [r7, #11]
		   break;
  58:	e004      	b.n	64 <controlFlow_Switch+0x64>

	   case 9 :
	   case 10 :
		   rating = 'A';
  5a:	2341      	movs	r3, #65	; 0x41
  5c:	72fb      	strb	r3, [r7, #11]
		   break;
  5e:	e001      	b.n	64 <controlFlow_Switch+0x64>

	   default :
		   rating = 'X';
  60:	2358      	movs	r3, #88	; 0x58
  62:	72fb      	strb	r3, [r7, #11]

   }//switch

	enum { colder, cold, warm, hot, hotter } climate = cold;
  64:	2301      	movs	r3, #1
  66:	72bb      	strb	r3, [r7, #10]
	wchar_t* text = "bilinmiyor";
  68:	4b13      	ldr	r3, [pc, #76]	; (b8 <controlFlow_Switch+0xb8>)
  6a:	607b      	str	r3, [r7, #4]

	// switch without default
	switch ( climate ) {
  6c:	7abb      	ldrb	r3, [r7, #10]
  6e:	2b04      	cmp	r3, #4
  70:	d81b      	bhi.n	aa <controlFlow_Switch+0xaa>
  72:	a201      	add	r2, pc, #4	; (adr r2, 78 <controlFlow_Switch+0x78>)
  74:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  78:	0000008d 	.word	0x0000008d
  7c:	00000093 	.word	0x00000093
  80:	00000099 	.word	0x00000099
  84:	0000009f 	.word	0x0000009f
  88:	000000a5 	.word	0x000000a5
		case colder : text = L"çok soğuk"; break;
  8c:	4b0b      	ldr	r3, [pc, #44]	; (bc <controlFlow_Switch+0xbc>)
  8e:	607b      	str	r3, [r7, #4]
  90:	e00b      	b.n	aa <controlFlow_Switch+0xaa>
		case cold   : text = L"soğuk";     break;
  92:	4b0b      	ldr	r3, [pc, #44]	; (c0 <controlFlow_Switch+0xc0>)
  94:	607b      	str	r3, [r7, #4]
  96:	e008      	b.n	aa <controlFlow_Switch+0xaa>
		case warm   : text = L"ılık";      break;
  98:	4b0a      	ldr	r3, [pc, #40]	; (c4 <controlFlow_Switch+0xc4>)
  9a:	607b      	str	r3, [r7, #4]
  9c:	e005      	b.n	aa <controlFlow_Switch+0xaa>
		case hot    : text = L"sıcak";     break;
  9e:	4b0a      	ldr	r3, [pc, #40]	; (c8 <controlFlow_Switch+0xc8>)
  a0:	607b      	str	r3, [r7, #4]
  a2:	e002      	b.n	aa <controlFlow_Switch+0xaa>
		case hotter : text = L"çok sıcak"; break;
  a4:	4b09      	ldr	r3, [pc, #36]	; (cc <controlFlow_Switch+0xcc>)
  a6:	607b      	str	r3, [r7, #4]
  a8:	bf00      	nop
	};

}//controlFlow_Switch
  aa:	bf00      	nop
  ac:	3714      	adds	r7, #20
  ae:	46bd      	mov	sp, r7
  b0:	f85d 7b04 	ldr.w	r7, [sp], #4
  b4:	4770      	bx	lr
  b6:	bf00      	nop
  b8:	000000f4 	.word	0x000000f4
  bc:	00000100 	.word	0x00000100
  c0:	00000128 	.word	0x00000128
  c4:	00000140 	.word	0x00000140
  c8:	00000154 	.word	0x00000154
  cc:	0000016c 	.word	0x0000016c

Disassembly of section .text.sinus:

00000000 <sinus>:
//-----------------------------------------------------------------------------

/*
 * switch sample : lookup table
 */
float sinus( int angle ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]

	// TODO : process sign 0..360 degrees
	angle = angle > 45 ? 90 - angle : angle;
   8:	687b      	ldr	r3, [r7, #4]
   a:	2b2d      	cmp	r3, #45	; 0x2d
   c:	dd03      	ble.n	16 <sinus+0x16>
   e:	687b      	ldr	r3, [r7, #4]
  10:	f1c3 035a 	rsb	r3, r3, #90	; 0x5a
  14:	e000      	b.n	18 <sinus+0x18>
  16:	687b      	ldr	r3, [r7, #4]
  18:	607b      	str	r3, [r7, #4]

	switch( angle ) {
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	2b2d      	cmp	r3, #45	; 0x2d
  1e:	d85f      	bhi.n	e0 <sinus+0xe0>
  20:	a201      	add	r2, pc, #4	; (adr r2, 28 <sinus+0x28>)
  22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  26:	bf00      	nop
  28:	000000e5 	.word	0x000000e5
  2c:	000000eb 	.word	0x000000eb
  30:	000000ef 	.word	0x000000ef
  34:	000000f3 	.word	0x000000f3
  38:	000000f7 	.word	0x000000f7
  3c:	000000fb 	.word	0x000000fb
  40:	000000ff 	.word	0x000000ff
  44:	00000103 	.word	0x00000103
  48:	00000107 	.word	0x00000107
  4c:	0000010b 	.word	0x0000010b
  50:	0000010f 	.word	0x0000010f
  54:	00000113 	.word	0x00000113
  58:	00000117 	.word	0x00000117
  5c:	0000011b 	.word	0x0000011b
  60:	0000011f 	.word	0x0000011f
  64:	00000123 	.word	0x00000123
  68:	00000127 	.word	0x00000127
  6c:	0000012b 	.word	0x0000012b
  70:	0000012f 	.word	0x0000012f
  74:	00000133 	.word	0x00000133
  78:	00000137 	.word	0x00000137
  7c:	0000013b 	.word	0x0000013b
  80:	0000013f 	.word	0x0000013f
  84:	00000143 	.word	0x00000143
  88:	00000147 	.word	0x00000147
  8c:	0000014b 	.word	0x0000014b
  90:	0000014f 	.word	0x0000014f
  94:	00000153 	.word	0x00000153
  98:	00000157 	.word	0x00000157
  9c:	0000015b 	.word	0x0000015b
  a0:	0000015f 	.word	0x0000015f
  a4:	00000165 	.word	0x00000165
  a8:	00000169 	.word	0x00000169
  ac:	0000016d 	.word	0x0000016d
  b0:	00000171 	.word	0x00000171
  b4:	00000175 	.word	0x00000175
  b8:	00000179 	.word	0x00000179
  bc:	0000017d 	.word	0x0000017d
  c0:	00000181 	.word	0x00000181
  c4:	00000185 	.word	0x00000185
  c8:	00000189 	.word	0x00000189
  cc:	0000018d 	.word	0x0000018d
  d0:	00000191 	.word	0x00000191
  d4:	00000195 	.word	0x00000195
  d8:	00000199 	.word	0x00000199
  dc:	0000019d 	.word	0x0000019d

    	default : return NAN;
  e0:	4b33      	ldr	r3, [pc, #204]	; (1b0 <sinus+0x1b0>)
  e2:	e05c      	b.n	19e <sinus+0x19e>

	    case 0  : return .0000;
  e4:	f04f 0300 	mov.w	r3, #0
  e8:	e059      	b.n	19e <sinus+0x19e>
		case 1  : return .0175;
  ea:	4b32      	ldr	r3, [pc, #200]	; (1b4 <sinus+0x1b4>)
  ec:	e057      	b.n	19e <sinus+0x19e>
		case 2  : return .0349;
  ee:	4b32      	ldr	r3, [pc, #200]	; (1b8 <sinus+0x1b8>)
  f0:	e055      	b.n	19e <sinus+0x19e>
		case 3  : return .0523;
  f2:	4b32      	ldr	r3, [pc, #200]	; (1bc <sinus+0x1bc>)
  f4:	e053      	b.n	19e <sinus+0x19e>
		case 4  : return .0698;
  f6:	4b32      	ldr	r3, [pc, #200]	; (1c0 <sinus+0x1c0>)
  f8:	e051      	b.n	19e <sinus+0x19e>
		case 5  : return .0872;
  fa:	4b32      	ldr	r3, [pc, #200]	; (1c4 <sinus+0x1c4>)
  fc:	e04f      	b.n	19e <sinus+0x19e>
		case 6  : return .1045;
  fe:	4b32      	ldr	r3, [pc, #200]	; (1c8 <sinus+0x1c8>)
 100:	e04d      	b.n	19e <sinus+0x19e>
		case 7  : return .1219;
 102:	4b32      	ldr	r3, [pc, #200]	; (1cc <sinus+0x1cc>)
 104:	e04b      	b.n	19e <sinus+0x19e>
		case 8  : return .1392;
 106:	4b32      	ldr	r3, [pc, #200]	; (1d0 <sinus+0x1d0>)
 108:	e049      	b.n	19e <sinus+0x19e>
		case 9  : return .1564;
 10a:	4b32      	ldr	r3, [pc, #200]	; (1d4 <sinus+0x1d4>)
 10c:	e047      	b.n	19e <sinus+0x19e>
		case 10 : return .1736;
 10e:	4b32      	ldr	r3, [pc, #200]	; (1d8 <sinus+0x1d8>)
 110:	e045      	b.n	19e <sinus+0x19e>
		case 11 : return .1908;
 112:	4b32      	ldr	r3, [pc, #200]	; (1dc <sinus+0x1dc>)
 114:	e043      	b.n	19e <sinus+0x19e>
		case 12 : return .2079;
 116:	4b32      	ldr	r3, [pc, #200]	; (1e0 <sinus+0x1e0>)
 118:	e041      	b.n	19e <sinus+0x19e>
		case 13 : return .2250;
 11a:	4b32      	ldr	r3, [pc, #200]	; (1e4 <sinus+0x1e4>)
 11c:	e03f      	b.n	19e <sinus+0x19e>
		case 14 : return .2419;
 11e:	4b32      	ldr	r3, [pc, #200]	; (1e8 <sinus+0x1e8>)
 120:	e03d      	b.n	19e <sinus+0x19e>
		case 15 : return .2588;
 122:	4b32      	ldr	r3, [pc, #200]	; (1ec <sinus+0x1ec>)
 124:	e03b      	b.n	19e <sinus+0x19e>
		case 16 : return .2756;
 126:	4b32      	ldr	r3, [pc, #200]	; (1f0 <sinus+0x1f0>)
 128:	e039      	b.n	19e <sinus+0x19e>
		case 17 : return .2924;
 12a:	4b32      	ldr	r3, [pc, #200]	; (1f4 <sinus+0x1f4>)
 12c:	e037      	b.n	19e <sinus+0x19e>
		case 18 : return .3090;
 12e:	4b32      	ldr	r3, [pc, #200]	; (1f8 <sinus+0x1f8>)
 130:	e035      	b.n	19e <sinus+0x19e>
		case 19 : return .3256;
 132:	4b32      	ldr	r3, [pc, #200]	; (1fc <sinus+0x1fc>)
 134:	e033      	b.n	19e <sinus+0x19e>
		case 20 : return .3420;
 136:	4b32      	ldr	r3, [pc, #200]	; (200 <sinus+0x200>)
 138:	e031      	b.n	19e <sinus+0x19e>
		case 21 : return .3584;
 13a:	4b32      	ldr	r3, [pc, #200]	; (204 <sinus+0x204>)
 13c:	e02f      	b.n	19e <sinus+0x19e>
		case 22 : return .3746;
 13e:	4b32      	ldr	r3, [pc, #200]	; (208 <sinus+0x208>)
 140:	e02d      	b.n	19e <sinus+0x19e>
		case 23 : return .3907;
 142:	4b32      	ldr	r3, [pc, #200]	; (20c <sinus+0x20c>)
 144:	e02b      	b.n	19e <sinus+0x19e>
		case 24 : return .4067;
 146:	4b32      	ldr	r3, [pc, #200]	; (210 <sinus+0x210>)
 148:	e029      	b.n	19e <sinus+0x19e>
		case 25 : return .4226;
 14a:	4b32      	ldr	r3, [pc, #200]	; (214 <sinus+0x214>)
 14c:	e027      	b.n	19e <sinus+0x19e>
		case 26 : return .4384;
 14e:	4b32      	ldr	r3, [pc, #200]	; (218 <sinus+0x218>)
 150:	e025      	b.n	19e <sinus+0x19e>
		case 27 : return .4540;
 152:	4b32      	ldr	r3, [pc, #200]	; (21c <sinus+0x21c>)
 154:	e023      	b.n	19e <sinus+0x19e>
		case 28 : return .4695;
 156:	4b32      	ldr	r3, [pc, #200]	; (220 <sinus+0x220>)
 158:	e021      	b.n	19e <sinus+0x19e>
		case 29 : return .4848;
 15a:	4b32      	ldr	r3, [pc, #200]	; (224 <sinus+0x224>)
 15c:	e01f      	b.n	19e <sinus+0x19e>
		case 30 : return .5000;
 15e:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
 162:	e01c      	b.n	19e <sinus+0x19e>
		case 31 : return .5150;
 164:	4b30      	ldr	r3, [pc, #192]	; (228 <sinus+0x228>)
 166:	e01a      	b.n	19e <sinus+0x19e>
		case 32 : return .5299;
 168:	4b30      	ldr	r3, [pc, #192]	; (22c <sinus+0x22c>)
 16a:	e018      	b.n	19e <sinus+0x19e>
		case 33 : return .5446;
 16c:	4b30      	ldr	r3, [pc, #192]	; (230 <sinus+0x230>)
 16e:	e016      	b.n	19e <sinus+0x19e>
		case 34 : return .5592;
 170:	4b30      	ldr	r3, [pc, #192]	; (234 <sinus+0x234>)
 172:	e014      	b.n	19e <sinus+0x19e>
		case 35 : return .5736;
 174:	4b30      	ldr	r3, [pc, #192]	; (238 <sinus+0x238>)
 176:	e012      	b.n	19e <sinus+0x19e>
		case 36 : return .5878;
 178:	4b30      	ldr	r3, [pc, #192]	; (23c <sinus+0x23c>)
 17a:	e010      	b.n	19e <sinus+0x19e>
		case 37 : return .6018;
 17c:	4b30      	ldr	r3, [pc, #192]	; (240 <sinus+0x240>)
 17e:	e00e      	b.n	19e <sinus+0x19e>
		case 38 : return .6157;
 180:	4b30      	ldr	r3, [pc, #192]	; (244 <sinus+0x244>)
 182:	e00c      	b.n	19e <sinus+0x19e>
		case 39 : return .6293;
 184:	4b30      	ldr	r3, [pc, #192]	; (248 <sinus+0x248>)
 186:	e00a      	b.n	19e <sinus+0x19e>
		case 40 : return .6428;
 188:	4b30      	ldr	r3, [pc, #192]	; (24c <sinus+0x24c>)
 18a:	e008      	b.n	19e <sinus+0x19e>
		case 41 : return .6561;
 18c:	4b30      	ldr	r3, [pc, #192]	; (250 <sinus+0x250>)
 18e:	e006      	b.n	19e <sinus+0x19e>
		case 42 : return .6691;
 190:	4b30      	ldr	r3, [pc, #192]	; (254 <sinus+0x254>)
 192:	e004      	b.n	19e <sinus+0x19e>
		case 43 : return .6820;
 194:	4b30      	ldr	r3, [pc, #192]	; (258 <sinus+0x258>)
 196:	e002      	b.n	19e <sinus+0x19e>
		case 44 : return .6947;
 198:	4b30      	ldr	r3, [pc, #192]	; (25c <sinus+0x25c>)
 19a:	e000      	b.n	19e <sinus+0x19e>
		case 45 : return .7071;
 19c:	4b30      	ldr	r3, [pc, #192]	; (260 <sinus+0x260>)

	};//switch

}//sinus
 19e:	ee07 3a90 	vmov	s15, r3
 1a2:	eeb0 0a67 	vmov.f32	s0, s15
 1a6:	370c      	adds	r7, #12
 1a8:	46bd      	mov	sp, r7
 1aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 1ae:	4770      	bx	lr
 1b0:	7fc00000 	.word	0x7fc00000
 1b4:	3c8f5c29 	.word	0x3c8f5c29
 1b8:	3d0ef34d 	.word	0x3d0ef34d
 1bc:	3d563886 	.word	0x3d563886
 1c0:	3d8ef34d 	.word	0x3d8ef34d
 1c4:	3db295ea 	.word	0x3db295ea
 1c8:	3dd60419 	.word	0x3dd60419
 1cc:	3df9a6b5 	.word	0x3df9a6b5
 1d0:	3e0e8a72 	.word	0x3e0e8a72
 1d4:	3e202752 	.word	0x3e202752
 1d8:	3e31c433 	.word	0x3e31c433
 1dc:	3e436113 	.word	0x3e436113
 1e0:	3e54e3bd 	.word	0x3e54e3bd
 1e4:	3e666666 	.word	0x3e666666
 1e8:	3e77b4a2 	.word	0x3e77b4a2
 1ec:	3e84816f 	.word	0x3e84816f
 1f0:	3e8d1b71 	.word	0x3e8d1b71
 1f4:	3e95b574 	.word	0x3e95b574
 1f8:	3e9e353f 	.word	0x3e9e353f
 1fc:	3ea6b50b 	.word	0x3ea6b50b
 200:	3eaf1aa0 	.word	0x3eaf1aa0
 204:	3eb78034 	.word	0x3eb78034
 208:	3ebfcb92 	.word	0x3ebfcb92
 20c:	3ec809d5 	.word	0x3ec809d5
 210:	3ed03afb 	.word	0x3ed03afb
 214:	3ed85f07 	.word	0x3ed85f07
 218:	3ee075f7 	.word	0x3ee075f7
 21c:	3ee872b0 	.word	0x3ee872b0
 220:	3ef0624e 	.word	0x3ef0624e
 224:	3ef837b5 	.word	0x3ef837b5
 228:	3f03d70a 	.word	0x3f03d70a
 22c:	3f07a787 	.word	0x3f07a787
 230:	3f0b6ae8 	.word	0x3f0b6ae8
 234:	3f0f27bb 	.word	0x3f0f27bb
 238:	3f12d773 	.word	0x3f12d773
 23c:	3f167a10 	.word	0x3f167a10
 240:	3f1a0f91 	.word	0x3f1a0f91
 244:	3f1d9e84 	.word	0x3f1d9e84
 248:	3f2119ce 	.word	0x3f2119ce
 24c:	3f248e8a 	.word	0x3f248e8a
 250:	3f27f62b 	.word	0x3f27f62b
 254:	3f2b4a23 	.word	0x3f2b4a23
 258:	3f2e978d 	.word	0x3f2e978d
 25c:	3f31d7dc 	.word	0x3f31d7dc
 260:	3f350481 	.word	0x3f350481

Disassembly of section .text.dosomething:

00000000 <dosomething>:

//-----------------------------------------------------------------------------

typedef int (*callsomething)( int, int );

int dosomething( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

	int loop = 3;
   a:	2303      	movs	r3, #3
   c:	60fb      	str	r3, [r7, #12]
	while ( loop-- );
   e:	bf00      	nop
  10:	68fb      	ldr	r3, [r7, #12]
  12:	1e5a      	subs	r2, r3, #1
  14:	60fa      	str	r2, [r7, #12]
  16:	2b00      	cmp	r3, #0
  18:	d1fa      	bne.n	10 <dosomething+0x10>

	return 0;
  1a:	2300      	movs	r3, #0

}//dosomething
  1c:	4618      	mov	r0, r3
  1e:	3714      	adds	r7, #20
  20:	46bd      	mov	sp, r7
  22:	f85d 7b04 	ldr.w	r7, [sp], #4
  26:	4770      	bx	lr

Disassembly of section .text.dosomething_endmarker:

00000000 <dosomething_endmarker>:

void dosomething_endmarker( void ) {
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0


}//dosomething_endmarker
   4:	bf00      	nop
   6:	46bd      	mov	sp, r7
   8:	f85d 7b04 	ldr.w	r7, [sp], #4
   c:	4770      	bx	lr

Disassembly of section .text.messWithTheFunctions:

00000000 <messWithTheFunctions>:

void messWithTheFunctions() {
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0

	int size = (void*)dosomething_endmarker - (void*)dosomething;
   6:	4a12      	ldr	r2, [pc, #72]	; (50 <messWithTheFunctions+0x50>)
   8:	4b12      	ldr	r3, [pc, #72]	; (54 <messWithTheFunctions+0x54>)
   a:	1ad3      	subs	r3, r2, r3
   c:	60fb      	str	r3, [r7, #12]

	char *source = dosomething;
   e:	4b11      	ldr	r3, [pc, #68]	; (54 <messWithTheFunctions+0x54>)
  10:	60bb      	str	r3, [r7, #8]
	char *target = calloc( size, sizeof(char) );
  12:	68fb      	ldr	r3, [r7, #12]
  14:	2101      	movs	r1, #1
  16:	4618      	mov	r0, r3
  18:	f7ff fffe 	bl	0 <calloc>
  1c:	4603      	mov	r3, r0
  1e:	607b      	str	r3, [r7, #4]

	while ( size-- )
  20:	e007      	b.n	32 <messWithTheFunctions+0x32>
		*target++ = *source++;
  22:	68ba      	ldr	r2, [r7, #8]
  24:	1c53      	adds	r3, r2, #1
  26:	60bb      	str	r3, [r7, #8]
  28:	687b      	ldr	r3, [r7, #4]
  2a:	1c59      	adds	r1, r3, #1
  2c:	6079      	str	r1, [r7, #4]
  2e:	7812      	ldrb	r2, [r2, #0]
  30:	701a      	strb	r2, [r3, #0]
	while ( size-- )
  32:	68fb      	ldr	r3, [r7, #12]
  34:	1e5a      	subs	r2, r3, #1
  36:	60fa      	str	r2, [r7, #12]
  38:	2b00      	cmp	r3, #0
  3a:	d1f2      	bne.n	22 <messWithTheFunctions+0x22>

	callsomething call = target;
  3c:	687b      	ldr	r3, [r7, #4]
  3e:	603b      	str	r3, [r7, #0]

	call( 3, 5 );
  40:	683b      	ldr	r3, [r7, #0]
  42:	2105      	movs	r1, #5
  44:	2003      	movs	r0, #3
  46:	4798      	blx	r3

}//messWithTheFunctions
  48:	bf00      	nop
  4a:	3710      	adds	r7, #16
  4c:	46bd      	mov	sp, r7
  4e:	bd80      	pop	{r7, pc}
	...

Disassembly of section .text.printArguments:

00000000 <printArguments>:

//-----------------------------------------------------------------------------

void printArguments( int argc, char** argv ) {
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

	for ( int i = 0; i < argc; i++ ) {
   a:	2300      	movs	r3, #0
   c:	60fb      	str	r3, [r7, #12]
   e:	e00d      	b.n	2c <printArguments+0x2c>
		printf( "[%d] : %s\r\n", (i+1), argv[i] );
  10:	68fb      	ldr	r3, [r7, #12]
  12:	1c59      	adds	r1, r3, #1
  14:	68fb      	ldr	r3, [r7, #12]
  16:	009b      	lsls	r3, r3, #2
  18:	683a      	ldr	r2, [r7, #0]
  1a:	4413      	add	r3, r2
  1c:	681b      	ldr	r3, [r3, #0]
  1e:	461a      	mov	r2, r3
  20:	4807      	ldr	r0, [pc, #28]	; (40 <printArguments+0x40>)
  22:	f7ff fffe 	bl	0 <printf>
	for ( int i = 0; i < argc; i++ ) {
  26:	68fb      	ldr	r3, [r7, #12]
  28:	3301      	adds	r3, #1
  2a:	60fb      	str	r3, [r7, #12]
  2c:	68fa      	ldr	r2, [r7, #12]
  2e:	687b      	ldr	r3, [r7, #4]
  30:	429a      	cmp	r2, r3
  32:	dbed      	blt.n	10 <printArguments+0x10>
	}//for

}//printArguments
  34:	bf00      	nop
  36:	bf00      	nop
  38:	3710      	adds	r7, #16
  3a:	46bd      	mov	sp, r7
  3c:	bd80      	pop	{r7, pc}
  3e:	bf00      	nop
  40:	00000194 	.word	0x00000194

Disassembly of section .text.nop:

00000000 <nop>:

// iki "int" tipinde değer alan ve bir "int" tipinde değer döndüren
// her tür fonksiyonu gösterebilen "function pointer" tanımla.
typedef int (*operation)( int, int );

int nop( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
	return 0;
   a:	2300      	movs	r3, #0
}
   c:	4618      	mov	r0, r3
   e:	370c      	adds	r7, #12
  10:	46bd      	mov	sp, r7
  12:	f85d 7b04 	ldr.w	r7, [sp], #4
  16:	4770      	bx	lr

Disassembly of section .text.add:

00000000 <add>:

int add( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
	return a + b;
   a:	687a      	ldr	r2, [r7, #4]
   c:	683b      	ldr	r3, [r7, #0]
   e:	4413      	add	r3, r2
}
  10:	4618      	mov	r0, r3
  12:	370c      	adds	r7, #12
  14:	46bd      	mov	sp, r7
  16:	f85d 7b04 	ldr.w	r7, [sp], #4
  1a:	4770      	bx	lr

Disassembly of section .text.sub:

00000000 <sub>:

int sub( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
	return a - b;
   a:	687a      	ldr	r2, [r7, #4]
   c:	683b      	ldr	r3, [r7, #0]
   e:	1ad3      	subs	r3, r2, r3
}
  10:	4618      	mov	r0, r3
  12:	370c      	adds	r7, #12
  14:	46bd      	mov	sp, r7
  16:	f85d 7b04 	ldr.w	r7, [sp], #4
  1a:	4770      	bx	lr

Disassembly of section .text.mul:

00000000 <mul>:

int mul( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
	return a * b;
   a:	687b      	ldr	r3, [r7, #4]
   c:	683a      	ldr	r2, [r7, #0]
   e:	fb02 f303 	mul.w	r3, r2, r3
}
  12:	4618      	mov	r0, r3
  14:	370c      	adds	r7, #12
  16:	46bd      	mov	sp, r7
  18:	f85d 7b04 	ldr.w	r7, [sp], #4
  1c:	4770      	bx	lr

Disassembly of section .text.idv:

00000000 <idv>:

int idv( int a, int b ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
	return a / b;
   a:	687a      	ldr	r2, [r7, #4]
   c:	683b      	ldr	r3, [r7, #0]
   e:	fb92 f3f3 	sdiv	r3, r2, r3
}
  12:	4618      	mov	r0, r3
  14:	370c      	adds	r7, #12
  16:	46bd      	mov	sp, r7
  18:	f85d 7b04 	ldr.w	r7, [sp], #4
  1c:	4770      	bx	lr

Disassembly of section .text.parseArguments:

00000000 <parseArguments>:
 * out_operandB : tamsayı değer.
 *
 * RETURN:
 * void
 */
void parseArguments( char** in_values, char* out_operator, int* out_operandA, int* out_operandB ) {
   0:	b480      	push	{r7}
   2:	b08b      	sub	sp, #44	; 0x2c
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	607a      	str	r2, [r7, #4]
   c:	603b      	str	r3, [r7, #0]

	*out_operator = in_values[ 1 ][ 0 ];
   e:	68fb      	ldr	r3, [r7, #12]
  10:	3304      	adds	r3, #4
  12:	681b      	ldr	r3, [r3, #0]
  14:	781a      	ldrb	r2, [r3, #0]
  16:	68bb      	ldr	r3, [r7, #8]
  18:	701a      	strb	r2, [r3, #0]

    int* values[] = { out_operandA, out_operandB };
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	613b      	str	r3, [r7, #16]
  1e:	683b      	ldr	r3, [r7, #0]
  20:	617b      	str	r3, [r7, #20]
    int index     = ( sizeof(values) / sizeof(int*) );
  22:	2302      	movs	r3, #2
  24:	627b      	str	r3, [r7, #36]	; 0x24

	while ( index ) {
  26:	e03d      	b.n	a4 <parseArguments+0xa4>

		char *valueStart = NULL;
  28:	2300      	movs	r3, #0
  2a:	61bb      	str	r3, [r7, #24]
		char *valueEnd   = NULL;
  2c:	2300      	movs	r3, #0
  2e:	623b      	str	r3, [r7, #32]

		// string'in başına git
		valueStart = valueEnd = in_values[ index + 1 ];
  30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  32:	3301      	adds	r3, #1
  34:	009b      	lsls	r3, r3, #2
  36:	68fa      	ldr	r2, [r7, #12]
  38:	4413      	add	r3, r2
  3a:	681b      	ldr	r3, [r3, #0]
  3c:	623b      	str	r3, [r7, #32]
  3e:	6a3b      	ldr	r3, [r7, #32]
  40:	61bb      	str	r3, [r7, #24]

		// string'in sonuna git
		while ( *++valueEnd );
  42:	bf00      	nop
  44:	6a3b      	ldr	r3, [r7, #32]
  46:	3301      	adds	r3, #1
  48:	623b      	str	r3, [r7, #32]
  4a:	6a3b      	ldr	r3, [r7, #32]
  4c:	781b      	ldrb	r3, [r3, #0]
  4e:	2b00      	cmp	r3, #0
  50:	d1f8      	bne.n	44 <parseArguments+0x44>

		// son, baştan büyük olduğu sürece "geri" git ve basamakların değerini hesapla
		int place = 1;
  52:	2301      	movs	r3, #1
  54:	61fb      	str	r3, [r7, #28]
		while ( valueStart < valueEnd-- ) {
  56:	e01c      	b.n	92 <parseArguments+0x92>

			*values[ index - 1 ] += ( *valueEnd - '0' ) * place;
  58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  5a:	3b01      	subs	r3, #1
  5c:	009b      	lsls	r3, r3, #2
  5e:	3328      	adds	r3, #40	; 0x28
  60:	443b      	add	r3, r7
  62:	f853 3c18 	ldr.w	r3, [r3, #-24]
  66:	6819      	ldr	r1, [r3, #0]
  68:	6a3b      	ldr	r3, [r7, #32]
  6a:	781b      	ldrb	r3, [r3, #0]
  6c:	3b30      	subs	r3, #48	; 0x30
  6e:	69fa      	ldr	r2, [r7, #28]
  70:	fb03 f202 	mul.w	r2, r3, r2
  74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  76:	3b01      	subs	r3, #1
  78:	009b      	lsls	r3, r3, #2
  7a:	3328      	adds	r3, #40	; 0x28
  7c:	443b      	add	r3, r7
  7e:	f853 3c18 	ldr.w	r3, [r3, #-24]
  82:	440a      	add	r2, r1
  84:	601a      	str	r2, [r3, #0]
			place *= 10;
  86:	69fa      	ldr	r2, [r7, #28]
  88:	4613      	mov	r3, r2
  8a:	009b      	lsls	r3, r3, #2
  8c:	4413      	add	r3, r2
  8e:	005b      	lsls	r3, r3, #1
  90:	61fb      	str	r3, [r7, #28]
		while ( valueStart < valueEnd-- ) {
  92:	6a3b      	ldr	r3, [r7, #32]
  94:	1e5a      	subs	r2, r3, #1
  96:	623a      	str	r2, [r7, #32]
  98:	69ba      	ldr	r2, [r7, #24]
  9a:	429a      	cmp	r2, r3
  9c:	d3dc      	bcc.n	58 <parseArguments+0x58>

		}

		index--;
  9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  a0:	3b01      	subs	r3, #1
  a2:	627b      	str	r3, [r7, #36]	; 0x24
	while ( index ) {
  a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  a6:	2b00      	cmp	r3, #0
  a8:	d1be      	bne.n	28 <parseArguments+0x28>

	}//while

}//parseArguments
  aa:	bf00      	nop
  ac:	bf00      	nop
  ae:	372c      	adds	r7, #44	; 0x2c
  b0:	46bd      	mov	sp, r7
  b2:	f85d 7b04 	ldr.w	r7, [sp], #4
  b6:	4770      	bx	lr

Disassembly of section .text.functionPointerSample:

00000000 <functionPointerSample>:

/*
 *  Eclipse, komut satırı parametrelerini belirle:
 *  Run => Debug Configurations... => tab[Arguments] => textbox[Program arguments]: + 1234 789
 */
int functionPointerSample( int argc, char** argv ) {
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b08d      	sub	sp, #52	; 0x34
   6:	af00      	add	r7, sp, #0
   8:	6078      	str	r0, [r7, #4]
   a:	6039      	str	r1, [r7, #0]
   c:	466b      	mov	r3, sp
   e:	461e      	mov	r6, r3

	const int minArgs = 4;
  10:	2304      	movs	r3, #4
  12:	62bb      	str	r3, [r7, #40]	; 0x28

	if ( argc < minArgs ) {
  14:	687a      	ldr	r2, [r7, #4]
  16:	6abb      	ldr	r3, [r7, #40]	; 0x28
  18:	429a      	cmp	r2, r3
  1a:	da04      	bge.n	26 <functionPointerSample+0x26>
	   puts( "Argüman sayısı yetersiz. En az 3 argüman gerekli." );
  1c:	483a      	ldr	r0, [pc, #232]	; (108 <functionPointerSample+0x108>)
  1e:	f7ff fffe 	bl	0 <puts>
	   return EXIT_FAILURE;
  22:	2301      	movs	r3, #1
  24:	e069      	b.n	fa <functionPointerSample+0xfa>
	}

	// operatör ve operandların değerlerini tutacak değişkenleri hazırla
	char operator = '\0';
  26:	2300      	movs	r3, #0
  28:	75fb      	strb	r3, [r7, #23]
	int  operandA = 0;
  2a:	2300      	movs	r3, #0
  2c:	613b      	str	r3, [r7, #16]
	int  operandB = 0;
  2e:	2300      	movs	r3, #0
  30:	60fb      	str	r3, [r7, #12]

	// komut satırından girlen "ham" metinleri "kullanılabilir" veriye çevir
	parseArguments( argv, &operator, &operandA, &operandB );
  32:	f107 030c 	add.w	r3, r7, #12
  36:	f107 0210 	add.w	r2, r7, #16
  3a:	f107 0117 	add.w	r1, r7, #23
  3e:	6838      	ldr	r0, [r7, #0]
  40:	f7ff fffe 	bl	0 <functionPointerSample>

	// operatörlere karşılık gelen operasyonları sağlayan fonksiyonların
	// adreslerini tutan "lookup table"ı tanımla
	const int maxEntries = 255;
  44:	23ff      	movs	r3, #255	; 0xff
  46:	627b      	str	r3, [r7, #36]	; 0x24
	operation operations[ maxEntries ];
  48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4a:	3b01      	subs	r3, #1
  4c:	623b      	str	r3, [r7, #32]
  4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  50:	2200      	movs	r2, #0
  52:	4698      	mov	r8, r3
  54:	4691      	mov	r9, r2
  56:	f04f 0200 	mov.w	r2, #0
  5a:	f04f 0300 	mov.w	r3, #0
  5e:	ea4f 1349 	mov.w	r3, r9, lsl #5
  62:	ea43 63d8 	orr.w	r3, r3, r8, lsr #27
  66:	ea4f 1248 	mov.w	r2, r8, lsl #5
  6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  6c:	2200      	movs	r2, #0
  6e:	461c      	mov	r4, r3
  70:	4615      	mov	r5, r2
  72:	f04f 0200 	mov.w	r2, #0
  76:	f04f 0300 	mov.w	r3, #0
  7a:	016b      	lsls	r3, r5, #5
  7c:	ea43 63d4 	orr.w	r3, r3, r4, lsr #27
  80:	0162      	lsls	r2, r4, #5
  82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  84:	009b      	lsls	r3, r3, #2
  86:	3307      	adds	r3, #7
  88:	08db      	lsrs	r3, r3, #3
  8a:	00db      	lsls	r3, r3, #3
  8c:	ebad 0d03 	sub.w	sp, sp, r3
  90:	466b      	mov	r3, sp
  92:	3303      	adds	r3, #3
  94:	089b      	lsrs	r3, r3, #2
  96:	009b      	lsls	r3, r3, #2
  98:	61fb      	str	r3, [r7, #28]

	int entryCount = maxEntries;
  9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  9c:	62fb      	str	r3, [r7, #44]	; 0x2c

	// "lookup table"ı "no-operation" ile doldurarak başlat
	while ( entryCount-- )
  9e:	e004      	b.n	aa <functionPointerSample+0xaa>
		operations[ entryCount ] = nop;
  a0:	69fb      	ldr	r3, [r7, #28]
  a2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  a4:	4919      	ldr	r1, [pc, #100]	; (10c <functionPointerSample+0x10c>)
  a6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	while ( entryCount-- )
  aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  ac:	1e5a      	subs	r2, r3, #1
  ae:	62fa      	str	r2, [r7, #44]	; 0x2c
  b0:	2b00      	cmp	r3, #0
  b2:	d1f5      	bne.n	a0 <functionPointerSample+0xa0>

	// başlatılan tabloyu hazırla
	operations[ '+' ] = add;
  b4:	69fb      	ldr	r3, [r7, #28]
  b6:	4a16      	ldr	r2, [pc, #88]	; (110 <functionPointerSample+0x110>)
  b8:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	operations[ '-' ] = sub;
  bc:	69fb      	ldr	r3, [r7, #28]
  be:	4a15      	ldr	r2, [pc, #84]	; (114 <functionPointerSample+0x114>)
  c0:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	operations[ '*' ] = mul;
  c4:	69fb      	ldr	r3, [r7, #28]
  c6:	4a14      	ldr	r2, [pc, #80]	; (118 <functionPointerSample+0x118>)
  c8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	operations[ '/' ] = idv;
  cc:	69fb      	ldr	r3, [r7, #28]
  ce:	4a13      	ldr	r2, [pc, #76]	; (11c <functionPointerSample+0x11c>)
  d0:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc

	// verilen operatörün operasyonunu tablodan bul çağır ve işlem sonucunu al
	int result = operations[ operator ]( operandA, operandB );
  d4:	7dfb      	ldrb	r3, [r7, #23]
  d6:	461a      	mov	r2, r3
  d8:	69fb      	ldr	r3, [r7, #28]
  da:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  de:	693a      	ldr	r2, [r7, #16]
  e0:	68f9      	ldr	r1, [r7, #12]
  e2:	4610      	mov	r0, r2
  e4:	4798      	blx	r3
  e6:	61b8      	str	r0, [r7, #24]

	// herhangi bir karakterle "no-operation"ı dene.
	result = operations[ '?' ]( operandA, operandB );
  e8:	69fb      	ldr	r3, [r7, #28]
  ea:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  ee:	693a      	ldr	r2, [r7, #16]
  f0:	68f9      	ldr	r1, [r7, #12]
  f2:	4610      	mov	r0, r2
  f4:	4798      	blx	r3
  f6:	61b8      	str	r0, [r7, #24]

	return EXIT_SUCCESS;
  f8:	2300      	movs	r3, #0
  fa:	46b5      	mov	sp, r6

}//functionPointerSample
  fc:	4618      	mov	r0, r3
  fe:	3734      	adds	r7, #52	; 0x34
 100:	46bd      	mov	sp, r7
 102:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 106:	bf00      	nop
 108:	000001a0 	.word	0x000001a0
	...

Disassembly of section .text.functionPointers:

00000000 <functionPointers>:

//-----------------------------------------------------------------------------

void functionPointers( void ) {
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0

   int (*fp)( int, int ) = NULL;
   6:	2300      	movs	r3, #0
   8:	60fb      	str	r3, [r7, #12]
   void *pv = NULL;
   a:	2300      	movs	r3, #0
   c:	60bb      	str	r3, [r7, #8]

   int result = 0;
   e:	2300      	movs	r3, #0
  10:	607b      	str	r3, [r7, #4]

   // both the same
   fp = add;
  12:	4b18      	ldr	r3, [pc, #96]	; (74 <functionPointers+0x74>)
  14:	60fb      	str	r3, [r7, #12]
   fp = &add;
  16:	4b17      	ldr	r3, [pc, #92]	; (74 <functionPointers+0x74>)
  18:	60fb      	str	r3, [r7, #12]

   // old style call
   result = (*fp)( 5,3 );
  1a:	68fb      	ldr	r3, [r7, #12]
  1c:	2103      	movs	r1, #3
  1e:	2005      	movs	r0, #5
  20:	4798      	blx	r3
  22:	6078      	str	r0, [r7, #4]

   // C99 style call
   result = fp( 5, 3 );
  24:	68fb      	ldr	r3, [r7, #12]
  26:	2103      	movs	r1, #3
  28:	2005      	movs	r0, #5
  2a:	4798      	blx	r3
  2c:	6078      	str	r0, [r7, #4]

   pv = add;
  2e:	4b11      	ldr	r3, [pc, #68]	; (74 <functionPointers+0x74>)
  30:	60bb      	str	r3, [r7, #8]

   // function address assignment with and without casting
   fp = (int(*)(int,int)) pv;
  32:	68bb      	ldr	r3, [r7, #8]
  34:	60fb      	str	r3, [r7, #12]
   fp = pv;
  36:	68bb      	ldr	r3, [r7, #8]
  38:	60fb      	str	r3, [r7, #12]

   result = fp( 5, 3 );
  3a:	68fb      	ldr	r3, [r7, #12]
  3c:	2103      	movs	r1, #3
  3e:	2005      	movs	r0, #5
  40:	4798      	blx	r3
  42:	6078      	str	r0, [r7, #4]

   // cast to function poimter than call :  int(*)(int,int)
   result = ( (int(*)(int,int))pv )( 5, 3 );
  44:	68bb      	ldr	r3, [r7, #8]
  46:	2103      	movs	r1, #3
  48:	2005      	movs	r0, #5
  4a:	4798      	blx	r3
  4c:	6078      	str	r0, [r7, #4]

   pv = sub;
  4e:	4b0a      	ldr	r3, [pc, #40]	; (78 <functionPointers+0x78>)
  50:	60bb      	str	r3, [r7, #8]
   result = ( (int(*)(int,int))pv )( 5, 3 );
  52:	68bb      	ldr	r3, [r7, #8]
  54:	2103      	movs	r1, #3
  56:	2005      	movs	r0, #5
  58:	4798      	blx	r3
  5a:	6078      	str	r0, [r7, #4]

   pv = mul;
  5c:	4b07      	ldr	r3, [pc, #28]	; (7c <functionPointers+0x7c>)
  5e:	60bb      	str	r3, [r7, #8]
   result = ( (int(*)(int,int))pv )( 5, 3 );
  60:	68bb      	ldr	r3, [r7, #8]
  62:	2103      	movs	r1, #3
  64:	2005      	movs	r0, #5
  66:	4798      	blx	r3
  68:	6078      	str	r0, [r7, #4]

}//functionPointers
  6a:	bf00      	nop
  6c:	3710      	adds	r7, #16
  6e:	46bd      	mov	sp, r7
  70:	bd80      	pop	{r7, pc}
  72:	bf00      	nop
	...

Disassembly of section .text.enums:

00000000 <enums>:
	yellow,
	black,
	white
} AllColor;

void enums( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

	enum PrintColor { cyan, magenta, yellow, black };

	enum PrintColor colorW;
	enum PrintColor colorX;
	enum PrintColor colorY = black;
   6:	2303      	movs	r3, #3
   8:	73fb      	strb	r3, [r7, #15]
	enum PrintColor colorZ = magenta;
   a:	2301      	movs	r3, #1
   c:	73bb      	strb	r3, [r7, #14]

    enum TAllColor allA;
    enum TAllColor allB = black;
   e:	2303      	movs	r3, #3
  10:	737b      	strb	r3, [r7, #13]
	AllColor       allC;
	AllColor       allD = white;
  12:	230a      	movs	r3, #10
  14:	733b      	strb	r3, [r7, #12]

	size_t size = 0;
  16:	2300      	movs	r3, #0
  18:	60bb      	str	r3, [r7, #8]
	size = sizeof( colorA );
  1a:	2301      	movs	r3, #1
  1c:	60bb      	str	r3, [r7, #8]

	colorA = 0;
  1e:	2300      	movs	r3, #0
  20:	71fb      	strb	r3, [r7, #7]
	colorA = 1;
  22:	2301      	movs	r3, #1
  24:	71fb      	strb	r3, [r7, #7]
	colorA = 2;
  26:	2302      	movs	r3, #2
  28:	71fb      	strb	r3, [r7, #7]

	colorA = red;
  2a:	2300      	movs	r3, #0
  2c:	71fb      	strb	r3, [r7, #7]
	colorA = green;
  2e:	2301      	movs	r3, #1
  30:	71fb      	strb	r3, [r7, #7]
	colorA = blue;
  32:	2302      	movs	r3, #2
  34:	71fb      	strb	r3, [r7, #7]

	colorA = colorA - 1;
  36:	79fb      	ldrb	r3, [r7, #7]
  38:	3b01      	subs	r3, #1
  3a:	71fb      	strb	r3, [r7, #7]
	colorA = colorA - 1;
  3c:	79fb      	ldrb	r3, [r7, #7]
  3e:	3b01      	subs	r3, #1
  40:	71fb      	strb	r3, [r7, #7]
	colorA = colorA - 1;
  42:	79fb      	ldrb	r3, [r7, #7]
  44:	3b01      	subs	r3, #1
  46:	71fb      	strb	r3, [r7, #7]

	colorA = INT_MIN;
  48:	2300      	movs	r3, #0
  4a:	71fb      	strb	r3, [r7, #7]
	colorA = INT_MAX;
  4c:	23ff      	movs	r3, #255	; 0xff
  4e:	71fb      	strb	r3, [r7, #7]

    colorA = colorZ;
  50:	7bbb      	ldrb	r3, [r7, #14]
  52:	71fb      	strb	r3, [r7, #7]

}//enums
  54:	bf00      	nop
  56:	3714      	adds	r7, #20
  58:	46bd      	mov	sp, r7
  5a:	f85d 7b04 	ldr.w	r7, [sp], #4
  5e:	4770      	bx	lr

Disassembly of section .text.arrays_variableSize:

00000000 <arrays_variableSize>:

//------------------------------------------------------------------------------

void arrays_variableSize( int length ) {
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b087      	sub	sp, #28
   6:	af00      	add	r7, sp, #0
   8:	6078      	str	r0, [r7, #4]
   a:	466b      	mov	r3, sp
   c:	461e      	mov	r6, r3

	//int valuesA[ length ] = {}; // error : variable-sized object may not be initialized
	int valuesA[ length ];
   e:	6879      	ldr	r1, [r7, #4]
  10:	1e4b      	subs	r3, r1, #1
  12:	613b      	str	r3, [r7, #16]
  14:	460a      	mov	r2, r1
  16:	2300      	movs	r3, #0
  18:	4690      	mov	r8, r2
  1a:	4699      	mov	r9, r3
  1c:	f04f 0200 	mov.w	r2, #0
  20:	f04f 0300 	mov.w	r3, #0
  24:	ea4f 1349 	mov.w	r3, r9, lsl #5
  28:	ea43 63d8 	orr.w	r3, r3, r8, lsr #27
  2c:	ea4f 1248 	mov.w	r2, r8, lsl #5
  30:	460a      	mov	r2, r1
  32:	2300      	movs	r3, #0
  34:	4614      	mov	r4, r2
  36:	461d      	mov	r5, r3
  38:	f04f 0200 	mov.w	r2, #0
  3c:	f04f 0300 	mov.w	r3, #0
  40:	016b      	lsls	r3, r5, #5
  42:	ea43 63d4 	orr.w	r3, r3, r4, lsr #27
  46:	0162      	lsls	r2, r4, #5
  48:	460b      	mov	r3, r1
  4a:	009b      	lsls	r3, r3, #2
  4c:	3307      	adds	r3, #7
  4e:	08db      	lsrs	r3, r3, #3
  50:	00db      	lsls	r3, r3, #3
  52:	ebad 0d03 	sub.w	sp, sp, r3
  56:	466b      	mov	r3, sp
  58:	3303      	adds	r3, #3
  5a:	089b      	lsrs	r3, r3, #2
  5c:	009b      	lsls	r3, r3, #2
  5e:	60fb      	str	r3, [r7, #12]

	int* valuesB = malloc( length * sizeof(int) );
  60:	687b      	ldr	r3, [r7, #4]
  62:	009b      	lsls	r3, r3, #2
  64:	4618      	mov	r0, r3
  66:	f7ff fffe 	bl	0 <malloc>
  6a:	4603      	mov	r3, r0
  6c:	60bb      	str	r3, [r7, #8]

	int loop = length;
  6e:	687b      	ldr	r3, [r7, #4]
  70:	617b      	str	r3, [r7, #20]
	while( loop-- )
  72:	e00d      	b.n	90 <arrays_variableSize+0x90>
	   valuesB[ loop ] = valuesA[ loop ] = 0;
  74:	68fb      	ldr	r3, [r7, #12]
  76:	697a      	ldr	r2, [r7, #20]
  78:	2100      	movs	r1, #0
  7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  7e:	697b      	ldr	r3, [r7, #20]
  80:	009b      	lsls	r3, r3, #2
  82:	68ba      	ldr	r2, [r7, #8]
  84:	4413      	add	r3, r2
  86:	68fa      	ldr	r2, [r7, #12]
  88:	6979      	ldr	r1, [r7, #20]
  8a:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  8e:	601a      	str	r2, [r3, #0]
	while( loop-- )
  90:	697b      	ldr	r3, [r7, #20]
  92:	1e5a      	subs	r2, r3, #1
  94:	617a      	str	r2, [r7, #20]
  96:	2b00      	cmp	r3, #0
  98:	d1ec      	bne.n	74 <arrays_variableSize+0x74>
  9a:	46b5      	mov	sp, r6

}//arrays_variableSize
  9c:	bf00      	nop
  9e:	371c      	adds	r7, #28
  a0:	46bd      	mov	sp, r7
  a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.arrays_multiDimensional:

00000000 <arrays_multiDimensional>:
//-----------------------------------------------------------------------------

// defines special type for ( 3 x 4 ) of integers.
typedef int Special3D[ 3 ][ 4 ];

void arrays_multiDimensional() {
   0:	b5b0      	push	{r4, r5, r7, lr}
   2:	b0bc      	sub	sp, #240	; 0xf0
   4:	af00      	add	r7, sp, #0

    char valuesA[ 5 ][ 2 ] = { {0,1}, {2,3}, {4,5}, {6,7}, {8,9} };
   6:	4a98      	ldr	r2, [pc, #608]	; (268 <arrays_multiDimensional+0x268>)
   8:	f107 0390 	add.w	r3, r7, #144	; 0x90
   c:	ca07      	ldmia	r2, {r0, r1, r2}
   e:	c303      	stmia	r3!, {r0, r1}
  10:	801a      	strh	r2, [r3, #0]

	int valuesB[   ][ 3 ] = { {1,3,5} , {2,4,6} };
  12:	4b96      	ldr	r3, [pc, #600]	; (26c <arrays_multiDimensional+0x26c>)
  14:	f107 0478 	add.w	r4, r7, #120	; 0x78
  18:	461d      	mov	r5, r3
  1a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  1c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1e:	e895 0003 	ldmia.w	r5, {r0, r1}
  22:	e884 0003 	stmia.w	r4, {r0, r1}
	int valuesC[ 2 ][ 3 ] = { {1,3,5} , {2,4,6} };
  26:	4b91      	ldr	r3, [pc, #580]	; (26c <arrays_multiDimensional+0x26c>)
  28:	f107 0460 	add.w	r4, r7, #96	; 0x60
  2c:	461d      	mov	r5, r3
  2e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  30:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  32:	e895 0003 	ldmia.w	r5, {r0, r1}
  36:	e884 0003 	stmia.w	r4, {r0, r1}
	//int valuesC[ 2 ][  ] = { {1,3,5} , {2,4,6} };// error : array type has incomplete element type

	int valuesE[ 2 ][ 3 ][ 4 ] = {
  3a:	4a8d      	ldr	r2, [pc, #564]	; (270 <arrays_multiDimensional+0x270>)
  3c:	463b      	mov	r3, r7
  3e:	4611      	mov	r1, r2
  40:	2260      	movs	r2, #96	; 0x60
  42:	4618      	mov	r0, r3
  44:	f7ff fffe 	bl	0 <memcpy>
		{
			{211, 212, 213, 214} ,  {221, 222, 223, 224} ,  {231, 232, 233, 234}
		}
	};

	int distanceAsBytes = (int)&valuesA[0][0] - (int)&valuesA[1][0];
  48:	f06f 0301 	mvn.w	r3, #1
  4c:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4

	// see disassembly
	int value = 0;
  50:	2300      	movs	r3, #0
  52:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	value = valuesA[0][0];
  56:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
  5a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	value = valuesA[0][1];
  5e:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
  62:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

	value = valuesA[1][0];
  66:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
  6a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	value = valuesA[1][1];
  6e:	f897 3093 	ldrb.w	r3, [r7, #147]	; 0x93
  72:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

	value = valuesA[2][0];
  76:	f897 3094 	ldrb.w	r3, [r7, #148]	; 0x94
  7a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	value = valuesA[3][1];
  7e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
  82:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

	const int lengthI = 4;
  86:	2304      	movs	r3, #4
  88:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	const int lengthJ = 3;
  8c:	2303      	movs	r3, #3
  8e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	const int lengthK = 2;
  92:	2302      	movs	r3, #2
  94:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

	size_t size = sizeof valuesE;
  98:	2360      	movs	r3, #96	; 0x60
  9a:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

	for ( int k = 0; k < lengthK; k++ ) {
  9e:	2300      	movs	r3, #0
  a0:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
  a4:	e059      	b.n	15a <arrays_multiDimensional+0x15a>

		for ( int j = 0; j < lengthJ; j++ ) {
  a6:	2300      	movs	r3, #0
  a8:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
  ac:	e04a      	b.n	144 <arrays_multiDimensional+0x144>

			for ( int i = 0; i < lengthI; i++ ) {
  ae:	2300      	movs	r3, #0
  b0:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  b4:	e03b      	b.n	12e <arrays_multiDimensional+0x12e>

				int hundreds = k + 1;
  b6:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
  ba:	3301      	adds	r3, #1
  bc:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
				int tens     = j + 1;
  c0:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
  c4:	3301      	adds	r3, #1
  c6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
				int ones     = i;
  ca:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
  ce:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

				valuesE[ k ][ j ][ i ] = 100*hundreds + 10*tens + ones;
  d2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
  d6:	2264      	movs	r2, #100	; 0x64
  d8:	fb02 f103 	mul.w	r1, r2, r3
  dc:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
  e0:	4613      	mov	r3, r2
  e2:	009b      	lsls	r3, r3, #2
  e4:	4413      	add	r3, r2
  e6:	005b      	lsls	r3, r3, #1
  e8:	18ca      	adds	r2, r1, r3
  ea:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  ee:	18d1      	adds	r1, r2, r3
  f0:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
  f4:	4613      	mov	r3, r2
  f6:	005b      	lsls	r3, r3, #1
  f8:	4413      	add	r3, r2
  fa:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
  fe:	4413      	add	r3, r2
 100:	009a      	lsls	r2, r3, #2
 102:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 106:	4413      	add	r3, r2
 108:	009b      	lsls	r3, r3, #2
 10a:	33f0      	adds	r3, #240	; 0xf0
 10c:	443b      	add	r3, r7
 10e:	f843 1cf0 	str.w	r1, [r3, #-240]
				printf( "%d%d%d ", hundreds, tens, ones );
 112:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 116:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 11a:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 11e:	4855      	ldr	r0, [pc, #340]	; (274 <arrays_multiDimensional+0x274>)
 120:	f7ff fffe 	bl	0 <printf>
			for ( int i = 0; i < lengthI; i++ ) {
 124:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 128:	3301      	adds	r3, #1
 12a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 12e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 132:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 136:	429a      	cmp	r2, r3
 138:	dbbd      	blt.n	b6 <arrays_multiDimensional+0xb6>
		for ( int j = 0; j < lengthJ; j++ ) {
 13a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 13e:	3301      	adds	r3, #1
 140:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 144:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 148:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 14c:	429a      	cmp	r2, r3
 14e:	dbae      	blt.n	ae <arrays_multiDimensional+0xae>
	for ( int k = 0; k < lengthK; k++ ) {
 150:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 154:	3301      	adds	r3, #1
 156:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 15a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 15e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 162:	429a      	cmp	r2, r3
 164:	db9f      	blt.n	a6 <arrays_multiDimensional+0xa6>

		}//forj

	}//fork

	Special3D* p3D = NULL;
 166:	2300      	movs	r3, #0
 168:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	size_t allocateBytes = sizeof(Special3D) * lengthK;
 16c:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 170:	4613      	mov	r3, r2
 172:	005b      	lsls	r3, r3, #1
 174:	4413      	add	r3, r2
 176:	011b      	lsls	r3, r3, #4
 178:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

	void* buffer = malloc( allocateBytes );
 17c:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
 180:	f7ff fffe 	bl	0 <malloc>
 184:	4603      	mov	r3, r0
 186:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	if ( buffer == NULL ) {
 18a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 18e:	2b00      	cmp	r3, #0
 190:	d102      	bne.n	198 <arrays_multiDimensional+0x198>
		// not enough memory, terminate the program with failure
	    exit( EXIT_FAILURE );
 192:	2001      	movs	r0, #1
 194:	f7ff fffe 	bl	0 <exit>
	}

	// Casting void* to int(*)[3][4]. Same effect as casting to Special3D*
	p3D = (int(*)[3][4]) buffer;
 198:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 19c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

	for ( int k = 0; k < lengthK; k++ ) {
 1a0:	2300      	movs	r3, #0
 1a2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 1a6:	e051      	b.n	24c <arrays_multiDimensional+0x24c>

		for ( int j = 0; j < lengthJ; j++ ) {
 1a8:	2300      	movs	r3, #0
 1aa:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 1ae:	e042      	b.n	236 <arrays_multiDimensional+0x236>

			for ( int i = 0; i < lengthI; i++ ) {
 1b0:	2300      	movs	r3, #0
 1b2:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 1b6:	e033      	b.n	220 <arrays_multiDimensional+0x220>

				int hundreds = k + 1;
 1b8:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 1bc:	3301      	adds	r3, #1
 1be:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
				int tens     = j + 1;
 1c2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 1c6:	3301      	adds	r3, #1
 1c8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
				int ones     = i;
 1cc:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 1d0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

				p3D[ k ][ j ][ i ] = 100*hundreds + 10*tens + ones;
 1d4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 1d8:	2264      	movs	r2, #100	; 0x64
 1da:	fb02 f103 	mul.w	r1, r2, r3
 1de:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 1e2:	4613      	mov	r3, r2
 1e4:	009b      	lsls	r3, r3, #2
 1e6:	4413      	add	r3, r2
 1e8:	005b      	lsls	r3, r3, #1
 1ea:	4419      	add	r1, r3
 1ec:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 1f0:	4613      	mov	r3, r2
 1f2:	005b      	lsls	r3, r3, #1
 1f4:	4413      	add	r3, r2
 1f6:	011b      	lsls	r3, r3, #4
 1f8:	461a      	mov	r2, r3
 1fa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 1fe:	4413      	add	r3, r2
 200:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 204:	4411      	add	r1, r2
 206:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 20a:	0090      	lsls	r0, r2, #2
 20c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 210:	4402      	add	r2, r0
 212:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			for ( int i = 0; i < lengthI; i++ ) {
 216:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 21a:	3301      	adds	r3, #1
 21c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 220:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 224:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 228:	429a      	cmp	r2, r3
 22a:	dbc5      	blt.n	1b8 <arrays_multiDimensional+0x1b8>
		for ( int j = 0; j < lengthJ; j++ ) {
 22c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 230:	3301      	adds	r3, #1
 232:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 236:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 23a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 23e:	429a      	cmp	r2, r3
 240:	dbb6      	blt.n	1b0 <arrays_multiDimensional+0x1b0>
	for ( int k = 0; k < lengthK; k++ ) {
 242:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 246:	3301      	adds	r3, #1
 248:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 24c:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 250:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 254:	429a      	cmp	r2, r3
 256:	dba7      	blt.n	1a8 <arrays_multiDimensional+0x1a8>
		}//forj

	}//fork

    // free the previously allocated memory
	free( p3D );
 258:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 25c:	f7ff fffe 	bl	0 <free>

}//arrays_multiDimensional
 260:	bf00      	nop
 262:	37f0      	adds	r7, #240	; 0xf0
 264:	46bd      	mov	sp, r7
 266:	bdb0      	pop	{r4, r5, r7, pc}
 268:	000001e0 	.word	0x000001e0
 26c:	000001ec 	.word	0x000001ec
 270:	00000204 	.word	0x00000204
 274:	000001d8 	.word	0x000001d8

Disassembly of section .text.arrays_multiDimensionalJagged:

00000000 <arrays_multiDimensionalJagged>:

//-----------------------------------------------------------------------------

void arrays_multiDimensionalJagged() {
   0:	b580      	push	{r7, lr}
   2:	b08a      	sub	sp, #40	; 0x28
   4:	af00      	add	r7, sp, #0

	// jagged array sample
	// refer https://en.wikipedia.org/wiki/Jagged_array
	int** values = NULL;
   6:	2300      	movs	r3, #0
   8:	61fb      	str	r3, [r7, #28]

    // TODO : implement check for return value of all "malloc()"s for an allocation error
    int arrayCount = 3;
   a:	2303      	movs	r3, #3
   c:	61bb      	str	r3, [r7, #24]
    values = (int**) malloc( arrayCount * sizeof(int*) );
   e:	69bb      	ldr	r3, [r7, #24]
  10:	009b      	lsls	r3, r3, #2
  12:	4618      	mov	r0, r3
  14:	f7ff fffe 	bl	0 <malloc>
  18:	4603      	mov	r3, r0
  1a:	61fb      	str	r3, [r7, #28]

    const int leastElementCount = 2;
  1c:	2302      	movs	r3, #2
  1e:	617b      	str	r3, [r7, #20]
	for ( int i = 0; i < arrayCount; i++ ) {
  20:	2300      	movs	r3, #0
  22:	627b      	str	r3, [r7, #36]	; 0x24
  24:	e02e      	b.n	84 <arrays_multiDimensionalJagged+0x84>

		int  length = i + leastElementCount;
  26:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  28:	697b      	ldr	r3, [r7, #20]
  2a:	4413      	add	r3, r2
  2c:	60bb      	str	r3, [r7, #8]
		int* buffer = malloc( length * sizeof(int) );
  2e:	68bb      	ldr	r3, [r7, #8]
  30:	009b      	lsls	r3, r3, #2
  32:	4618      	mov	r0, r3
  34:	f7ff fffe 	bl	0 <malloc>
  38:	4603      	mov	r3, r0
  3a:	607b      	str	r3, [r7, #4]

		values[ i ] = buffer;
  3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  3e:	009b      	lsls	r3, r3, #2
  40:	69fa      	ldr	r2, [r7, #28]
  42:	4413      	add	r3, r2
  44:	687a      	ldr	r2, [r7, #4]
  46:	601a      	str	r2, [r3, #0]

		// fill the buffer
		for ( int j = 0; j < length; j++ ) {
  48:	2300      	movs	r3, #0
  4a:	623b      	str	r3, [r7, #32]
  4c:	e013      	b.n	76 <arrays_multiDimensionalJagged+0x76>

			values[ i ][ j ] = i*10 + j;
  4e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  50:	4613      	mov	r3, r2
  52:	009b      	lsls	r3, r3, #2
  54:	4413      	add	r3, r2
  56:	005b      	lsls	r3, r3, #1
  58:	4619      	mov	r1, r3
  5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  5c:	009b      	lsls	r3, r3, #2
  5e:	69fa      	ldr	r2, [r7, #28]
  60:	4413      	add	r3, r2
  62:	681a      	ldr	r2, [r3, #0]
  64:	6a3b      	ldr	r3, [r7, #32]
  66:	009b      	lsls	r3, r3, #2
  68:	4413      	add	r3, r2
  6a:	6a3a      	ldr	r2, [r7, #32]
  6c:	440a      	add	r2, r1
  6e:	601a      	str	r2, [r3, #0]
		for ( int j = 0; j < length; j++ ) {
  70:	6a3b      	ldr	r3, [r7, #32]
  72:	3301      	adds	r3, #1
  74:	623b      	str	r3, [r7, #32]
  76:	6a3a      	ldr	r2, [r7, #32]
  78:	68bb      	ldr	r3, [r7, #8]
  7a:	429a      	cmp	r2, r3
  7c:	dbe7      	blt.n	4e <arrays_multiDimensionalJagged+0x4e>
	for ( int i = 0; i < arrayCount; i++ ) {
  7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  80:	3301      	adds	r3, #1
  82:	627b      	str	r3, [r7, #36]	; 0x24
  84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  86:	69bb      	ldr	r3, [r7, #24]
  88:	429a      	cmp	r2, r3
  8a:	dbcc      	blt.n	26 <arrays_multiDimensionalJagged+0x26>
		}//forj

	}//fori


	int distanceAsBytes = (int)&values[0][0] - (int)&values[1][0];
  8c:	69fb      	ldr	r3, [r7, #28]
  8e:	681b      	ldr	r3, [r3, #0]
  90:	461a      	mov	r2, r3
  92:	69fb      	ldr	r3, [r7, #28]
  94:	3304      	adds	r3, #4
  96:	681b      	ldr	r3, [r3, #0]
  98:	1ad3      	subs	r3, r2, r3
  9a:	613b      	str	r3, [r7, #16]

	// see disassembly
	int value = 0;
  9c:	2300      	movs	r3, #0
  9e:	60fb      	str	r3, [r7, #12]
	value = values[0][0];
  a0:	69fb      	ldr	r3, [r7, #28]
  a2:	681b      	ldr	r3, [r3, #0]
  a4:	681b      	ldr	r3, [r3, #0]
  a6:	60fb      	str	r3, [r7, #12]
	value = values[0][1];
  a8:	69fb      	ldr	r3, [r7, #28]
  aa:	681b      	ldr	r3, [r3, #0]
  ac:	685b      	ldr	r3, [r3, #4]
  ae:	60fb      	str	r3, [r7, #12]
	value = values[0][2];
  b0:	69fb      	ldr	r3, [r7, #28]
  b2:	681b      	ldr	r3, [r3, #0]
  b4:	689b      	ldr	r3, [r3, #8]
  b6:	60fb      	str	r3, [r7, #12]

	value = values[1][0];
  b8:	69fb      	ldr	r3, [r7, #28]
  ba:	3304      	adds	r3, #4
  bc:	681b      	ldr	r3, [r3, #0]
  be:	681b      	ldr	r3, [r3, #0]
  c0:	60fb      	str	r3, [r7, #12]
	value = values[1][1];
  c2:	69fb      	ldr	r3, [r7, #28]
  c4:	3304      	adds	r3, #4
  c6:	681b      	ldr	r3, [r3, #0]
  c8:	685b      	ldr	r3, [r3, #4]
  ca:	60fb      	str	r3, [r7, #12]
	value = values[1][2];
  cc:	69fb      	ldr	r3, [r7, #28]
  ce:	3304      	adds	r3, #4
  d0:	681b      	ldr	r3, [r3, #0]
  d2:	689b      	ldr	r3, [r3, #8]
  d4:	60fb      	str	r3, [r7, #12]

	value = values[2][0];
  d6:	69fb      	ldr	r3, [r7, #28]
  d8:	3308      	adds	r3, #8
  da:	681b      	ldr	r3, [r3, #0]
  dc:	681b      	ldr	r3, [r3, #0]
  de:	60fb      	str	r3, [r7, #12]
	value = values[2][1];
  e0:	69fb      	ldr	r3, [r7, #28]
  e2:	3308      	adds	r3, #8
  e4:	681b      	ldr	r3, [r3, #0]
  e6:	685b      	ldr	r3, [r3, #4]
  e8:	60fb      	str	r3, [r7, #12]
	value = values[2][2];
  ea:	69fb      	ldr	r3, [r7, #28]
  ec:	3308      	adds	r3, #8
  ee:	681b      	ldr	r3, [r3, #0]
  f0:	689b      	ldr	r3, [r3, #8]
  f2:	60fb      	str	r3, [r7, #12]

	// TODO : we need lots of "free()"s here...

}//arrays_multiDimensionalJagged
  f4:	bf00      	nop
  f6:	3728      	adds	r7, #40	; 0x28
  f8:	46bd      	mov	sp, r7
  fa:	bd80      	pop	{r7, pc}

Disassembly of section .text.arrays_multiDimensionalJaggedvsFlat:

00000000 <arrays_multiDimensionalJaggedvsFlat>:

//-----------------------------------------------------------------------------

void arrays_multiDimensionalJaggedvsFlat() {
   0:	b5b0      	push	{r4, r5, r7, lr}
   2:	b092      	sub	sp, #72	; 0x48
   4:	af00      	add	r7, sp, #0

	// jagged array sample
	// refer https://en.wikipedia.org/wiki/Jagged_array

	int** jagged = NULL;
   6:	2300      	movs	r3, #0
   8:	63fb      	str	r3, [r7, #60]	; 0x3c
    int   flat[3][3] = { {0,1,2}, {10,11,12}, {20,21,22} };
   a:	4b44      	ldr	r3, [pc, #272]	; (11c <arrays_multiDimensionalJaggedvsFlat+0x11c>)
   c:	463c      	mov	r4, r7
   e:	461d      	mov	r5, r3
  10:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  12:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  16:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  18:	682b      	ldr	r3, [r5, #0]
  1a:	6023      	str	r3, [r4, #0]

    // TODO : implement check for return value of all "malloc"s for an allocation error
    int arrayCount = 3;
  1c:	2303      	movs	r3, #3
  1e:	63bb      	str	r3, [r7, #56]	; 0x38
    jagged = (int**) malloc( 2 * sizeof(int*) );
  20:	2008      	movs	r0, #8
  22:	f7ff fffe 	bl	0 <malloc>
  26:	4603      	mov	r3, r0
  28:	63fb      	str	r3, [r7, #60]	; 0x3c

    const int leastElementCount = 2;
  2a:	2302      	movs	r3, #2
  2c:	637b      	str	r3, [r7, #52]	; 0x34
	for ( int i = 0; i < arrayCount; i++ ) {
  2e:	2300      	movs	r3, #0
  30:	647b      	str	r3, [r7, #68]	; 0x44
  32:	e02e      	b.n	92 <arrays_multiDimensionalJaggedvsFlat+0x92>

		int  length = i + leastElementCount;
  34:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  38:	4413      	add	r3, r2
  3a:	62bb      	str	r3, [r7, #40]	; 0x28
		int* buffer = malloc( length * sizeof(int) );
  3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  3e:	009b      	lsls	r3, r3, #2
  40:	4618      	mov	r0, r3
  42:	f7ff fffe 	bl	0 <malloc>
  46:	4603      	mov	r3, r0
  48:	627b      	str	r3, [r7, #36]	; 0x24

		jagged[ i ] = buffer;
  4a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  4c:	009b      	lsls	r3, r3, #2
  4e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  50:	4413      	add	r3, r2
  52:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  54:	601a      	str	r2, [r3, #0]

		// fill the buffer
		for ( int j = 0; j < length; j++ ) {
  56:	2300      	movs	r3, #0
  58:	643b      	str	r3, [r7, #64]	; 0x40
  5a:	e013      	b.n	84 <arrays_multiDimensionalJaggedvsFlat+0x84>

			jagged[ i ][ j ] = i*10 + j;
  5c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  5e:	4613      	mov	r3, r2
  60:	009b      	lsls	r3, r3, #2
  62:	4413      	add	r3, r2
  64:	005b      	lsls	r3, r3, #1
  66:	4619      	mov	r1, r3
  68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  6a:	009b      	lsls	r3, r3, #2
  6c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  6e:	4413      	add	r3, r2
  70:	681a      	ldr	r2, [r3, #0]
  72:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  74:	009b      	lsls	r3, r3, #2
  76:	4413      	add	r3, r2
  78:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  7a:	440a      	add	r2, r1
  7c:	601a      	str	r2, [r3, #0]
		for ( int j = 0; j < length; j++ ) {
  7e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  80:	3301      	adds	r3, #1
  82:	643b      	str	r3, [r7, #64]	; 0x40
  84:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  86:	6abb      	ldr	r3, [r7, #40]	; 0x28
  88:	429a      	cmp	r2, r3
  8a:	dbe7      	blt.n	5c <arrays_multiDimensionalJaggedvsFlat+0x5c>
	for ( int i = 0; i < arrayCount; i++ ) {
  8c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  8e:	3301      	adds	r3, #1
  90:	647b      	str	r3, [r7, #68]	; 0x44
  92:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  94:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  96:	429a      	cmp	r2, r3
  98:	dbcc      	blt.n	34 <arrays_multiDimensionalJaggedvsFlat+0x34>

		}//forj

	}//fori

	int distanceAsBytes = 0;
  9a:	2300      	movs	r3, #0
  9c:	633b      	str	r3, [r7, #48]	; 0x30
	distanceAsBytes = (int)&jagged[0][0] - (int)&jagged[1][0];
  9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  a0:	681b      	ldr	r3, [r3, #0]
  a2:	461a      	mov	r2, r3
  a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  a6:	3304      	adds	r3, #4
  a8:	681b      	ldr	r3, [r3, #0]
  aa:	1ad3      	subs	r3, r2, r3
  ac:	633b      	str	r3, [r7, #48]	; 0x30
	distanceAsBytes = (int)&flat[0][0]   - (int)&flat[1][0];
  ae:	f06f 030b 	mvn.w	r3, #11
  b2:	633b      	str	r3, [r7, #48]	; 0x30

	// see disassembly
	int value = 0;
  b4:	2300      	movs	r3, #0
  b6:	62fb      	str	r3, [r7, #44]	; 0x2c

	value = flat[0][0];
  b8:	683b      	ldr	r3, [r7, #0]
  ba:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = jagged[0][0];
  bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  be:	681b      	ldr	r3, [r3, #0]
  c0:	681b      	ldr	r3, [r3, #0]
  c2:	62fb      	str	r3, [r7, #44]	; 0x2c

	value = jagged[0][0];
  c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  c6:	681b      	ldr	r3, [r3, #0]
  c8:	681b      	ldr	r3, [r3, #0]
  ca:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = jagged[0][1];
  cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  ce:	681b      	ldr	r3, [r3, #0]
  d0:	685b      	ldr	r3, [r3, #4]
  d2:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = jagged[0][2];
  d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  d6:	681b      	ldr	r3, [r3, #0]
  d8:	689b      	ldr	r3, [r3, #8]
  da:	62fb      	str	r3, [r7, #44]	; 0x2c

	value = jagged[1][0];
  dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  de:	3304      	adds	r3, #4
  e0:	681b      	ldr	r3, [r3, #0]
  e2:	681b      	ldr	r3, [r3, #0]
  e4:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = jagged[1][1];
  e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  e8:	3304      	adds	r3, #4
  ea:	681b      	ldr	r3, [r3, #0]
  ec:	685b      	ldr	r3, [r3, #4]
  ee:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = jagged[1][2];
  f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  f2:	3304      	adds	r3, #4
  f4:	681b      	ldr	r3, [r3, #0]
  f6:	689b      	ldr	r3, [r3, #8]
  f8:	62fb      	str	r3, [r7, #44]	; 0x2c

	value = flat[0][0];
  fa:	683b      	ldr	r3, [r7, #0]
  fc:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = flat[0][1];
  fe:	687b      	ldr	r3, [r7, #4]
 100:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = flat[0][2];
 102:	68bb      	ldr	r3, [r7, #8]
 104:	62fb      	str	r3, [r7, #44]	; 0x2c

	value = flat[1][0];
 106:	68fb      	ldr	r3, [r7, #12]
 108:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = flat[1][1];
 10a:	693b      	ldr	r3, [r7, #16]
 10c:	62fb      	str	r3, [r7, #44]	; 0x2c
	value = flat[1][2];
 10e:	697b      	ldr	r3, [r7, #20]
 110:	62fb      	str	r3, [r7, #44]	; 0x2c

	// TODO : we need lots of "free()"s here...

}//arrays_multiDimensionalJagged
 112:	bf00      	nop
 114:	3748      	adds	r7, #72	; 0x48
 116:	46bd      	mov	sp, r7
 118:	bdb0      	pop	{r4, r5, r7, pc}
 11a:	bf00      	nop
 11c:	00000264 	.word	0x00000264

Disassembly of section .text.setBit:

00000000 <setBit>:

typedef unsigned char byte;
typedef unsigned int doubleword;
typedef enum { zero, one } BitValue;

doubleword setBit( doubleword value, byte bitIndex ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]

	doubleword mask = 0;
   c:	2300      	movs	r3, #0
   e:	60fb      	str	r3, [r7, #12]

	mask = (unsigned) 1 << bitIndex;
  10:	78fb      	ldrb	r3, [r7, #3]
  12:	2201      	movs	r2, #1
  14:	fa02 f303 	lsl.w	r3, r2, r3
  18:	60fb      	str	r3, [r7, #12]
    value |= mask;
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	68fb      	ldr	r3, [r7, #12]
  1e:	4313      	orrs	r3, r2
  20:	607b      	str	r3, [r7, #4]

	return value;
  22:	687b      	ldr	r3, [r7, #4]

}//setBit
  24:	4618      	mov	r0, r3
  26:	3714      	adds	r7, #20
  28:	46bd      	mov	sp, r7
  2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  2e:	4770      	bx	lr

Disassembly of section .text.resetBit:

00000000 <resetBit>:

doubleword resetBit( doubleword value, byte bitIndex ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]

	doubleword mask = 0;
   c:	2300      	movs	r3, #0
   e:	60fb      	str	r3, [r7, #12]

	mask = (unsigned) 1 << bitIndex;
  10:	78fb      	ldrb	r3, [r7, #3]
  12:	2201      	movs	r2, #1
  14:	fa02 f303 	lsl.w	r3, r2, r3
  18:	60fb      	str	r3, [r7, #12]
	mask = ~mask;
  1a:	68fb      	ldr	r3, [r7, #12]
  1c:	43db      	mvns	r3, r3
  1e:	60fb      	str	r3, [r7, #12]

	value &= mask;
  20:	687a      	ldr	r2, [r7, #4]
  22:	68fb      	ldr	r3, [r7, #12]
  24:	4013      	ands	r3, r2
  26:	607b      	str	r3, [r7, #4]

	return value;
  28:	687b      	ldr	r3, [r7, #4]

}//resetBit
  2a:	4618      	mov	r0, r3
  2c:	3714      	adds	r7, #20
  2e:	46bd      	mov	sp, r7
  30:	f85d 7b04 	ldr.w	r7, [sp], #4
  34:	4770      	bx	lr

Disassembly of section .text.readBit:

00000000 <readBit>:

BitValue readBit( doubleword value, byte bitIndex ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]

	doubleword mask = 0;
   c:	2300      	movs	r3, #0
   e:	60fb      	str	r3, [r7, #12]

	mask = (unsigned) 1 << bitIndex;
  10:	78fb      	ldrb	r3, [r7, #3]
  12:	2201      	movs	r2, #1
  14:	fa02 f303 	lsl.w	r3, r2, r3
  18:	60fb      	str	r3, [r7, #12]
	mask = ~mask;
  1a:	68fb      	ldr	r3, [r7, #12]
  1c:	43db      	mvns	r3, r3
  1e:	60fb      	str	r3, [r7, #12]

	return (value & mask) ? one : zero;
  20:	687a      	ldr	r2, [r7, #4]
  22:	68fb      	ldr	r3, [r7, #12]
  24:	4013      	ands	r3, r2
  26:	2b00      	cmp	r3, #0
  28:	bf14      	ite	ne
  2a:	2301      	movne	r3, #1
  2c:	2300      	moveq	r3, #0
  2e:	b2db      	uxtb	r3, r3

}//readBit
  30:	4618      	mov	r0, r3
  32:	3714      	adds	r7, #20
  34:	46bd      	mov	sp, r7
  36:	f85d 7b04 	ldr.w	r7, [sp], #4
  3a:	4770      	bx	lr

Disassembly of section .text.xorSwap:

00000000 <xorSwap>:

void xorSwap( doubleword* pValueA, doubleword* pValueB ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

	if ( *pValueA == *pValueA )
		return;
   a:	bf00      	nop
    *pValueB ^= *pValueA;
    *pValueA ^= *pValueB;

    //*pValueA ^= *pValueB ^= *pValueA ^= *pValueB;

}//xorSwap
   c:	370c      	adds	r7, #12
   e:	46bd      	mov	sp, r7
  10:	f85d 7b04 	ldr.w	r7, [sp], #4
  14:	4770      	bx	lr

Disassembly of section .text.xorIsNonDestructiveOperation:

00000000 <xorIsNonDestructiveOperation>:

void xorIsNonDestructiveOperation( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b093      	sub	sp, #76	; 0x4c
   4:	af00      	add	r7, sp, #0

   int value = 0xF0000000;
   6:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   a:	63fb      	str	r3, [r7, #60]	; 0x3c

   value = value ^ value;
   c:	2300      	movs	r3, #0
   e:	63fb      	str	r3, [r7, #60]	; 0x3c

   value ^= value;
  10:	2300      	movs	r3, #0
  12:	63fb      	str	r3, [r7, #60]	; 0x3c
   value ^= value;
  14:	2300      	movs	r3, #0
  16:	63fb      	str	r3, [r7, #60]	; 0x3c

   value = 0xFFFF0000;
  18:	4b27      	ldr	r3, [pc, #156]	; (b8 <xorIsNonDestructiveOperation+0xb8>)
  1a:	63fb      	str	r3, [r7, #60]	; 0x3c

   value ^= value;
  1c:	2300      	movs	r3, #0
  1e:	63fb      	str	r3, [r7, #60]	; 0x3c
   value ^= value;
  20:	2300      	movs	r3, #0
  22:	63fb      	str	r3, [r7, #60]	; 0x3c

   byte cipherKey = '#';
  24:	2323      	movs	r3, #35	; 0x23
  26:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
   char message[] = "look to my coming on the first light of the fifth day";
  2a:	4b24      	ldr	r3, [pc, #144]	; (bc <xorIsNonDestructiveOperation+0xbc>)
  2c:	1d3c      	adds	r4, r7, #4
  2e:	461d      	mov	r5, r3
  30:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  32:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  34:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  36:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  38:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  3a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  3c:	e895 0003 	ldmia.w	r5, {r0, r1}
  40:	6020      	str	r0, [r4, #0]
  42:	3404      	adds	r4, #4
  44:	8021      	strh	r1, [r4, #0]

   // cipher
   for ( int i = 0 ; message[ i ] ; i++ ) {
  46:	2300      	movs	r3, #0
  48:	647b      	str	r3, [r7, #68]	; 0x44
  4a:	e00f      	b.n	6c <xorIsNonDestructiveOperation+0x6c>

	   message[ i ] ^= (char) cipherKey;
  4c:	1d3a      	adds	r2, r7, #4
  4e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  50:	4413      	add	r3, r2
  52:	781a      	ldrb	r2, [r3, #0]
  54:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
  58:	4053      	eors	r3, r2
  5a:	b2d9      	uxtb	r1, r3
  5c:	1d3a      	adds	r2, r7, #4
  5e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  60:	4413      	add	r3, r2
  62:	460a      	mov	r2, r1
  64:	701a      	strb	r2, [r3, #0]
   for ( int i = 0 ; message[ i ] ; i++ ) {
  66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  68:	3301      	adds	r3, #1
  6a:	647b      	str	r3, [r7, #68]	; 0x44
  6c:	1d3a      	adds	r2, r7, #4
  6e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  70:	4413      	add	r3, r2
  72:	781b      	ldrb	r3, [r3, #0]
  74:	2b00      	cmp	r3, #0
  76:	d1e9      	bne.n	4c <xorIsNonDestructiveOperation+0x4c>

   }

   // decipher
   for ( int i = 0 ; message[ i ] ; i++ ) {
  78:	2300      	movs	r3, #0
  7a:	643b      	str	r3, [r7, #64]	; 0x40
  7c:	e00f      	b.n	9e <xorIsNonDestructiveOperation+0x9e>

	   message[ i ] ^= (char) cipherKey;
  7e:	1d3a      	adds	r2, r7, #4
  80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  82:	4413      	add	r3, r2
  84:	781a      	ldrb	r2, [r3, #0]
  86:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
  8a:	4053      	eors	r3, r2
  8c:	b2d9      	uxtb	r1, r3
  8e:	1d3a      	adds	r2, r7, #4
  90:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  92:	4413      	add	r3, r2
  94:	460a      	mov	r2, r1
  96:	701a      	strb	r2, [r3, #0]
   for ( int i = 0 ; message[ i ] ; i++ ) {
  98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  9a:	3301      	adds	r3, #1
  9c:	643b      	str	r3, [r7, #64]	; 0x40
  9e:	1d3a      	adds	r2, r7, #4
  a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  a2:	4413      	add	r3, r2
  a4:	781b      	ldrb	r3, [r3, #0]
  a6:	2b00      	cmp	r3, #0
  a8:	d1e9      	bne.n	7e <xorIsNonDestructiveOperation+0x7e>

   }

}//xorIsNonDestructiveOperation
  aa:	bf00      	nop
  ac:	bf00      	nop
  ae:	374c      	adds	r7, #76	; 0x4c
  b0:	46bd      	mov	sp, r7
  b2:	bcb0      	pop	{r4, r5, r7}
  b4:	4770      	bx	lr
  b6:	bf00      	nop
  b8:	ffff0000 	.word	0xffff0000
  bc:	00000288 	.word	0x00000288

Disassembly of section .text.getHighNibble:

00000000 <getHighNibble>:

#define CLEAR_LOW_NIBBLE (4)
#define CLEAR_HIGH_NIBBLE (0xF)

byte getHighNibble( byte value ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]

	return (byte)( value >> CLEAR_LOW_NIBBLE );
   a:	79fb      	ldrb	r3, [r7, #7]
   c:	091b      	lsrs	r3, r3, #4
   e:	b2db      	uxtb	r3, r3

}//getHighNibble
  10:	4618      	mov	r0, r3
  12:	370c      	adds	r7, #12
  14:	46bd      	mov	sp, r7
  16:	f85d 7b04 	ldr.w	r7, [sp], #4
  1a:	4770      	bx	lr

Disassembly of section .text.getLowNibble:

00000000 <getLowNibble>:

byte getLowNibble( byte value ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]

	return value & CLEAR_HIGH_NIBBLE;
   a:	79fb      	ldrb	r3, [r7, #7]
   c:	f003 030f 	and.w	r3, r3, #15
  10:	b2db      	uxtb	r3, r3

}//getLowNibble
  12:	4618      	mov	r0, r3
  14:	370c      	adds	r7, #12
  16:	46bd      	mov	sp, r7
  18:	f85d 7b04 	ldr.w	r7, [sp], #4
  1c:	4770      	bx	lr

Disassembly of section .text.bitManipulation:

00000000 <bitManipulation>:

void bitManipulation() {
   0:	b580      	push	{r7, lr}
   2:	b088      	sub	sp, #32
   4:	af00      	add	r7, sp, #0

	BitValue valueAsBit = 0;
   6:	2300      	movs	r3, #0
   8:	77fb      	strb	r3, [r7, #31]
	int      result     = 0;
   a:	2300      	movs	r3, #0
   c:	61bb      	str	r3, [r7, #24]
	int      testValue  = 6; // 00000000000000000000000000000110
   e:	2306      	movs	r3, #6
  10:	617b      	str	r3, [r7, #20]

	valueAsBit = readBit( testValue, 2 );
  12:	697b      	ldr	r3, [r7, #20]
  14:	2102      	movs	r1, #2
  16:	4618      	mov	r0, r3
  18:	f7ff fffe 	bl	0 <bitManipulation>
  1c:	4603      	mov	r3, r0
  1e:	77fb      	strb	r3, [r7, #31]

	result = resetBit( testValue, 2 );
  20:	697b      	ldr	r3, [r7, #20]
  22:	2102      	movs	r1, #2
  24:	4618      	mov	r0, r3
  26:	f7ff fffe 	bl	0 <bitManipulation>
  2a:	4603      	mov	r3, r0
  2c:	61bb      	str	r3, [r7, #24]
	result = setBit( result, 2 );
  2e:	69bb      	ldr	r3, [r7, #24]
  30:	2102      	movs	r1, #2
  32:	4618      	mov	r0, r3
  34:	f7ff fffe 	bl	0 <bitManipulation>
  38:	4603      	mov	r3, r0
  3a:	61bb      	str	r3, [r7, #24]

	const byte mostSignificantBit  = 31;
  3c:	231f      	movs	r3, #31
  3e:	74fb      	strb	r3, [r7, #19]
	const byte leastSignificantBit = 0;
  40:	2300      	movs	r3, #0
  42:	74bb      	strb	r3, [r7, #18]

	// negatif ?
	result = setBit( result, mostSignificantBit );
  44:	69bb      	ldr	r3, [r7, #24]
  46:	7cfa      	ldrb	r2, [r7, #19]
  48:	4611      	mov	r1, r2
  4a:	4618      	mov	r0, r3
  4c:	f7ff fffe 	bl	0 <bitManipulation>
  50:	4603      	mov	r3, r0
  52:	61bb      	str	r3, [r7, #24]
	result = setBit( result, leastSignificantBit );
  54:	69bb      	ldr	r3, [r7, #24]
  56:	7cba      	ldrb	r2, [r7, #18]
  58:	4611      	mov	r1, r2
  5a:	4618      	mov	r0, r3
  5c:	f7ff fffe 	bl	0 <bitManipulation>
  60:	4603      	mov	r3, r0
  62:	61bb      	str	r3, [r7, #24]

	result = resetBit( result, leastSignificantBit );
  64:	69bb      	ldr	r3, [r7, #24]
  66:	7cba      	ldrb	r2, [r7, #18]
  68:	4611      	mov	r1, r2
  6a:	4618      	mov	r0, r3
  6c:	f7ff fffe 	bl	0 <bitManipulation>
  70:	4603      	mov	r3, r0
  72:	61bb      	str	r3, [r7, #24]
	result = resetBit( result, mostSignificantBit );
  74:	69bb      	ldr	r3, [r7, #24]
  76:	7cfa      	ldrb	r2, [r7, #19]
  78:	4611      	mov	r1, r2
  7a:	4618      	mov	r0, r3
  7c:	f7ff fffe 	bl	0 <bitManipulation>
  80:	4603      	mov	r3, r0
  82:	61bb      	str	r3, [r7, #24]

	int a = 3;
  84:	2303      	movs	r3, #3
  86:	607b      	str	r3, [r7, #4]
	int b = 5;
  88:	2305      	movs	r3, #5
  8a:	603b      	str	r3, [r7, #0]
	xorSwap( &a, &b );
  8c:	463a      	mov	r2, r7
  8e:	1d3b      	adds	r3, r7, #4
  90:	4611      	mov	r1, r2
  92:	4618      	mov	r0, r3
  94:	f7ff fffe 	bl	0 <bitManipulation>

	xorIsNonDestructiveOperation();
  98:	f7ff fffe 	bl	0 <bitManipulation>

	result = getLowNibble( 221 );
  9c:	20dd      	movs	r0, #221	; 0xdd
  9e:	f7ff fffe 	bl	0 <bitManipulation>
  a2:	4603      	mov	r3, r0
  a4:	61bb      	str	r3, [r7, #24]
	result = getHighNibble( 221 );
  a6:	20dd      	movs	r0, #221	; 0xdd
  a8:	f7ff fffe 	bl	0 <bitManipulation>
  ac:	4603      	mov	r3, r0
  ae:	61bb      	str	r3, [r7, #24]

	result = getLowNibble( 13 );
  b0:	200d      	movs	r0, #13
  b2:	f7ff fffe 	bl	0 <bitManipulation>
  b6:	4603      	mov	r3, r0
  b8:	61bb      	str	r3, [r7, #24]
	result = getHighNibble( 208 );
  ba:	20d0      	movs	r0, #208	; 0xd0
  bc:	f7ff fffe 	bl	0 <bitManipulation>
  c0:	4603      	mov	r3, r0
  c2:	61bb      	str	r3, [r7, #24]

	float fA = 2.99F;
  c4:	4b03      	ldr	r3, [pc, #12]	; (d4 <bitManipulation+0xd4>)
  c6:	60fb      	str	r3, [r7, #12]
	float fB = 1.99F;
  c8:	4b03      	ldr	r3, [pc, #12]	; (d8 <bitManipulation+0xd8>)
  ca:	60bb      	str	r3, [r7, #8]
	//result = fA & fB; // error invalid operands

}//bitManipulation
  cc:	bf00      	nop
  ce:	3720      	adds	r7, #32
  d0:	46bd      	mov	sp, r7
  d2:	bd80      	pop	{r7, pc}
  d4:	403f5c29 	.word	0x403f5c29
  d8:	3ffeb852 	.word	0x3ffeb852

Disassembly of section .text.bitFields:

00000000 <bitFields>:
     unsigned track         : 9;
     unsigned sector        : 5;
     unsigned command       : 5;
} DiskRegister;

void bitFields( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

	int size = 0;
   6:	2300      	movs	r3, #0
   8:	60fb      	str	r3, [r7, #12]
	size = sizeof(FancyChar);
   a:	2302      	movs	r3, #2
   c:	60fb      	str	r3, [r7, #12]
    size = sizeof(Minireal);
   e:	2304      	movs	r3, #4
  10:	60fb      	str	r3, [r7, #12]
    size = sizeof(DiskRegister);
  12:	2304      	movs	r3, #4
  14:	60fb      	str	r3, [r7, #12]

    // blinking underlined red "A"
    FancyChar character = { 'A',red, true, true };
  16:	4b16      	ldr	r3, [pc, #88]	; (70 <bitFields+0x70>)
  18:	881b      	ldrh	r3, [r3, #0]
  1a:	813b      	strh	r3, [r7, #8]

    character.underline = false;
  1c:	7a7b      	ldrb	r3, [r7, #9]
  1e:	f36f 1304 	bfc	r3, #4, #1
  22:	727b      	strb	r3, [r7, #9]
    character.blink     = false;
  24:	7a7b      	ldrb	r3, [r7, #9]
  26:	f36f 1345 	bfc	r3, #5, #1
  2a:	727b      	strb	r3, [r7, #9]

	// +2345.678
	Minireal real = { 0, 2345, 1 };
  2c:	88bb      	ldrh	r3, [r7, #4]
  2e:	f36f 0309 	bfc	r3, #0, #10
  32:	80bb      	strh	r3, [r7, #4]
  34:	687b      	ldr	r3, [r7, #4]
  36:	f640 1229 	movw	r2, #2345	; 0x929
  3a:	f362 239e 	bfi	r3, r2, #10, #21
  3e:	607b      	str	r3, [r7, #4]
  40:	79fb      	ldrb	r3, [r7, #7]
  42:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  46:	71fb      	strb	r3, [r7, #7]

	// -1234.567
	real.sign     = 1;
  48:	79fb      	ldrb	r3, [r7, #7]
  4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  4e:	71fb      	strb	r3, [r7, #7]
	real.decimal  = 2345;
  50:	687b      	ldr	r3, [r7, #4]
  52:	f640 1229 	movw	r2, #2345	; 0x929
  56:	f362 239e 	bfi	r3, r2, #10, #21
  5a:	607b      	str	r3, [r7, #4]
	real.fraction = 0;
  5c:	88bb      	ldrh	r3, [r7, #4]
  5e:	f36f 0309 	bfc	r3, #0, #10
  62:	80bb      	strh	r3, [r7, #4]

}//bitFields
  64:	bf00      	nop
  66:	3714      	adds	r7, #20
  68:	46bd      	mov	sp, r7
  6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  6e:	4770      	bx	lr
  70:	000002c0 	.word	0x000002c0

Disassembly of section .text.swap:

00000000 <swap>:

//-----------------------------------------------------------------------------

// fast executing small function ( gcc -std=c99 )
static inline void swap( int *x, int *y ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

    if ( x == y )
   a:	687a      	ldr	r2, [r7, #4]
   c:	683b      	ldr	r3, [r7, #0]
   e:	429a      	cmp	r2, r3
  10:	d015      	beq.n	3e <swap+0x3e>
    	return;

   *x ^= *y;
  12:	687b      	ldr	r3, [r7, #4]
  14:	681a      	ldr	r2, [r3, #0]
  16:	683b      	ldr	r3, [r7, #0]
  18:	681b      	ldr	r3, [r3, #0]
  1a:	405a      	eors	r2, r3
  1c:	687b      	ldr	r3, [r7, #4]
  1e:	601a      	str	r2, [r3, #0]
	*y ^= *x;
  20:	683b      	ldr	r3, [r7, #0]
  22:	681a      	ldr	r2, [r3, #0]
  24:	687b      	ldr	r3, [r7, #4]
  26:	681b      	ldr	r3, [r3, #0]
  28:	405a      	eors	r2, r3
  2a:	683b      	ldr	r3, [r7, #0]
  2c:	601a      	str	r2, [r3, #0]
	*x ^= *y;
  2e:	687b      	ldr	r3, [r7, #4]
  30:	681a      	ldr	r2, [r3, #0]
  32:	683b      	ldr	r3, [r7, #0]
  34:	681b      	ldr	r3, [r3, #0]
  36:	405a      	eors	r2, r3
  38:	687b      	ldr	r3, [r7, #4]
  3a:	601a      	str	r2, [r3, #0]
  3c:	e000      	b.n	40 <swap+0x40>
    	return;
  3e:	bf00      	nop

}//swap
  40:	370c      	adds	r7, #12
  42:	46bd      	mov	sp, r7
  44:	f85d 7b04 	ldr.w	r7, [sp], #4
  48:	4770      	bx	lr

Disassembly of section .text.targetFound:

00000000 <targetFound>:

//-----------------------------------------------------------------------------

void targetFound( void ) {
   0:	b580      	push	{r7, lr}
   2:	af00      	add	r7, sp, #0
   printf( "Target value found." );
   4:	4802      	ldr	r0, [pc, #8]	; (10 <targetFound+0x10>)
   6:	f7ff fffe 	bl	0 <printf>
}//targetFound
   a:	bf00      	nop
   c:	bd80      	pop	{r7, pc}
   e:	bf00      	nop
  10:	000002c4 	.word	0x000002c4

Disassembly of section .text.goodGotosAlwaysBranchesForward:

00000000 <goodGotosAlwaysBranchesForward>:

void goodGotosAlwaysBranchesForward() {
   0:	b580      	push	{r7, lr}
   2:	b0a0      	sub	sp, #128	; 0x80
   4:	af00      	add	r7, sp, #0

	static const int meaningOfLife       = 42;
	static const unsigned int largePrime = 2147483647;

	int values[ 2 ][ 3 ][ 4 ] = {
   6:	4a33      	ldr	r2, [pc, #204]	; (d4 <goodGotosAlwaysBranchesForward+0xd4>)
   8:	463b      	mov	r3, r7
   a:	4611      	mov	r1, r2
   c:	2260      	movs	r2, #96	; 0x60
   e:	4618      	mov	r0, r3
  10:	f7ff fffe 	bl	0 <memcpy>
		{
			{211, 212, 213, 214}, {221, 222, 223, 224}, {231, 232, 233, 234}
		}
	};

	const int sizeI = 4;
  14:	2304      	movs	r3, #4
  16:	673b      	str	r3, [r7, #112]	; 0x70
	const int sizeJ = 3;
  18:	2303      	movs	r3, #3
  1a:	66fb      	str	r3, [r7, #108]	; 0x6c
	const int sizeK = 2;
  1c:	2302      	movs	r3, #2
  1e:	66bb      	str	r3, [r7, #104]	; 0x68

	void *buffer = malloc( sizeof(values) );
  20:	2060      	movs	r0, #96	; 0x60
  22:	f7ff fffe 	bl	0 <malloc>
  26:	4603      	mov	r3, r0
  28:	667b      	str	r3, [r7, #100]	; 0x64

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == meaningOfLife )
  2a:	f7ff fffe 	bl	0 <rand>
  2e:	4602      	mov	r2, r0
  30:	4b29      	ldr	r3, [pc, #164]	; (d8 <goodGotosAlwaysBranchesForward+0xd8>)
  32:	681b      	ldr	r3, [r3, #0]
  34:	429a      	cmp	r2, r3
  36:	d041      	beq.n	bc <goodGotosAlwaysBranchesForward+0xbc>
	    goto CLEANUP;

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == largePrime )
  38:	f7ff fffe 	bl	0 <rand>
  3c:	4603      	mov	r3, r0
  3e:	4a27      	ldr	r2, [pc, #156]	; (dc <goodGotosAlwaysBranchesForward+0xdc>)
  40:	6812      	ldr	r2, [r2, #0]
  42:	4293      	cmp	r3, r2
  44:	d03c      	beq.n	c0 <goodGotosAlwaysBranchesForward+0xc0>
	    goto CLEANUP;

	// acaip bi'şey bulunduysa daha fazla aramaya gerek yok
	if ( rand() == NULL )
  46:	f7ff fffe 	bl	0 <rand>
  4a:	4603      	mov	r3, r0
  4c:	2b00      	cmp	r3, #0
  4e:	d039      	beq.n	c4 <goodGotosAlwaysBranchesForward+0xc4>
	    goto CLEANUP;

	// bulunamadıysa aramaya devam
	int target = 222;
  50:	23de      	movs	r3, #222	; 0xde
  52:	663b      	str	r3, [r7, #96]	; 0x60
	for ( int k = 0; k < sizeK; k++ ) {
  54:	2300      	movs	r3, #0
  56:	67fb      	str	r3, [r7, #124]	; 0x7c
  58:	e027      	b.n	aa <goodGotosAlwaysBranchesForward+0xaa>

		for ( int j = 0; j < sizeJ; j++ ) {
  5a:	2300      	movs	r3, #0
  5c:	67bb      	str	r3, [r7, #120]	; 0x78
  5e:	e01d      	b.n	9c <goodGotosAlwaysBranchesForward+0x9c>

			for ( int i = 0; i < sizeI; i++ ) {
  60:	2300      	movs	r3, #0
  62:	677b      	str	r3, [r7, #116]	; 0x74
  64:	e013      	b.n	8e <goodGotosAlwaysBranchesForward+0x8e>

				if ( target == values[ k ][ j ][ i ] )
  66:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  68:	4613      	mov	r3, r2
  6a:	005b      	lsls	r3, r3, #1
  6c:	4413      	add	r3, r2
  6e:	6fba      	ldr	r2, [r7, #120]	; 0x78
  70:	4413      	add	r3, r2
  72:	009a      	lsls	r2, r3, #2
  74:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  76:	4413      	add	r3, r2
  78:	009b      	lsls	r3, r3, #2
  7a:	3380      	adds	r3, #128	; 0x80
  7c:	443b      	add	r3, r7
  7e:	f853 3c80 	ldr.w	r3, [r3, #-128]
  82:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  84:	429a      	cmp	r2, r3
  86:	d015      	beq.n	b4 <goodGotosAlwaysBranchesForward+0xb4>
			for ( int i = 0; i < sizeI; i++ ) {
  88:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  8a:	3301      	adds	r3, #1
  8c:	677b      	str	r3, [r7, #116]	; 0x74
  8e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
  90:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  92:	429a      	cmp	r2, r3
  94:	dbe7      	blt.n	66 <goodGotosAlwaysBranchesForward+0x66>
		for ( int j = 0; j < sizeJ; j++ ) {
  96:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  98:	3301      	adds	r3, #1
  9a:	67bb      	str	r3, [r7, #120]	; 0x78
  9c:	6fba      	ldr	r2, [r7, #120]	; 0x78
  9e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  a0:	429a      	cmp	r2, r3
  a2:	dbdd      	blt.n	60 <goodGotosAlwaysBranchesForward+0x60>
	for ( int k = 0; k < sizeK; k++ ) {
  a4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  a6:	3301      	adds	r3, #1
  a8:	67fb      	str	r3, [r7, #124]	; 0x7c
  aa:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  ac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  ae:	429a      	cmp	r2, r3
  b0:	dbd3      	blt.n	5a <goodGotosAlwaysBranchesForward+0x5a>

		}//forj

	}//fork

   goto CLEANUP;
  b2:	e008      	b.n	c6 <goodGotosAlwaysBranchesForward+0xc6>
				   goto MULTIBREAK;
  b4:	bf00      	nop

MULTIBREAK:

   targetFound();
  b6:	f7ff fffe 	bl	0 <goodGotosAlwaysBranchesForward>
  ba:	e004      	b.n	c6 <goodGotosAlwaysBranchesForward+0xc6>
	    goto CLEANUP;
  bc:	bf00      	nop
  be:	e002      	b.n	c6 <goodGotosAlwaysBranchesForward+0xc6>
	    goto CLEANUP;
  c0:	bf00      	nop
  c2:	e000      	b.n	c6 <goodGotosAlwaysBranchesForward+0xc6>
	    goto CLEANUP;
  c4:	bf00      	nop

CLEANUP:

	free( buffer );
  c6:	6e78      	ldr	r0, [r7, #100]	; 0x64
  c8:	f7ff fffe 	bl	0 <free>

}//goodGotosAlwaysBranchesForward
  cc:	bf00      	nop
  ce:	3780      	adds	r7, #128	; 0x80
  d0:	46bd      	mov	sp, r7
  d2:	bd80      	pop	{r7, pc}
  d4:	00000204 	.word	0x00000204
	...

Disassembly of section .text.functions_recursiveFunction:

00000000 <functions_recursiveFunction>:

//-----------------------------------------------------------------------------

int recursionLimit = 16;
void functions_recursiveFunction( void ) {
   0:	b580      	push	{r7, lr}
   2:	af00      	add	r7, sp, #0

	if ( recursionLimit-- ) {
   4:	4b05      	ldr	r3, [pc, #20]	; (1c <functions_recursiveFunction+0x1c>)
   6:	681b      	ldr	r3, [r3, #0]
   8:	1e5a      	subs	r2, r3, #1
   a:	4904      	ldr	r1, [pc, #16]	; (1c <functions_recursiveFunction+0x1c>)
   c:	600a      	str	r2, [r1, #0]
   e:	2b00      	cmp	r3, #0
  10:	d001      	beq.n	16 <functions_recursiveFunction+0x16>
		functions_recursiveFunction();
  12:	f7ff fffe 	bl	0 <functions_recursiveFunction>
	}

}//functions_recursiveFunction
  16:	bf00      	nop
  18:	bd80      	pop	{r7, pc}
  1a:	bf00      	nop
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.functions_recursiveFactorial:

00000000 <functions_recursiveFactorial>:

long long int functions_recursiveFactorial( long long int number ) {
   0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
   4:	b082      	sub	sp, #8
   6:	af00      	add	r7, sp, #0
   8:	e9c7 0100 	strd	r0, r1, [r7]
	} else {
	   return number * functions_recursiveFactorial( number - 1 );
	}
    */

	return number == 0 ? 1 : number * functions_recursiveFactorial( number - 1 );
   c:	e9d7 2300 	ldrd	r2, r3, [r7]
  10:	4313      	orrs	r3, r2
  12:	d018      	beq.n	46 <functions_recursiveFactorial+0x46>
  14:	e9d7 2300 	ldrd	r2, r3, [r7]
  18:	f112 38ff 	adds.w	r8, r2, #4294967295	; 0xffffffff
  1c:	f143 39ff 	adc.w	r9, r3, #4294967295	; 0xffffffff
  20:	4640      	mov	r0, r8
  22:	4649      	mov	r1, r9
  24:	f7ff fffe 	bl	0 <functions_recursiveFactorial>
  28:	4602      	mov	r2, r0
  2a:	460b      	mov	r3, r1
  2c:	6839      	ldr	r1, [r7, #0]
  2e:	fb03 f001 	mul.w	r0, r3, r1
  32:	6879      	ldr	r1, [r7, #4]
  34:	fb02 f101 	mul.w	r1, r2, r1
  38:	4401      	add	r1, r0
  3a:	6838      	ldr	r0, [r7, #0]
  3c:	fba0 4502 	umull	r4, r5, r0, r2
  40:	194b      	adds	r3, r1, r5
  42:	461d      	mov	r5, r3
  44:	e003      	b.n	4e <functions_recursiveFactorial+0x4e>
  46:	f04f 0401 	mov.w	r4, #1
  4a:	f04f 0500 	mov.w	r5, #0
  4e:	4622      	mov	r2, r4
  50:	462b      	mov	r3, r5

}//functions_recursionFactorial
  52:	4610      	mov	r0, r2
  54:	4619      	mov	r1, r3
  56:	3708      	adds	r7, #8
  58:	46bd      	mov	sp, r7
  5a:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

Disassembly of section .text.functions_sum:

00000000 <functions_sum>:

//-----------------------------------------------------------------------------

long long int functions_sum( int argc, ... ) {
   0:	b40f      	push	{r0, r1, r2, r3}
   2:	b4b0      	push	{r4, r5, r7}
   4:	b085      	sub	sp, #20
   6:	af00      	add	r7, sp, #0

	long long int sum = 0;
   8:	f04f 0200 	mov.w	r2, #0
   c:	f04f 0300 	mov.w	r3, #0
  10:	e9c7 2302 	strd	r2, r3, [r7, #8]
	va_list valist;

	// initialize macro
	va_start( valist, argc );
  14:	f107 0324 	add.w	r3, r7, #36	; 0x24
  18:	603b      	str	r3, [r7, #0]

	for ( int i = 0; i < argc; i++)
  1a:	2300      	movs	r3, #0
  1c:	607b      	str	r3, [r7, #4]
  1e:	e010      	b.n	42 <functions_sum+0x42>
	{
	   sum += va_arg( valist, int );
  20:	683b      	ldr	r3, [r7, #0]
  22:	1d1a      	adds	r2, r3, #4
  24:	603a      	str	r2, [r7, #0]
  26:	681b      	ldr	r3, [r3, #0]
  28:	17da      	asrs	r2, r3, #31
  2a:	4618      	mov	r0, r3
  2c:	4611      	mov	r1, r2
  2e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
  32:	1814      	adds	r4, r2, r0
  34:	eb43 0501 	adc.w	r5, r3, r1
  38:	e9c7 4502 	strd	r4, r5, [r7, #8]
	for ( int i = 0; i < argc; i++)
  3c:	687b      	ldr	r3, [r7, #4]
  3e:	3301      	adds	r3, #1
  40:	607b      	str	r3, [r7, #4]
  42:	687a      	ldr	r2, [r7, #4]
  44:	6a3b      	ldr	r3, [r7, #32]
  46:	429a      	cmp	r2, r3
  48:	dbea      	blt.n	20 <functions_sum+0x20>
	}

	// clean valist left overs
	va_end( valist );

	return sum;
  4a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]

}//functions_sum
  4e:	4610      	mov	r0, r2
  50:	4619      	mov	r1, r3
  52:	3714      	adds	r7, #20
  54:	46bd      	mov	sp, r7
  56:	bcb0      	pop	{r4, r5, r7}
  58:	b004      	add	sp, #16
  5a:	4770      	bx	lr

Disassembly of section .text.unions:

00000000 <unions>:
	MixCSI     mixCSI;
	FloatBits  bits;

} VeryMix;

void unions( void ) {
   0:	b480      	push	{r7}
   2:	b091      	sub	sp, #68	; 0x44
   4:	af00      	add	r7, sp, #0

   // left uninitialized
   FloatBits bits;
   size_t size = 0;
   6:	2300      	movs	r3, #0
   8:	637b      	str	r3, [r7, #52]	; 0x34

   size = sizeof( bits );
   a:	2304      	movs	r3, #4
   c:	637b      	str	r3, [r7, #52]	; 0x34

   bits.fv      = -3.14F;
   e:	4b44      	ldr	r3, [pc, #272]	; (120 <unions+0x120>)
  10:	627b      	str	r3, [r7, #36]	; 0x24
   bits.bv.sign = 0;
  12:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  16:	f36f 13c7 	bfc	r3, #7, #1
  1a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

   // initialize with zeros
   MixCSI mcsi = {};
  1e:	2300      	movs	r3, #0
  20:	623b      	str	r3, [r7, #32]
   mcsi.iValue = 0xFAFBFCFD;
  22:	4b40      	ldr	r3, [pc, #256]	; (124 <unions+0x124>)
  24:	623b      	str	r3, [r7, #32]

   size = sizeof( MixCSI );
  26:	2304      	movs	r3, #4
  28:	637b      	str	r3, [r7, #52]	; 0x34

   char c = mcsi.cA;
  2a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  2e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

   c = mcsi.cB;
  32:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
  36:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
   c = mcsi.cC;
  3a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
  3e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
   c = mcsi.cD;
  42:	f897 3020 	ldrb.w	r3, [r7, #32]
  46:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

   int s =  mcsi.sL;
  4a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
  4e:	62fb      	str	r3, [r7, #44]	; 0x2c
   s =  mcsi.sH;
  50:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
  54:	62fb      	str	r3, [r7, #44]	; 0x2c

   int i = mcsi.iValue;
  56:	6a3b      	ldr	r3, [r7, #32]
  58:	62bb      	str	r3, [r7, #40]	; 0x28

   mcsi.cD = 0xFF;
  5a:	23ff      	movs	r3, #255	; 0xff
  5c:	f887 3020 	strb.w	r3, [r7, #32]

   mcsi.sH = 0xF1F2;
  60:	f24f 13f2 	movw	r3, #61938	; 0xf1f2
  64:	847b      	strh	r3, [r7, #34]	; 0x22

   int loop = 4;
  66:	2304      	movs	r3, #4
  68:	63fb      	str	r3, [r7, #60]	; 0x3c
   while ( loop-- )
  6a:	e00a      	b.n	82 <unions+0x82>
	  mcsi.car[ loop ] = 68 - loop;
  6c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  6e:	b2db      	uxtb	r3, r3
  70:	f1c3 0344 	rsb	r3, r3, #68	; 0x44
  74:	b2d9      	uxtb	r1, r3
  76:	f107 0220 	add.w	r2, r7, #32
  7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  7c:	4413      	add	r3, r2
  7e:	460a      	mov	r2, r1
  80:	701a      	strb	r2, [r3, #0]
   while ( loop-- )
  82:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  84:	1e5a      	subs	r2, r3, #1
  86:	63fa      	str	r2, [r7, #60]	; 0x3c
  88:	2b00      	cmp	r3, #0
  8a:	d1ef      	bne.n	6c <unions+0x6c>

   // initialize with zeros
   Mix mix = {};
  8c:	f107 0310 	add.w	r3, r7, #16
  90:	2200      	movs	r2, #0
  92:	601a      	str	r2, [r3, #0]
  94:	605a      	str	r2, [r3, #4]
  96:	609a      	str	r2, [r3, #8]
  98:	60da      	str	r2, [r3, #12]
   size = sizeof( Mix );
  9a:	2310      	movs	r3, #16
  9c:	637b      	str	r3, [r7, #52]	; 0x34

   mix.decimal = -3.14L;
  9e:	a31e      	add	r3, pc, #120	; (adr r3, 118 <unions+0x118>)
  a0:	e9d3 2300 	ldrd	r2, r3, [r3]
  a4:	e9c7 2304 	strd	r2, r3, [r7, #16]
   mix.decimal = LDBL_MAX;
  a8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  ac:	4b1e      	ldr	r3, [pc, #120]	; (128 <unions+0x128>)
  ae:	e9c7 2304 	strd	r2, r3, [r7, #16]

   loop = 12;
  b2:	230c      	movs	r3, #12
  b4:	63fb      	str	r3, [r7, #60]	; 0x3c
   while ( loop-- )
  b6:	e00a      	b.n	ce <unions+0xce>
	  mix.text[ loop ] = 80 - loop;
  b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  ba:	b2db      	uxtb	r3, r3
  bc:	f1c3 0350 	rsb	r3, r3, #80	; 0x50
  c0:	b2d9      	uxtb	r1, r3
  c2:	f107 0210 	add.w	r2, r7, #16
  c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  c8:	4413      	add	r3, r2
  ca:	460a      	mov	r2, r1
  cc:	701a      	strb	r2, [r3, #0]
   while ( loop-- )
  ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  d0:	1e5a      	subs	r2, r3, #1
  d2:	63fa      	str	r2, [r7, #60]	; 0x3c
  d4:	2b00      	cmp	r3, #0
  d6:	d1ef      	bne.n	b8 <unions+0xb8>


   // initialize with zeros
   VeryMix vmx = {};
  d8:	463b      	mov	r3, r7
  da:	2200      	movs	r2, #0
  dc:	601a      	str	r2, [r3, #0]
  de:	605a      	str	r2, [r3, #4]
  e0:	609a      	str	r2, [r3, #8]
  e2:	60da      	str	r2, [r3, #12]
   char* pc = (char*) &vmx;
  e4:	463b      	mov	r3, r7
  e6:	63bb      	str	r3, [r7, #56]	; 0x38

   loop = sizeof( VeryMix );
  e8:	2310      	movs	r3, #16
  ea:	63fb      	str	r3, [r7, #60]	; 0x3c
   while ( loop-- )
  ec:	e004      	b.n	f8 <unions+0xf8>
	   *pc++ = 0;
  ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  f0:	1c5a      	adds	r2, r3, #1
  f2:	63ba      	str	r2, [r7, #56]	; 0x38
  f4:	2200      	movs	r2, #0
  f6:	701a      	strb	r2, [r3, #0]
   while ( loop-- )
  f8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  fa:	1e5a      	subs	r2, r3, #1
  fc:	63fa      	str	r2, [r7, #60]	; 0x3c
  fe:	2b00      	cmp	r3, #0
 100:	d1f5      	bne.n	ee <unions+0xee>

   vmx.mixCSI.cD = 65;
 102:	2341      	movs	r3, #65	; 0x41
 104:	703b      	strb	r3, [r7, #0]

}//unions
 106:	bf00      	nop
 108:	3744      	adds	r7, #68	; 0x44
 10a:	46bd      	mov	sp, r7
 10c:	f85d 7b04 	ldr.w	r7, [sp], #4
 110:	4770      	bx	lr
 112:	bf00      	nop
 114:	f3af 8000 	nop.w
 118:	51eb851f 	.word	0x51eb851f
 11c:	c0091eb8 	.word	0xc0091eb8
 120:	c048f5c3 	.word	0xc048f5c3
 124:	fafbfcfd 	.word	0xfafbfcfd
 128:	7fefffff 	.word	0x7fefffff

Disassembly of section .text.typePromotion:

00000000 <typePromotion>:

//-----------------------------------------------------------------------------

void typePromotion( void ) {
   0:	b480      	push	{r7}
   2:	b089      	sub	sp, #36	; 0x24
   4:	af00      	add	r7, sp, #0

	int   i =  1;
   6:	2101      	movs	r1, #1
   8:	61f9      	str	r1, [r7, #28]
	float f =  0.10F;
   a:	4918      	ldr	r1, [pc, #96]	; (6c <typePromotion+0x6c>)
   c:	61b9      	str	r1, [r7, #24]
	float r =  0.00F;
   e:	f04f 0100 	mov.w	r1, #0
  12:	6179      	str	r1, [r7, #20]

	r = f + i;
  14:	69f9      	ldr	r1, [r7, #28]
  16:	ee07 1a90 	vmov	s15, r1
  1a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  1e:	ed97 7a06 	vldr	s14, [r7, #24]
  22:	ee77 7a27 	vadd.f32	s15, s14, s15
  26:	edc7 7a05 	vstr	s15, [r7, #20]

	char  c  = 2;
  2a:	2102      	movs	r1, #2
  2c:	74f9      	strb	r1, [r7, #19]
	short s  = 3;
  2e:	2103      	movs	r1, #3
  30:	8239      	strh	r1, [r7, #16]
	unsigned int u = 6;
  32:	2106      	movs	r1, #6
  34:	60f9      	str	r1, [r7, #12]

	i = i + c;
  36:	7cf9      	ldrb	r1, [r7, #19]
  38:	69f8      	ldr	r0, [r7, #28]
  3a:	4401      	add	r1, r0
  3c:	61f9      	str	r1, [r7, #28]

	i = i + s;
  3e:	f9b7 1010 	ldrsh.w	r1, [r7, #16]
  42:	69f8      	ldr	r0, [r7, #28]
  44:	4401      	add	r1, r0
  46:	61f9      	str	r1, [r7, #28]

	i = i + u;
  48:	69f8      	ldr	r0, [r7, #28]
  4a:	68f9      	ldr	r1, [r7, #12]
  4c:	4401      	add	r1, r0
  4e:	61f9      	str	r1, [r7, #28]

	long long l = 1L + c;
  50:	7cf9      	ldrb	r1, [r7, #19]
  52:	3101      	adds	r1, #1
  54:	17c8      	asrs	r0, r1, #31
  56:	460a      	mov	r2, r1
  58:	4603      	mov	r3, r0
  5a:	e9c7 2300 	strd	r2, r3, [r7]

}//typePromotion
  5e:	bf00      	nop
  60:	3724      	adds	r7, #36	; 0x24
  62:	46bd      	mov	sp, r7
  64:	f85d 7b04 	ldr.w	r7, [sp], #4
  68:	4770      	bx	lr
  6a:	bf00      	nop
  6c:	3dcccccd 	.word	0x3dcccccd

Disassembly of section .text.typePromotionPromoteToInt:

00000000 <typePromotionPromoteToInt>:

//-----------------------------------------------------------------------------

void typePromotionPromoteToInt( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

	// see disassembly ( sign extend instructions )
	// all ranks lower than int (signed or unsigned), promote to int
	_Bool b =  false;
   6:	2300      	movs	r3, #0
   8:	73fb      	strb	r3, [r7, #15]
	char  c =  'a';
   a:	2361      	movs	r3, #97	; 0x61
   c:	73bb      	strb	r3, [r7, #14]
	short s =  -8;
   e:	f64f 73f8 	movw	r3, #65528	; 0xfff8
  12:	81bb      	strh	r3, [r7, #12]

	int r = 0;
  14:	2300      	movs	r3, #0
  16:	60bb      	str	r3, [r7, #8]
	int d = 1;
  18:	2301      	movs	r3, #1
  1a:	607b      	str	r3, [r7, #4]
	d = b + b + b;
  1c:	7bfa      	ldrb	r2, [r7, #15]
  1e:	4613      	mov	r3, r2
  20:	005b      	lsls	r3, r3, #1
  22:	4413      	add	r3, r2
  24:	607b      	str	r3, [r7, #4]

	r = b + c + s;
  26:	7bfa      	ldrb	r2, [r7, #15]
  28:	7bbb      	ldrb	r3, [r7, #14]
  2a:	441a      	add	r2, r3
  2c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
  30:	4413      	add	r3, r2
  32:	60bb      	str	r3, [r7, #8]

}//typePromotionPromoteToInt
  34:	bf00      	nop
  36:	3714      	adds	r7, #20
  38:	46bd      	mov	sp, r7
  3a:	f85d 7b04 	ldr.w	r7, [sp], #4
  3e:	4770      	bx	lr

Disassembly of section .text.typePromotionPromoteToInt2:

00000000 <typePromotionPromoteToInt2>:

//-----------------------------------------------------------------------------

void typePromotionPromoteToInt2( void ) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0

	// see disassembly ( sign extend instructions )
	// all ranks lower than int (signed or unsigned), promote to int

	short s1 = -5;
   6:	f64f 73fb 	movw	r3, #65531	; 0xfffb
   a:	80fb      	strh	r3, [r7, #6]
	short s2 = 3;
   c:	2303      	movs	r3, #3
   e:	80bb      	strh	r3, [r7, #4]

	s2 = -s2;
  10:	88bb      	ldrh	r3, [r7, #4]
  12:	425b      	negs	r3, r3
  14:	b29b      	uxth	r3, r3
  16:	80bb      	strh	r3, [r7, #4]
	s1 = s1 + s2;
  18:	88fa      	ldrh	r2, [r7, #6]
  1a:	88bb      	ldrh	r3, [r7, #4]
  1c:	4413      	add	r3, r2
  1e:	b29b      	uxth	r3, r3
  20:	80fb      	strh	r3, [r7, #6]

	int r = s1 + s1;
  22:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
  26:	005b      	lsls	r3, r3, #1
  28:	603b      	str	r3, [r7, #0]

	r = s1 + s2;
  2a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
  2e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
  32:	4413      	add	r3, r2
  34:	603b      	str	r3, [r7, #0]

}//typePromotionPromoteToInt2
  36:	bf00      	nop
  38:	370c      	adds	r7, #12
  3a:	46bd      	mov	sp, r7
  3c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40:	4770      	bx	lr

Disassembly of section .text.typePromotionSameWidth:

00000000 <typePromotionSameWidth>:

//-----------------------------------------------------------------------------

void typePromotionSameWidth( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

	// see disassembly
	// same size (representation) different rank
	signed   int negativeOne =  -1;
   6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   a:	60fb      	str	r3, [r7, #12]
	unsigned int positiveOne =  +1;
   c:	2301      	movs	r3, #1
   e:	60bb      	str	r3, [r7, #8]

	_Bool result = false;
  10:	2300      	movs	r3, #0
  12:	71fb      	strb	r3, [r7, #7]

	result = positiveOne < negativeOne;
  14:	68fb      	ldr	r3, [r7, #12]
  16:	68ba      	ldr	r2, [r7, #8]
  18:	429a      	cmp	r2, r3
  1a:	bf34      	ite	cc
  1c:	2301      	movcc	r3, #1
  1e:	2300      	movcs	r3, #0
  20:	71fb      	strb	r3, [r7, #7]

}//typePromotionSameWidth
  22:	bf00      	nop
  24:	3714      	adds	r7, #20
  26:	46bd      	mov	sp, r7
  28:	f85d 7b04 	ldr.w	r7, [sp], #4
  2c:	4770      	bx	lr

Disassembly of section .text.evaluationOrderA:

00000000 <evaluationOrderA>:

//-----------------------------------------------------------------------------

void evaluationOrderA( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

	// see disassembly
   int a = 1;
   6:	2301      	movs	r3, #1
   8:	60fb      	str	r3, [r7, #12]
   int b = 2;
   a:	2302      	movs	r3, #2
   c:	60bb      	str	r3, [r7, #8]
   int c = 3;
   e:	2303      	movs	r3, #3
  10:	607b      	str	r3, [r7, #4]
   int d = 4;
  12:	2304      	movs	r3, #4
  14:	603b      	str	r3, [r7, #0]

   d = a + b - c + 3;
  16:	68fa      	ldr	r2, [r7, #12]
  18:	68bb      	ldr	r3, [r7, #8]
  1a:	441a      	add	r2, r3
  1c:	687b      	ldr	r3, [r7, #4]
  1e:	1ad3      	subs	r3, r2, r3
  20:	3303      	adds	r3, #3
  22:	603b      	str	r3, [r7, #0]

}//evaluationOrderA
  24:	bf00      	nop
  26:	3714      	adds	r7, #20
  28:	46bd      	mov	sp, r7
  2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  2e:	4770      	bx	lr

Disassembly of section .text.evaluationOrderB:

00000000 <evaluationOrderB>:

//-----------------------------------------------------------------------------

void evaluationOrderB( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int a = 1;
   6:	2301      	movs	r3, #1
   8:	60fb      	str	r3, [r7, #12]
   int b = 2;
   a:	2302      	movs	r3, #2
   c:	60bb      	str	r3, [r7, #8]
   int c = 3;
   e:	2303      	movs	r3, #3
  10:	607b      	str	r3, [r7, #4]
   int d = 4;
  12:	2304      	movs	r3, #4
  14:	603b      	str	r3, [r7, #0]

   d = a + b * c + 3;
  16:	68bb      	ldr	r3, [r7, #8]
  18:	687a      	ldr	r2, [r7, #4]
  1a:	fb03 f202 	mul.w	r2, r3, r2
  1e:	68fb      	ldr	r3, [r7, #12]
  20:	4413      	add	r3, r2
  22:	3303      	adds	r3, #3
  24:	603b      	str	r3, [r7, #0]

}//evaluationOrderB
  26:	bf00      	nop
  28:	3714      	adds	r7, #20
  2a:	46bd      	mov	sp, r7
  2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  30:	4770      	bx	lr

Disassembly of section .text.evaluationOrderC:

00000000 <evaluationOrderC>:

//-----------------------------------------------------------------------------

void evaluationOrderC( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int a = 1;
   6:	2301      	movs	r3, #1
   8:	60fb      	str	r3, [r7, #12]
   int b = 2;
   a:	2302      	movs	r3, #2
   c:	60bb      	str	r3, [r7, #8]
   int c = 3;
   e:	2303      	movs	r3, #3
  10:	607b      	str	r3, [r7, #4]
   int d = 4;
  12:	2304      	movs	r3, #4
  14:	603b      	str	r3, [r7, #0]

   d = a = b = c = 5;
  16:	2305      	movs	r3, #5
  18:	607b      	str	r3, [r7, #4]
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	60bb      	str	r3, [r7, #8]
  1e:	68bb      	ldr	r3, [r7, #8]
  20:	60fb      	str	r3, [r7, #12]
  22:	68fb      	ldr	r3, [r7, #12]
  24:	603b      	str	r3, [r7, #0]

}//evaluationOrderC
  26:	bf00      	nop
  28:	3714      	adds	r7, #20
  2a:	46bd      	mov	sp, r7
  2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  30:	4770      	bx	lr

Disassembly of section .text.division:

00000000 <division>:

//-----------------------------------------------------------------------------

void division( void ) {
   0:	b480      	push	{r7}
   2:	b089      	sub	sp, #36	; 0x24
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int a = 5;
   6:	2305      	movs	r3, #5
   8:	61fb      	str	r3, [r7, #28]
   int b = 2;
   a:	2302      	movs	r3, #2
   c:	61bb      	str	r3, [r7, #24]

   unsigned int ua = 5;
   e:	2305      	movs	r3, #5
  10:	617b      	str	r3, [r7, #20]
   unsigned int ub = 2;
  12:	2302      	movs	r3, #2
  14:	613b      	str	r3, [r7, #16]

   int          ir = 0;
  16:	2300      	movs	r3, #0
  18:	60fb      	str	r3, [r7, #12]
   unsigned int ur = 0;
  1a:	2300      	movs	r3, #0
  1c:	60bb      	str	r3, [r7, #8]
   float        fr = 0.0F;
  1e:	f04f 0300 	mov.w	r3, #0
  22:	607b      	str	r3, [r7, #4]

   ir = a / b;
  24:	69fa      	ldr	r2, [r7, #28]
  26:	69bb      	ldr	r3, [r7, #24]
  28:	fb92 f3f3 	sdiv	r3, r2, r3
  2c:	60fb      	str	r3, [r7, #12]

   fr = a / b;
  2e:	69fa      	ldr	r2, [r7, #28]
  30:	69bb      	ldr	r3, [r7, #24]
  32:	fb92 f3f3 	sdiv	r3, r2, r3
  36:	ee07 3a90 	vmov	s15, r3
  3a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  3e:	edc7 7a01 	vstr	s15, [r7, #4]

   fr = (float)( a / b );
  42:	69fa      	ldr	r2, [r7, #28]
  44:	69bb      	ldr	r3, [r7, #24]
  46:	fb92 f3f3 	sdiv	r3, r2, r3
  4a:	ee07 3a90 	vmov	s15, r3
  4e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  52:	edc7 7a01 	vstr	s15, [r7, #4]

   fr = (float)a / b;
  56:	69fb      	ldr	r3, [r7, #28]
  58:	ee07 3a90 	vmov	s15, r3
  5c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  60:	69bb      	ldr	r3, [r7, #24]
  62:	ee07 3a90 	vmov	s15, r3
  66:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  6a:	eec6 7a87 	vdiv.f32	s15, s13, s14
  6e:	edc7 7a01 	vstr	s15, [r7, #4]

   fr = a / (float)b;
  72:	69fb      	ldr	r3, [r7, #28]
  74:	ee07 3a90 	vmov	s15, r3
  78:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  7c:	69bb      	ldr	r3, [r7, #24]
  7e:	ee07 3a90 	vmov	s15, r3
  82:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  86:	eec6 7a87 	vdiv.f32	s15, s13, s14
  8a:	edc7 7a01 	vstr	s15, [r7, #4]

   ur = ua / ub;
  8e:	697a      	ldr	r2, [r7, #20]
  90:	693b      	ldr	r3, [r7, #16]
  92:	fbb2 f3f3 	udiv	r3, r2, r3
  96:	60bb      	str	r3, [r7, #8]

   ur = (float)ua / ub;
  98:	697b      	ldr	r3, [r7, #20]
  9a:	ee07 3a90 	vmov	s15, r3
  9e:	eef8 6a67 	vcvt.f32.u32	s13, s15
  a2:	693b      	ldr	r3, [r7, #16]
  a4:	ee07 3a90 	vmov	s15, r3
  a8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  ac:	eec6 7a87 	vdiv.f32	s15, s13, s14
  b0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  b4:	ee17 3a90 	vmov	r3, s15
  b8:	60bb      	str	r3, [r7, #8]

}//division
  ba:	bf00      	nop
  bc:	3724      	adds	r7, #36	; 0x24
  be:	46bd      	mov	sp, r7
  c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  c4:	4770      	bx	lr

Disassembly of section .text.modulus:

00000000 <modulus>:

//-----------------------------------------------------------------------------

void modulus( void ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0

   // see disassembly
   int r = 0;
   6:	2300      	movs	r3, #0
   8:	60fb      	str	r3, [r7, #12]

   r = +5 % 3;
   a:	2302      	movs	r3, #2
   c:	60fb      	str	r3, [r7, #12]
   r = -5 % 3;
   e:	f06f 0301 	mvn.w	r3, #1
  12:	60fb      	str	r3, [r7, #12]
   r = +5 % -3;
  14:	2302      	movs	r3, #2
  16:	60fb      	str	r3, [r7, #12]

   r = +3 % 5;
  18:	2303      	movs	r3, #3
  1a:	60fb      	str	r3, [r7, #12]
   r = +3 % -5;
  1c:	2303      	movs	r3, #3
  1e:	60fb      	str	r3, [r7, #12]

   r = (int)7.99F % 5;
  20:	2302      	movs	r3, #2
  22:	60fb      	str	r3, [r7, #12]

   int a = 5;
  24:	2305      	movs	r3, #5
  26:	60bb      	str	r3, [r7, #8]
   int b = 3;
  28:	2303      	movs	r3, #3
  2a:	607b      	str	r3, [r7, #4]

   r = +a % 3;
  2c:	68ba      	ldr	r2, [r7, #8]
  2e:	4b19      	ldr	r3, [pc, #100]	; (94 <modulus+0x94>)
  30:	fb83 3102 	smull	r3, r1, r3, r2
  34:	17d3      	asrs	r3, r2, #31
  36:	1ac9      	subs	r1, r1, r3
  38:	460b      	mov	r3, r1
  3a:	005b      	lsls	r3, r3, #1
  3c:	440b      	add	r3, r1
  3e:	1ad3      	subs	r3, r2, r3
  40:	60fb      	str	r3, [r7, #12]
   r = -a % 3;
  42:	68bb      	ldr	r3, [r7, #8]
  44:	425a      	negs	r2, r3
  46:	4b13      	ldr	r3, [pc, #76]	; (94 <modulus+0x94>)
  48:	fb83 3102 	smull	r3, r1, r3, r2
  4c:	17d3      	asrs	r3, r2, #31
  4e:	1ac9      	subs	r1, r1, r3
  50:	460b      	mov	r3, r1
  52:	005b      	lsls	r3, r3, #1
  54:	440b      	add	r3, r1
  56:	1ad3      	subs	r3, r2, r3
  58:	60fb      	str	r3, [r7, #12]

   r = +a % -3;
  5a:	68ba      	ldr	r2, [r7, #8]
  5c:	4b0d      	ldr	r3, [pc, #52]	; (94 <modulus+0x94>)
  5e:	fb83 3102 	smull	r3, r1, r3, r2
  62:	17d3      	asrs	r3, r2, #31
  64:	1ac9      	subs	r1, r1, r3
  66:	460b      	mov	r3, r1
  68:	005b      	lsls	r3, r3, #1
  6a:	440b      	add	r3, r1
  6c:	1ad3      	subs	r3, r2, r3
  6e:	60fb      	str	r3, [r7, #12]
   r = -a % -3;
  70:	68bb      	ldr	r3, [r7, #8]
  72:	425a      	negs	r2, r3
  74:	4b07      	ldr	r3, [pc, #28]	; (94 <modulus+0x94>)
  76:	fb83 3102 	smull	r3, r1, r3, r2
  7a:	17d3      	asrs	r3, r2, #31
  7c:	1ac9      	subs	r1, r1, r3
  7e:	460b      	mov	r3, r1
  80:	005b      	lsls	r3, r3, #1
  82:	440b      	add	r3, r1
  84:	1ad3      	subs	r3, r2, r3
  86:	60fb      	str	r3, [r7, #12]

}//modulus
  88:	bf00      	nop
  8a:	3714      	adds	r7, #20
  8c:	46bd      	mov	sp, r7
  8e:	f85d 7b04 	ldr.w	r7, [sp], #4
  92:	4770      	bx	lr
  94:	55555556 	.word	0x55555556

Disassembly of section .text.initializationOfVariables:

00000000 <initializationOfVariables>:

//-----------------------------------------------------------------------------

void initializationOfVariables( void ) {
   0:	b580      	push	{r7, lr}
   2:	b08e      	sub	sp, #56	; 0x38
   4:	af00      	add	r7, sp, #0

   // see disassembly
   char           c = 'A';
   6:	2341      	movs	r3, #65	; 0x41
   8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
   unsigned char uc = 'B';
   c:	2342      	movs	r3, #66	; 0x42
   e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

   short          s  = 1;
  12:	2301      	movs	r3, #1
  14:	86bb      	strh	r3, [r7, #52]	; 0x34
   unsigned short us = 1;
  16:	2301      	movs	r3, #1
  18:	867b      	strh	r3, [r7, #50]	; 0x32

   int          i  = 3;
  1a:	2303      	movs	r3, #3
  1c:	62fb      	str	r3, [r7, #44]	; 0x2c
   unsigned int ui = 4;
  1e:	2304      	movs	r3, #4
  20:	62bb      	str	r3, [r7, #40]	; 0x28

   long long          ll  = 5LL;
  22:	f04f 0205 	mov.w	r2, #5
  26:	f04f 0300 	mov.w	r3, #0
  2a:	e9c7 2308 	strd	r2, r3, [r7, #32]
   unsigned long long ull = 6ULL;
  2e:	f04f 0206 	mov.w	r2, #6
  32:	f04f 0300 	mov.w	r3, #0
  36:	e9c7 2306 	strd	r2, r3, [r7, #24]

   float       fA = 1.99F;
  3a:	4b2b      	ldr	r3, [pc, #172]	; (e8 <initializationOfVariables+0xe8>)
  3c:	617b      	str	r3, [r7, #20]
   double      dB = 2.99;
  3e:	a324      	add	r3, pc, #144	; (adr r3, d0 <initializationOfVariables+0xd0>)
  40:	e9d3 2300 	ldrd	r2, r3, [r3]
  44:	e9c7 2302 	strd	r2, r3, [r7, #8]
   long double lC = 3.99L;
  48:	a323      	add	r3, pc, #140	; (adr r3, d8 <initializationOfVariables+0xd8>)
  4a:	e9d3 2300 	ldrd	r2, r3, [r3]
  4e:	e9c7 2300 	strd	r2, r3, [r7]


   i = c + 1;
  52:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  56:	3301      	adds	r3, #1
  58:	62fb      	str	r3, [r7, #44]	; 0x2c
   i = s + 1;
  5a:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
  5e:	3301      	adds	r3, #1
  60:	62fb      	str	r3, [r7, #44]	; 0x2c
   i = i + 1;
  62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  64:	3301      	adds	r3, #1
  66:	62fb      	str	r3, [r7, #44]	; 0x2c

   i = uc + 1;
  68:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
  6c:	3301      	adds	r3, #1
  6e:	62fb      	str	r3, [r7, #44]	; 0x2c
   i = us + 1;
  70:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  72:	3301      	adds	r3, #1
  74:	62fb      	str	r3, [r7, #44]	; 0x2c
   i = ui + 1;
  76:	6abb      	ldr	r3, [r7, #40]	; 0x28
  78:	3301      	adds	r3, #1
  7a:	62fb      	str	r3, [r7, #44]	; 0x2c

   fA = fA + i;
  7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  7e:	ee07 3a90 	vmov	s15, r3
  82:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  86:	ed97 7a05 	vldr	s14, [r7, #20]
  8a:	ee77 7a27 	vadd.f32	s15, s14, s15
  8e:	edc7 7a05 	vstr	s15, [r7, #20]
   dB = dB + 1.99;
  92:	a313      	add	r3, pc, #76	; (adr r3, e0 <initializationOfVariables+0xe0>)
  94:	e9d3 2300 	ldrd	r2, r3, [r3]
  98:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
  9c:	f7ff fffe 	bl	0 <__aeabi_dadd>
  a0:	4602      	mov	r2, r0
  a2:	460b      	mov	r3, r1
  a4:	e9c7 2302 	strd	r2, r3, [r7, #8]
   lC = fA + dB;
  a8:	6978      	ldr	r0, [r7, #20]
  aa:	f7ff fffe 	bl	0 <__aeabi_f2d>
  ae:	4602      	mov	r2, r0
  b0:	460b      	mov	r3, r1
  b2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
  b6:	f7ff fffe 	bl	0 <__aeabi_dadd>
  ba:	4602      	mov	r2, r0
  bc:	460b      	mov	r3, r1
  be:	e9c7 2300 	strd	r2, r3, [r7]

}//initializationOfVariables
  c2:	bf00      	nop
  c4:	3738      	adds	r7, #56	; 0x38
  c6:	46bd      	mov	sp, r7
  c8:	bd80      	pop	{r7, pc}
  ca:	bf00      	nop
  cc:	f3af 8000 	nop.w
  d0:	1eb851ec 	.word	0x1eb851ec
  d4:	4007eb85 	.word	0x4007eb85
  d8:	1eb851ec 	.word	0x1eb851ec
  dc:	400feb85 	.word	0x400feb85
  e0:	3d70a3d7 	.word	0x3d70a3d7
  e4:	3fffd70a 	.word	0x3fffd70a
  e8:	3ffeb852 	.word	0x3ffeb852

Disassembly of section .text.initializationOfArrays:

00000000 <initializationOfArrays>:

//-----------------------------------------------------------------------------

void initializationOfArrays( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b0ab      	sub	sp, #172	; 0xac
   4:	af00      	add	r7, sp, #0

   // see disassembly
   char carA[ 5 ] = "ABCD";
   6:	4a3c      	ldr	r2, [pc, #240]	; (f8 <initializationOfArrays+0xf8>)
   8:	f107 0380 	add.w	r3, r7, #128	; 0x80
   c:	e892 0003 	ldmia.w	r2, {r0, r1}
  10:	6018      	str	r0, [r3, #0]
  12:	3304      	adds	r3, #4
  14:	7019      	strb	r1, [r3, #0]
   char carB[ 5 ] = {'A','B','C','D', 0 };
  16:	4a38      	ldr	r2, [pc, #224]	; (f8 <initializationOfArrays+0xf8>)
  18:	f107 0378 	add.w	r3, r7, #120	; 0x78
  1c:	e892 0003 	ldmia.w	r2, {r0, r1}
  20:	6018      	str	r0, [r3, #0]
  22:	3304      	adds	r3, #4
  24:	7019      	strb	r1, [r3, #0]
   char c         = '\0';
  26:	2300      	movs	r3, #0
  28:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7

   int iar[ 5 ] = { 65, 66, 67, 68, 69 };
  2c:	4b33      	ldr	r3, [pc, #204]	; (fc <initializationOfArrays+0xfc>)
  2e:	f107 0464 	add.w	r4, r7, #100	; 0x64
  32:	461d      	mov	r5, r3
  34:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  36:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  38:	682b      	ldr	r3, [r5, #0]
  3a:	6023      	str	r3, [r4, #0]
   int i        = 0;
  3c:	2300      	movs	r3, #0
  3e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

   float far[ 5 ] = { .1F, .2F, .3F, .4F, .5F };
  42:	4b2f      	ldr	r3, [pc, #188]	; (100 <initializationOfArrays+0x100>)
  44:	f107 0450 	add.w	r4, r7, #80	; 0x50
  48:	461d      	mov	r5, r3
  4a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  4c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  4e:	682b      	ldr	r3, [r5, #0]
  50:	6023      	str	r3, [r4, #0]
   float f        = .0F;
  52:	f04f 0300 	mov.w	r3, #0
  56:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

   double dar[ 5 ] = { .1, .2, .3, .4, .5 };
  5a:	4b2a      	ldr	r3, [pc, #168]	; (104 <initializationOfArrays+0x104>)
  5c:	f107 0428 	add.w	r4, r7, #40	; 0x28
  60:	461d      	mov	r5, r3
  62:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  64:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  66:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  68:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  6a:	e895 0003 	ldmia.w	r5, {r0, r1}
  6e:	e884 0003 	stmia.w	r4, {r0, r1}
   double d        = .0;
  72:	f04f 0200 	mov.w	r2, #0
  76:	f04f 0300 	mov.w	r3, #0
  7a:	e9c7 2324 	strd	r2, r3, [r7, #144]	; 0x90

   long double ldar[ 5 ] = { .1L, .2L, .3L, .4, .5L };
  7e:	4b21      	ldr	r3, [pc, #132]	; (104 <initializationOfArrays+0x104>)
  80:	463c      	mov	r4, r7
  82:	461d      	mov	r5, r3
  84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  8c:	e895 0003 	ldmia.w	r5, {r0, r1}
  90:	e884 0003 	stmia.w	r4, {r0, r1}
   long double ld        = .0L;
  94:	f04f 0200 	mov.w	r2, #0
  98:	f04f 0300 	mov.w	r3, #0
  9c:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88

   iar[ 0 ] = 66;
  a0:	2342      	movs	r3, #66	; 0x42
  a2:	667b      	str	r3, [r7, #100]	; 0x64
   i = iar[ 0 ];
  a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  a6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

   carA[ 0 ] = 97;
  aa:	2361      	movs	r3, #97	; 0x61
  ac:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
   c = carA[0];
  b0:	f897 3080 	ldrb.w	r3, [r7, #128]	; 0x80
  b4:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7

   far[ 0 ] = .2F;
  b8:	4b13      	ldr	r3, [pc, #76]	; (108 <initializationOfArrays+0x108>)
  ba:	653b      	str	r3, [r7, #80]	; 0x50
   f = far[ 0 ];
  bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  be:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

   dar[ 0 ] = .2;
  c2:	a30b      	add	r3, pc, #44	; (adr r3, f0 <initializationOfArrays+0xf0>)
  c4:	e9d3 2300 	ldrd	r2, r3, [r3]
  c8:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   d = dar[ 0 ];
  cc:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
  d0:	e9c7 2324 	strd	r2, r3, [r7, #144]	; 0x90

   ldar[ 0 ] = .2L;
  d4:	a306      	add	r3, pc, #24	; (adr r3, f0 <initializationOfArrays+0xf0>)
  d6:	e9d3 2300 	ldrd	r2, r3, [r3]
  da:	e9c7 2300 	strd	r2, r3, [r7]
   ld = dar[ 0 ];
  de:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
  e2:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88

}//initializationOfArrays
  e6:	bf00      	nop
  e8:	37ac      	adds	r7, #172	; 0xac
  ea:	46bd      	mov	sp, r7
  ec:	bcb0      	pop	{r4, r5, r7}
  ee:	4770      	bx	lr
  f0:	9999999a 	.word	0x9999999a
  f4:	3fc99999 	.word	0x3fc99999
  f8:	000002d8 	.word	0x000002d8
  fc:	000002e0 	.word	0x000002e0
 100:	000002f4 	.word	0x000002f4
 104:	00000070 	.word	0x00000070
 108:	3e4ccccd 	.word	0x3e4ccccd

Disassembly of section .text.f:

00000000 <f>:

//-----------------------------------------------------------------------------

int f( void ) { return 3; }
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
   4:	2303      	movs	r3, #3
   6:	4618      	mov	r0, r3
   8:	46bd      	mov	sp, r7
   a:	f85d 7b04 	ldr.w	r7, [sp], #4
   e:	4770      	bx	lr

Disassembly of section .text.expressionEvaluationOrder:

00000000 <expressionEvaluationOrder>:

void expressionEvaluationOrder( void ) {
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0

	// see disassembly
	int a = 0;
   6:	2300      	movs	r3, #0
   8:	60fb      	str	r3, [r7, #12]
	int b = 0;
   a:	2300      	movs	r3, #0
   c:	60bb      	str	r3, [r7, #8]
	int c = 1;
   e:	2301      	movs	r3, #1
  10:	607b      	str	r3, [r7, #4]

	// ! : not a 1.99 double
	float fA = 0.0F;
  12:	f04f 0300 	mov.w	r3, #0
  16:	603b      	str	r3, [r7, #0]
	fA = 1,99;
  18:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  1c:	603b      	str	r3, [r7, #0]
	(fA = 1) , 99;
  1e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  22:	603b      	str	r3, [r7, #0]

	a & b || c;
  24:	68fa      	ldr	r2, [r7, #12]
  26:	68bb      	ldr	r3, [r7, #8]
  28:	4013      	ands	r3, r2
  2a:	2b00      	cmp	r3, #0
  2c:	d101      	bne.n	32 <expressionEvaluationOrder+0x32>
  2e:	687b      	ldr	r3, [r7, #4]
  30:	2b00      	cmp	r3, #0

	a && b || c--;
  32:	68fb      	ldr	r3, [r7, #12]
  34:	2b00      	cmp	r3, #0
  36:	d002      	beq.n	3e <expressionEvaluationOrder+0x3e>
  38:	68bb      	ldr	r3, [r7, #8]
  3a:	2b00      	cmp	r3, #0
  3c:	d103      	bne.n	46 <expressionEvaluationOrder+0x46>
  3e:	687b      	ldr	r3, [r7, #4]
  40:	1e5a      	subs	r2, r3, #1
  42:	607a      	str	r2, [r7, #4]
  44:	2b00      	cmp	r3, #0
  46:	bf00      	nop
	1 + ( (2 * 2) * 4 );

	( 1 + 2 ) * 2 * 4;
	( (1 + 2) * 2 ) * 4;

	1 + 4, c = 2 | 3 + 5;
  48:	230a      	movs	r3, #10
  4a:	607b      	str	r3, [r7, #4]
	( 1 + 4 ), ( c = ( 2 | ( 3 + 5 ) ) );
  4c:	230a      	movs	r3, #10
  4e:	607b      	str	r3, [r7, #4]
	(1 + 5) & (4 == 3);

	// series of constant expressions
	3 , 4 , 5;

	!a++ + ~f();
  50:	68fb      	ldr	r3, [r7, #12]
  52:	1c5a      	adds	r2, r3, #1
  54:	60fa      	str	r2, [r7, #12]
  56:	2b00      	cmp	r3, #0
  58:	f7ff fffe 	bl	0 <expressionEvaluationOrder>
	( !(a++) ) + ( ~(f()) );
  5c:	68fb      	ldr	r3, [r7, #12]
  5e:	1c5a      	adds	r2, r3, #1
  60:	60fa      	str	r2, [r7, #12]
  62:	2b00      	cmp	r3, #0
  64:	f7ff fffe 	bl	0 <expressionEvaluationOrder>


}//expressionEvaluationOrder
  68:	bf00      	nop
  6a:	3710      	adds	r7, #16
  6c:	46bd      	mov	sp, r7
  6e:	bd80      	pop	{r7, pc}

Disassembly of section .text.sequentialEvaluation:

00000000 <sequentialEvaluation>:

int sequentialEvaluation( void ) {
   0:	b4b0      	push	{r4, r5, r7}
   2:	b08d      	sub	sp, #52	; 0x34
   4:	af00      	add	r7, sp, #0
	// , comma / sequence operator
    // binary operator.
	// Left associative
	// eval first operand than discard it

	int values[2][3] = {
   6:	4b23      	ldr	r3, [pc, #140]	; (94 <sequentialEvaluation+0x94>)
   8:	463c      	mov	r4, r7
   a:	461d      	mov	r5, r3
   c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  10:	e895 0003 	ldmia.w	r5, {r0, r1}
  14:	e884 0003 	stmia.w	r4, {r0, r1}
		{0,10,22} , {0,11,22}
	} ;


	int a=1, b=2, c=3, i=0; // commas act as separators in this line, not as an operator
  18:	2301      	movs	r3, #1
  1a:	62fb      	str	r3, [r7, #44]	; 0x2c
  1c:	2302      	movs	r3, #2
  1e:	623b      	str	r3, [r7, #32]
  20:	2303      	movs	r3, #3
  22:	61fb      	str	r3, [r7, #28]
  24:	2300      	movs	r3, #0
  26:	61bb      	str	r3, [r7, #24]

	i = (a, b);             // stores b into i
  28:	6a3b      	ldr	r3, [r7, #32]
  2a:	61bb      	str	r3, [r7, #24]

	i = a, b;               // stores a into i. Equivalent to (i = a), b;
  2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2e:	61bb      	str	r3, [r7, #24]
	                        // ... a=1, b=2, c=3, i=1
	i = (a += 2, a + b);    // increases a by 2, then stores a+b = 3+2 into i
  30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  32:	3302      	adds	r3, #2
  34:	62fb      	str	r3, [r7, #44]	; 0x2c
  36:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  38:	6a3b      	ldr	r3, [r7, #32]
  3a:	4413      	add	r3, r2
  3c:	61bb      	str	r3, [r7, #24]

	i = a += 2, a + b;      // increases a by 2, then stores a to i, and discards unused
  3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40:	3302      	adds	r3, #2
  42:	62fb      	str	r3, [r7, #44]	; 0x2c
  44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  46:	61bb      	str	r3, [r7, #24]

	i = a, b, c;            // stores a into i, discarding the unused b and c rvalues
  48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4a:	61bb      	str	r3, [r7, #24]

	i = (a, b, c);          // stores c into i, discarding the unused a and b rvalues
  4c:	69fb      	ldr	r3, [r7, #28]
  4e:	61bb      	str	r3, [r7, #24]


	values[0,1];             // ! not the same thing as values[0][1] : discards 0, use 1 as index
    values[1,1];             // ! not the same thing as values[1][1] : discards left 1, use riht 1 as index

	while ( a > 0, a-- );
  50:	bf00      	nop
  52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  54:	1e5a      	subs	r2, r3, #1
  56:	62fa      	str	r2, [r7, #44]	; 0x2c
  58:	2b00      	cmp	r3, #0
  5a:	d1fa      	bne.n	52 <sequentialEvaluation+0x52>

	for ( int j = 0, k = 10; j < k; j++, k-- );
  5c:	2300      	movs	r3, #0
  5e:	62bb      	str	r3, [r7, #40]	; 0x28
  60:	230a      	movs	r3, #10
  62:	627b      	str	r3, [r7, #36]	; 0x24
  64:	e005      	b.n	72 <sequentialEvaluation+0x72>
  66:	6abb      	ldr	r3, [r7, #40]	; 0x28
  68:	3301      	adds	r3, #1
  6a:	62bb      	str	r3, [r7, #40]	; 0x28
  6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  6e:	3b01      	subs	r3, #1
  70:	627b      	str	r3, [r7, #36]	; 0x24
  72:	6aba      	ldr	r2, [r7, #40]	; 0x28
  74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  76:	429a      	cmp	r2, r3
  78:	dbf5      	blt.n	66 <sequentialEvaluation+0x66>


	return a=4, b=5, c=6;   // returns 6, not 4,
  7a:	2304      	movs	r3, #4
  7c:	62fb      	str	r3, [r7, #44]	; 0x2c
  7e:	2305      	movs	r3, #5
  80:	623b      	str	r3, [r7, #32]
  82:	2306      	movs	r3, #6
  84:	61fb      	str	r3, [r7, #28]
  86:	69fb      	ldr	r3, [r7, #28]

	return 1, 2, 3;         // returns 3, not 1,

	return (1), 2, 3;        // returns 3, not 1,

}//sequentialEvaluation
  88:	4618      	mov	r0, r3
  8a:	3734      	adds	r7, #52	; 0x34
  8c:	46bd      	mov	sp, r7
  8e:	bcb0      	pop	{r4, r5, r7}
  90:	4770      	bx	lr
  92:	bf00      	nop
  94:	00000308 	.word	0x00000308

Disassembly of section .text.structs_asParameterAndReturnValue:

00000000 <structs_asParameterAndReturnValue>:
	int heigthAsCm;
	float weigthAsKg;
};


struct PointX structs_asParameterAndReturnValue( struct PointX point ) {
   0:	b082      	sub	sp, #8
   2:	b4b0      	push	{r4, r5, r7}
   4:	b083      	sub	sp, #12
   6:	af00      	add	r7, sp, #0
   8:	6078      	str	r0, [r7, #4]
   a:	f107 0118 	add.w	r1, r7, #24
   e:	e881 000c 	stmia.w	r1, {r2, r3}

	return *(point.pNext);
  12:	6abb      	ldr	r3, [r7, #40]	; 0x28
  14:	687a      	ldr	r2, [r7, #4]
  16:	4614      	mov	r4, r2
  18:	461d      	mov	r5, r3
  1a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  1c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1e:	e895 0003 	ldmia.w	r5, {r0, r1}
  22:	e884 0003 	stmia.w	r4, {r0, r1}

}//structs_asParameterAndReturnValue
  26:	6878      	ldr	r0, [r7, #4]
  28:	370c      	adds	r7, #12
  2a:	46bd      	mov	sp, r7
  2c:	bcb0      	pop	{r4, r5, r7}
  2e:	b002      	add	sp, #8
  30:	4770      	bx	lr

Disassembly of section .text.structs:

00000000 <structs>:

// TODO : struct flexible array member C99

void structs( void ) {
   0:	b490      	push	{r4, r7}
   2:	b0a0      	sub	sp, #128	; 0x80
   4:	af00      	add	r7, sp, #0

	struct { char C; int I; double D; } mixA;
	mixA.C = 'a';
   6:	2361      	movs	r3, #97	; 0x61
   8:	f887 3068 	strb.w	r3, [r7, #104]	; 0x68
	mixA.I = 3;
   c:	2303      	movs	r3, #3
   e:	66fb      	str	r3, [r7, #108]	; 0x6c
	mixA.D = 1.618;
  10:	a34e      	add	r3, pc, #312	; (adr r3, 14c <structs+0x14c>)
  12:	e9d3 2300 	ldrd	r2, r3, [r3]
  16:	e9c7 231c 	strd	r2, r3, [r7, #112]	; 0x70

	// mixB's type is different than mixA's type although they are looking the same
	struct { char C; int I; double D; } mixB = { 'a', 3, 1.618 };
  1a:	4b3f      	ldr	r3, [pc, #252]	; (118 <structs+0x118>)
  1c:	f107 0458 	add.w	r4, r7, #88	; 0x58
  20:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  22:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}


	// mixA = mixB; // error : incompatible types struct<anonymous>

	PointF.fX = .01F;
  26:	4b3d      	ldr	r3, [pc, #244]	; (11c <structs+0x11c>)
  28:	4a3d      	ldr	r2, [pc, #244]	; (120 <structs+0x120>)
  2a:	601a      	str	r2, [r3, #0]
	PointF.fX = .02F;
  2c:	4b3b      	ldr	r3, [pc, #236]	; (11c <structs+0x11c>)
  2e:	4a3d      	ldr	r2, [pc, #244]	; (124 <structs+0x124>)
  30:	601a      	str	r2, [r3, #0]

	Point pointA = { 2, 3 };
  32:	4a3d      	ldr	r2, [pc, #244]	; (128 <structs+0x128>)
  34:	f107 0350 	add.w	r3, r7, #80	; 0x50
  38:	e892 0003 	ldmia.w	r2, {r0, r1}
  3c:	e883 0003 	stmia.w	r3, {r0, r1}
	Point pointB = { .X = 2, .Y = 3 };
  40:	4a39      	ldr	r2, [pc, #228]	; (128 <structs+0x128>)
  42:	f107 0348 	add.w	r3, r7, #72	; 0x48
  46:	e892 0003 	ldmia.w	r2, {r0, r1}
  4a:	e883 0003 	stmia.w	r3, {r0, r1}
	Point pointC = { .Y = 4 }; // initializes .X with zero
  4e:	f107 0340 	add.w	r3, r7, #64	; 0x40
  52:	2200      	movs	r2, #0
  54:	601a      	str	r2, [r3, #0]
  56:	605a      	str	r2, [r3, #4]
  58:	2304      	movs	r3, #4
  5a:	647b      	str	r3, [r7, #68]	; 0x44

	// pointA = { 4,5 }         // error
	pointA = (Point){ 4, 5 };  // ok : "compound literal" assignment
  5c:	4a33      	ldr	r2, [pc, #204]	; (12c <structs+0x12c>)
  5e:	f107 0350 	add.w	r3, r7, #80	; 0x50
  62:	e892 0003 	ldmia.w	r2, {r0, r1}
  66:	e883 0003 	stmia.w	r3, {r0, r1}

	// !!
	pointA = (Point){ .Y = 6 }; // !! overrides .X with zero
  6a:	f107 0350 	add.w	r3, r7, #80	; 0x50
  6e:	2200      	movs	r2, #0
  70:	601a      	str	r2, [r3, #0]
  72:	605a      	str	r2, [r3, #4]
  74:	2306      	movs	r3, #6
  76:	657b      	str	r3, [r7, #84]	; 0x54

	//
	pointA = pointB;
  78:	f107 0350 	add.w	r3, r7, #80	; 0x50
  7c:	f107 0248 	add.w	r2, r7, #72	; 0x48
  80:	e892 0003 	ldmia.w	r2, {r0, r1}
  84:	e883 0003 	stmia.w	r3, {r0, r1}

	// PointF
    PointF.fY = .1F;
  88:	4b24      	ldr	r3, [pc, #144]	; (11c <structs+0x11c>)
  8a:	4a29      	ldr	r2, [pc, #164]	; (130 <structs+0x130>)
  8c:	605a      	str	r2, [r3, #4]
    PointF.fY = .2F;
  8e:	4b23      	ldr	r3, [pc, #140]	; (11c <structs+0x11c>)
  90:	4a28      	ldr	r2, [pc, #160]	; (134 <structs+0x134>)
  92:	605a      	str	r2, [r3, #4]

    //global points
    g_pointA.X = 1;
  94:	4b28      	ldr	r3, [pc, #160]	; (138 <structs+0x138>)
  96:	2201      	movs	r2, #1
  98:	601a      	str	r2, [r3, #0]
    g_pointA.Y = 2;
  9a:	4b27      	ldr	r3, [pc, #156]	; (138 <structs+0x138>)
  9c:	2202      	movs	r2, #2
  9e:	605a      	str	r2, [r3, #4]

    g_pointB.X = 10;
  a0:	4b26      	ldr	r3, [pc, #152]	; (13c <structs+0x13c>)
  a2:	220a      	movs	r2, #10
  a4:	601a      	str	r2, [r3, #0]
    g_pointB.Y = 20;
  a6:	4b25      	ldr	r3, [pc, #148]	; (13c <structs+0x13c>)
  a8:	2214      	movs	r2, #20
  aa:	605a      	str	r2, [r3, #4]

    g_pointC.X = 100;
  ac:	4b24      	ldr	r3, [pc, #144]	; (140 <structs+0x140>)
  ae:	2264      	movs	r2, #100	; 0x64
  b0:	601a      	str	r2, [r3, #0]
    g_pointC.Y = 200;
  b2:	4b23      	ldr	r3, [pc, #140]	; (140 <structs+0x140>)
  b4:	22c8      	movs	r2, #200	; 0xc8
  b6:	605a      	str	r2, [r3, #4]

    // assigment (copy)
    g_pointA = g_pointB;
  b8:	4b1f      	ldr	r3, [pc, #124]	; (138 <structs+0x138>)
  ba:	4a20      	ldr	r2, [pc, #128]	; (13c <structs+0x13c>)
  bc:	e892 0003 	ldmia.w	r2, {r0, r1}
  c0:	e883 0003 	stmia.w	r3, {r0, r1}

    // struct member referencing
    g_pointer = &g_pointC;
  c4:	4b1f      	ldr	r3, [pc, #124]	; (144 <structs+0x144>)
  c6:	4a1e      	ldr	r2, [pc, #120]	; (140 <structs+0x140>)
  c8:	601a      	str	r2, [r3, #0]
    (*g_pointer).X = 22;
  ca:	4b1e      	ldr	r3, [pc, #120]	; (144 <structs+0x144>)
  cc:	681b      	ldr	r3, [r3, #0]
  ce:	2216      	movs	r2, #22
  d0:	601a      	str	r2, [r3, #0]
    (*g_pointer).Y = 33;
  d2:	4b1c      	ldr	r3, [pc, #112]	; (144 <structs+0x144>)
  d4:	681b      	ldr	r3, [r3, #0]
  d6:	2221      	movs	r2, #33	; 0x21
  d8:	605a      	str	r2, [r3, #4]

    // member dereferencing operator
    g_pointer->X = 44;
  da:	4b1a      	ldr	r3, [pc, #104]	; (144 <structs+0x144>)
  dc:	681b      	ldr	r3, [r3, #0]
  de:	222c      	movs	r2, #44	; 0x2c
  e0:	601a      	str	r2, [r3, #0]
    g_pointer->Y = 55;
  e2:	4b18      	ldr	r3, [pc, #96]	; (144 <structs+0x144>)
  e4:	681b      	ldr	r3, [r3, #0]
  e6:	2237      	movs	r2, #55	; 0x37
  e8:	605a      	str	r2, [r3, #4]

    struct PointD pointD1;
    struct PointD pointD2 = { .1, .2 };
  ea:	4b17      	ldr	r3, [pc, #92]	; (148 <structs+0x148>)
  ec:	f107 0410 	add.w	r4, r7, #16
  f0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  f2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    //pointD1 = { .1, .2 };              // error
    //pointD1 = (PointD){ .1, .2 };      // error
    pointD1 = (struct PointD){ .1, .2 }; // ok : "compound literal" assignment
  f6:	4b14      	ldr	r3, [pc, #80]	; (148 <structs+0x148>)
  f8:	f107 0420 	add.w	r4, r7, #32
  fc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  fe:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	size_t position = 0;
 102:	2300      	movs	r3, #0
 104:	67fb      	str	r3, [r7, #124]	; 0x7c
	position = offsetof(  Point, Y );
 106:	2304      	movs	r3, #4
 108:	67fb      	str	r3, [r7, #124]	; 0x7c

}//structs
 10a:	bf00      	nop
 10c:	3780      	adds	r7, #128	; 0x80
 10e:	46bd      	mov	sp, r7
 110:	bc90      	pop	{r4, r7}
 112:	4770      	bx	lr
 114:	f3af 8000 	nop.w
 118:	00000320 	.word	0x00000320
 11c:	00000000 	.word	0x00000000
 120:	3c23d70a 	.word	0x3c23d70a
 124:	3ca3d70a 	.word	0x3ca3d70a
 128:	00000330 	.word	0x00000330
 12c:	00000338 	.word	0x00000338
 130:	3dcccccd 	.word	0x3dcccccd
 134:	3e4ccccd 	.word	0x3e4ccccd
	...
 148:	00000340 	.word	0x00000340
 14c:	f7ced917 	.word	0xf7ced917
 150:	3ff9e353 	.word	0x3ff9e353

Disassembly of section .text.structs_structArrays:

00000000 <structs_structArrays>:

//-----------------------------------------------------------------------------

void structs_structArrays( void ) {
   0:	b580      	push	{r7, lr}
   2:	b0b4      	sub	sp, #208	; 0xd0
   4:	af00      	add	r7, sp, #0

	// see disassembly
	struct TPerson people[ 3 ] = {
   6:	4a2d      	ldr	r2, [pc, #180]	; (bc <structs_structArrays+0xbc>)
   8:	1d3b      	adds	r3, r7, #4
   a:	4611      	mov	r1, r2
   c:	22c0      	movs	r2, #192	; 0xc0
   e:	4618      	mov	r0, r3
  10:	f7ff fffe 	bl	0 <memcpy>
		{ "ayhan", 160, 65.5F  },
		{ "beyhan", 150, 55.5F },
		{ "ceyhan", 170, 70.5F }
	};

	char *pc = NULL;
  14:	2300      	movs	r3, #0
  16:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	int  i   = 0;
  1a:	2300      	movs	r3, #0
  1c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	float f  = .0F;
  20:	f04f 0300 	mov.w	r3, #0
  24:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

	pc = people[ 0 ].name;
  28:	1d3b      	adds	r3, r7, #4
  2a:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
    i  = people[ 0 ].heigthAsCm;
  2e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  30:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	f  = people[ 0 ].weigthAsKg;
  34:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  36:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

	pc = people[ 1 ].name;
  3a:	1d3b      	adds	r3, r7, #4
  3c:	3340      	adds	r3, #64	; 0x40
  3e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
    i  = people[ 1 ].heigthAsCm;
  42:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  44:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	f  = people[ 1 ].weigthAsKg;
  48:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4c:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

	pc = people[ 2 ].name;
  50:	1d3b      	adds	r3, r7, #4
  52:	3380      	adds	r3, #128	; 0x80
  54:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
    i  = people[ 2 ].heigthAsCm;
  58:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
  5c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	f  = people[ 2 ].weigthAsKg;
  60:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
  64:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

	strcpy( people[ 0 ].name, "ayda" );
  68:	1d3b      	adds	r3, r7, #4
  6a:	4a15      	ldr	r2, [pc, #84]	; (c0 <structs_structArrays+0xc0>)
  6c:	e892 0003 	ldmia.w	r2, {r0, r1}
  70:	6018      	str	r0, [r3, #0]
  72:	3304      	adds	r3, #4
  74:	7019      	strb	r1, [r3, #0]
	people[ 0 ].heigthAsCm = 152;
  76:	2398      	movs	r3, #152	; 0x98
  78:	63fb      	str	r3, [r7, #60]	; 0x3c
	people[ 0 ].weigthAsKg = 67.5F;
  7a:	4b12      	ldr	r3, [pc, #72]	; (c4 <structs_structArrays+0xc4>)
  7c:	643b      	str	r3, [r7, #64]	; 0x40

	strcpy( people[ 1 ].name, "beyda" );
  7e:	1d3b      	adds	r3, r7, #4
  80:	3340      	adds	r3, #64	; 0x40
  82:	4a11      	ldr	r2, [pc, #68]	; (c8 <structs_structArrays+0xc8>)
  84:	e892 0003 	ldmia.w	r2, {r0, r1}
  88:	6018      	str	r0, [r3, #0]
  8a:	3304      	adds	r3, #4
  8c:	8019      	strh	r1, [r3, #0]
	people[ 1 ].heigthAsCm = 162;
  8e:	23a2      	movs	r3, #162	; 0xa2
  90:	67fb      	str	r3, [r7, #124]	; 0x7c
	people[ 1 ].weigthAsKg = 57.5F;
  92:	4b0e      	ldr	r3, [pc, #56]	; (cc <structs_structArrays+0xcc>)
  94:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

	strcpy( people[ 2 ].name, "ceyda" );
  98:	1d3b      	adds	r3, r7, #4
  9a:	3380      	adds	r3, #128	; 0x80
  9c:	4a0c      	ldr	r2, [pc, #48]	; (d0 <structs_structArrays+0xd0>)
  9e:	e892 0003 	ldmia.w	r2, {r0, r1}
  a2:	6018      	str	r0, [r3, #0]
  a4:	3304      	adds	r3, #4
  a6:	8019      	strh	r1, [r3, #0]
	people[ 2 ].heigthAsCm = 162;
  a8:	23a2      	movs	r3, #162	; 0xa2
  aa:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	people[ 2 ].weigthAsKg = 72.5F;
  ae:	4b09      	ldr	r3, [pc, #36]	; (d4 <structs_structArrays+0xd4>)
  b0:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

}//structs_structArrays
  b4:	bf00      	nop
  b6:	37d0      	adds	r7, #208	; 0xd0
  b8:	46bd      	mov	sp, r7
  ba:	bd80      	pop	{r7, pc}
  bc:	00000368 	.word	0x00000368
  c0:	00000350 	.word	0x00000350
  c4:	42870000 	.word	0x42870000
  c8:	00000358 	.word	0x00000358
  cc:	42660000 	.word	0x42660000
  d0:	00000360 	.word	0x00000360
  d4:	42910000 	.word	0x42910000

Disassembly of section .text.structs_flexibleArrayMember:

00000000 <structs_flexibleArrayMember>:
	unsigned int length;
	long double values[];

};

void structs_flexibleArrayMember( int measurementCount ) {
   0:	b580      	push	{r7, lr}
   2:	b086      	sub	sp, #24
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]

   // refer: https://en.wikipedia.org/wiki/Flexible_array_member

   struct TMeasurements* pMsr;

   size_t bytesAllocated = sizeof(struct TMeasurements) + measurementCount * sizeof(long double);
   8:	687b      	ldr	r3, [r7, #4]
   a:	3301      	adds	r3, #1
   c:	00db      	lsls	r3, r3, #3
   e:	613b      	str	r3, [r7, #16]
   pMsr = (struct TMeasurements*) malloc( bytesAllocated );
  10:	6938      	ldr	r0, [r7, #16]
  12:	f7ff fffe 	bl	0 <malloc>
  16:	4603      	mov	r3, r0
  18:	60fb      	str	r3, [r7, #12]
   pMsr->length = measurementCount;
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	68fb      	ldr	r3, [r7, #12]
  1e:	601a      	str	r2, [r3, #0]

   const int upperLimit = 10;
  20:	230a      	movs	r3, #10
  22:	60bb      	str	r3, [r7, #8]
   int loop = measurementCount;
  24:	687b      	ldr	r3, [r7, #4]
  26:	617b      	str	r3, [r7, #20]

   while ( loop-- )
  28:	e00e      	b.n	48 <structs_flexibleArrayMember+0x48>
	   pMsr->values[ loop ] = (long double)rand();
  2a:	f7ff fffe 	bl	0 <rand>
  2e:	4603      	mov	r3, r0
  30:	4618      	mov	r0, r3
  32:	f7ff fffe 	bl	0 <__aeabi_i2d>
  36:	4602      	mov	r2, r0
  38:	460b      	mov	r3, r1
  3a:	68f8      	ldr	r0, [r7, #12]
  3c:	6979      	ldr	r1, [r7, #20]
  3e:	3101      	adds	r1, #1
  40:	00c9      	lsls	r1, r1, #3
  42:	4401      	add	r1, r0
  44:	e9c1 2300 	strd	r2, r3, [r1]
   while ( loop-- )
  48:	697b      	ldr	r3, [r7, #20]
  4a:	1e5a      	subs	r2, r3, #1
  4c:	617a      	str	r2, [r7, #20]
  4e:	2b00      	cmp	r3, #0
  50:	d1eb      	bne.n	2a <structs_flexibleArrayMember+0x2a>

}//structs_flexibleArrayMember
  52:	bf00      	nop
  54:	bf00      	nop
  56:	3718      	adds	r7, #24
  58:	46bd      	mov	sp, r7
  5a:	bd80      	pop	{r7, pc}

Disassembly of section .text.memoryManagement_alloc_calloc_realloc_free:

00000000 <memoryManagement_alloc_calloc_realloc_free>:

//-----------------------------------------------------------------------------

void memoryManagement_alloc_calloc_realloc_free( void ) {
   0:	b5b0      	push	{r4, r5, r7, lr}
   2:	b086      	sub	sp, #24
   4:	af00      	add	r7, sp, #0

	char *textA = NULL;
   6:	2300      	movs	r3, #0
   8:	617b      	str	r3, [r7, #20]

	//textA = "lorem ipsum";// !! DON'T it's risky

	// returned memory block contains "garbage" values.
	textA = (char *) malloc( 12 );
   a:	200c      	movs	r0, #12
   c:	f7ff fffe 	bl	0 <malloc>
  10:	4603      	mov	r3, r0
  12:	617b      	str	r3, [r7, #20]
	if ( NULL == textA )
  14:	697b      	ldr	r3, [r7, #20]
  16:	2b00      	cmp	r3, #0
  18:	d034      	beq.n	84 <memoryManagement_alloc_calloc_realloc_free+0x84>
	   goto EXIT;

   strcpy( textA, "lorem ipsum" );
  1a:	697b      	ldr	r3, [r7, #20]
  1c:	4a23      	ldr	r2, [pc, #140]	; (ac <memoryManagement_alloc_calloc_realloc_free+0xac>)
  1e:	461c      	mov	r4, r3
  20:	4613      	mov	r3, r2
  22:	cb07      	ldmia	r3!, {r0, r1, r2}
  24:	6020      	str	r0, [r4, #0]
  26:	6061      	str	r1, [r4, #4]
  28:	60a2      	str	r2, [r4, #8]

	char *textB = NULL;
  2a:	2300      	movs	r3, #0
  2c:	613b      	str	r3, [r7, #16]

	// returned memory block contains "zeroed" values.
	textB = (char *) calloc( 16, 1 );
  2e:	2101      	movs	r1, #1
  30:	2010      	movs	r0, #16
  32:	f7ff fffe 	bl	0 <calloc>
  36:	4603      	mov	r3, r0
  38:	613b      	str	r3, [r7, #16]
	if ( NULL == textB )
  3a:	693b      	ldr	r3, [r7, #16]
  3c:	2b00      	cmp	r3, #0
  3e:	d023      	beq.n	88 <memoryManagement_alloc_calloc_realloc_free+0x88>
	   goto EXIT;

    strcpy( textB, " dolor sit amet" );
  40:	693b      	ldr	r3, [r7, #16]
  42:	4a1b      	ldr	r2, [pc, #108]	; (b0 <memoryManagement_alloc_calloc_realloc_free+0xb0>)
  44:	461c      	mov	r4, r3
  46:	4615      	mov	r5, r2
  48:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  4a:	6020      	str	r0, [r4, #0]
  4c:	6061      	str	r1, [r4, #4]
  4e:	60a2      	str	r2, [r4, #8]
  50:	60e3      	str	r3, [r4, #12]

	size_t sizeA = strlen( textA );
  52:	6978      	ldr	r0, [r7, #20]
  54:	f7ff fffe 	bl	0 <strlen>
  58:	60f8      	str	r0, [r7, #12]
	size_t sizeB = strlen( textB );
  5a:	6938      	ldr	r0, [r7, #16]
  5c:	f7ff fffe 	bl	0 <strlen>
  60:	60b8      	str	r0, [r7, #8]

	// after successful realloc, previously malloced-buffer passed as first argument
	// is no longer valid and should not be "freed()".
	void* newBlock = realloc( textA, sizeA + sizeB + 1 );
  62:	68fa      	ldr	r2, [r7, #12]
  64:	68bb      	ldr	r3, [r7, #8]
  66:	4413      	add	r3, r2
  68:	3301      	adds	r3, #1
  6a:	4619      	mov	r1, r3
  6c:	6978      	ldr	r0, [r7, #20]
  6e:	f7ff fffe 	bl	0 <realloc>
  72:	6078      	str	r0, [r7, #4]
   textA = newBlock ? (char*) newBlock : textA;
  74:	687b      	ldr	r3, [r7, #4]
  76:	2b00      	cmp	r3, #0
  78:	d001      	beq.n	7e <memoryManagement_alloc_calloc_realloc_free+0x7e>
  7a:	687b      	ldr	r3, [r7, #4]
  7c:	e000      	b.n	80 <memoryManagement_alloc_calloc_realloc_free+0x80>
  7e:	697b      	ldr	r3, [r7, #20]
  80:	617b      	str	r3, [r7, #20]
  82:	e002      	b.n	8a <memoryManagement_alloc_calloc_realloc_free+0x8a>
	   goto EXIT;
  84:	bf00      	nop
  86:	e000      	b.n	8a <memoryManagement_alloc_calloc_realloc_free+0x8a>
	   goto EXIT;
  88:	bf00      	nop

EXIT:
	textA ? 0 : free( textA );
  8a:	697b      	ldr	r3, [r7, #20]
  8c:	2b00      	cmp	r3, #0
  8e:	d102      	bne.n	96 <memoryManagement_alloc_calloc_realloc_free+0x96>
  90:	6978      	ldr	r0, [r7, #20]
  92:	f7ff fffe 	bl	0 <free>
	textB ? 0 : free( textB );
  96:	693b      	ldr	r3, [r7, #16]
  98:	2b00      	cmp	r3, #0
  9a:	d102      	bne.n	a2 <memoryManagement_alloc_calloc_realloc_free+0xa2>
  9c:	6938      	ldr	r0, [r7, #16]
  9e:	f7ff fffe 	bl	0 <free>

}//memoryManagement_alloc_calloc_realloc_free
  a2:	bf00      	nop
  a4:	3718      	adds	r7, #24
  a6:	46bd      	mov	sp, r7
  a8:	bdb0      	pop	{r4, r5, r7, pc}
  aa:	bf00      	nop
  ac:	00000428 	.word	0x00000428
  b0:	00000434 	.word	0x00000434

Disassembly of section .text.implicitFunDec:

00000000 <implicitFunDec>:
//-----------------------------------------------------------------------------

implicitlyTypedVariableA;
impTVB = 2;

implicitFunDec( value ) {
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]

   unsigned impTVC = 3;
   8:	2303      	movs	r3, #3
   a:	60fb      	str	r3, [r7, #12]

}//implicitFunDec
   c:	bf00      	nop
   e:	4618      	mov	r0, r3
  10:	3714      	adds	r7, #20
  12:	46bd      	mov	sp, r7
  14:	f85d 7b04 	ldr.w	r7, [sp], #4
  18:	4770      	bx	lr

Disassembly of section .text.main:

00000000 <main>:

//-----------------------------------------------------------------------------

int main( int argc, char** argv ) {
   0:	b580      	push	{r7, lr}
   2:	b092      	sub	sp, #72	; 0x48
   4:	af02      	add	r7, sp, #8
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
   
   //pathCombineTester();

   implicitFunDec( 2 );
   a:	2002      	movs	r0, #2
   c:	f7ff fffe 	bl	0 <main>

	pointers6();
  10:	f7ff fffe 	bl	0 <main>

	initializationOfArrays();
  14:	f7ff fffe 	bl	0 <main>

	pointers5();
  18:	f7ff fffe 	bl	0 <main>

	memoryManagement_alloc_calloc_realloc_free();
  1c:	f7ff fffe 	bl	0 <main>

	structs_flexibleArrayMember( 4 );
  20:	2004      	movs	r0, #4
  22:	f7ff fffe 	bl	0 <main>

	arrays_variableSize( 3 );
  26:	2003      	movs	r0, #3
  28:	f7ff fffe 	bl	0 <main>

	unions();
  2c:	f7ff fffe 	bl	0 <main>

	arrays_multiDimensionalJaggedvsFlat();
  30:	f7ff fffe 	bl	0 <main>
	arrays_multiDimensionalJagged();
  34:	f7ff fffe 	bl	0 <main>
	arrays_multiDimensional();
  38:	f7ff fffe 	bl	0 <main>

	long long int sum = 0;
  3c:	f04f 0200 	mov.w	r2, #0
  40:	f04f 0300 	mov.w	r3, #0
  44:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	sum = functions_sum( 3 , 2, 4, 6 );
  48:	2306      	movs	r3, #6
  4a:	2204      	movs	r2, #4
  4c:	2102      	movs	r1, #2
  4e:	2003      	movs	r0, #3
  50:	f7ff fffe 	bl	0 <main>
  54:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
	sum = functions_sum( 4 , 1, 3, 5, 7 );
  58:	2307      	movs	r3, #7
  5a:	9300      	str	r3, [sp, #0]
  5c:	2305      	movs	r3, #5
  5e:	2203      	movs	r2, #3
  60:	2101      	movs	r1, #1
  62:	2004      	movs	r0, #4
  64:	f7ff fffe 	bl	0 <main>
  68:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38


	long long int factorial = functions_recursiveFactorial( 5 );
  6c:	f04f 0005 	mov.w	r0, #5
  70:	f04f 0100 	mov.w	r1, #0
  74:	f7ff fffe 	bl	0 <main>
  78:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

	functions_recursiveFunction();
  7c:	f7ff fffe 	bl	0 <main>

	sinus( 120 );
  80:	2078      	movs	r0, #120	; 0x78
  82:	f7ff fffe 	bl	0 <main>

	arrays();
  86:	f7ff fffe 	bl	0 <main>

	structs();
  8a:	f7ff fffe 	bl	0 <main>

	literals();
  8e:	f7ff fffe 	bl	0 <main>

	operators_conditionalExpression();
  92:	f7ff fffe 	bl	0 <main>
	operators_additive();
  96:	f7ff fffe 	bl	0 <main>
	operators_multiplicative();
  9a:	f7ff fffe 	bl	0 <main>

	functionPointers();
  9e:	f7ff fffe 	bl	0 <main>

   everyIdentifierHasAnAddress();
  a2:	f7ff fffe 	bl	0 <main>

   arrays();
  a6:	f7ff fffe 	bl	0 <main>
   arrays_multiDimensional();
  aa:	f7ff fffe 	bl	0 <main>
	initializationOfVariables();
  ae:	f7ff fffe 	bl	0 <main>
	sequentialEvaluation();
  b2:	f7ff fffe 	bl	0 <main>
	bitManipulation();
  b6:	f7ff fffe 	bl	0 <main>

    int a = 1;
  ba:	2301      	movs	r3, #1
  bc:	61bb      	str	r3, [r7, #24]

    int x = 1;
  be:	2301      	movs	r3, #1
  c0:	62fb      	str	r3, [r7, #44]	; 0x2c
    int y = 1;
  c2:	2301      	movs	r3, #1
  c4:	62bb      	str	r3, [r7, #40]	; 0x28
	 int z = 0;
  c6:	2300      	movs	r3, #0
  c8:	627b      	str	r3, [r7, #36]	; 0x24


    // conditional evaluation of y
    x && y++;
  ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  cc:	2b00      	cmp	r3, #0
  ce:	d003      	beq.n	d8 <main+0xd8>
  d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  d2:	1c5a      	adds	r2, r3, #1
  d4:	62ba      	str	r2, [r7, #40]	; 0x28
  d6:	2b00      	cmp	r3, #0

    //x == 0 ? x += 1: x += 2;
    (x == 0) ? (x += 1) : (x += 2);
  d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  da:	2b00      	cmp	r3, #0
  dc:	d103      	bne.n	e6 <main+0xe6>
  de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  e0:	3301      	adds	r3, #1
  e2:	62fb      	str	r3, [r7, #44]	; 0x2c
  e4:	e002      	b.n	ec <main+0xec>
  e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  e8:	3302      	adds	r3, #2
  ea:	62fb      	str	r3, [r7, #44]	; 0x2c

	z = !a++;
  ec:	69bb      	ldr	r3, [r7, #24]
  ee:	1c5a      	adds	r2, r3, #1
  f0:	61ba      	str	r2, [r7, #24]
  f2:	2b00      	cmp	r3, #0
  f4:	bf0c      	ite	eq
  f6:	2301      	moveq	r3, #1
  f8:	2300      	movne	r3, #0
  fa:	b2db      	uxtb	r3, r3
  fc:	627b      	str	r3, [r7, #36]	; 0x24


	z = ( 0, 1, 2, 3 + 4 );
  fe:	2307      	movs	r3, #7
 100:	627b      	str	r3, [r7, #36]	; 0x24

	z = 0;
 102:	2300      	movs	r3, #0
 104:	627b      	str	r3, [r7, #36]	; 0x24
	a = 0;
 106:	2300      	movs	r3, #0
 108:	61bb      	str	r3, [r7, #24]

	z = !(a++);
 10a:	69bb      	ldr	r3, [r7, #24]
 10c:	1c5a      	adds	r2, r3, #1
 10e:	61ba      	str	r2, [r7, #24]
 110:	2b00      	cmp	r3, #0
 112:	bf0c      	ite	eq
 114:	2301      	moveq	r3, #1
 116:	2300      	movne	r3, #0
 118:	b2db      	uxtb	r3, r3
 11a:	627b      	str	r3, [r7, #36]	; 0x24

	division();
 11c:	f7ff fffe 	bl	0 <main>

	typePromotionPromoteToInt();
 120:	f7ff fffe 	bl	0 <main>

	// precedence of post increment
   int i[] = {3, 5};
 124:	4a15      	ldr	r2, [pc, #84]	; (17c <main+0x17c>)
 126:	f107 0310 	add.w	r3, r7, #16
 12a:	e892 0003 	ldmia.w	r2, {r0, r1}
 12e:	e883 0003 	stmia.w	r3, {r0, r1}
   int *p = i;
 132:	f107 0310 	add.w	r3, r7, #16
 136:	623b      	str	r3, [r7, #32]
   int j = --*p++;
 138:	6a3b      	ldr	r3, [r7, #32]
 13a:	1d1a      	adds	r2, r3, #4
 13c:	623a      	str	r2, [r7, #32]
 13e:	681a      	ldr	r2, [r3, #0]
 140:	3a01      	subs	r2, #1
 142:	601a      	str	r2, [r3, #0]
 144:	681b      	ldr	r3, [r3, #0]
 146:	61fb      	str	r3, [r7, #28]

	typePromotion();
 148:	f7ff fffe 	bl	0 <main>
	modulus();
 14c:	f7ff fffe 	bl	0 <main>
	//SameWidthTypePromotion();


	expressionEvaluationOrder();
 150:	f7ff fffe 	bl	0 <main>

	literals();
 154:	f7ff fffe 	bl	0 <main>

   bitFields();
 158:	f7ff fffe 	bl	0 <main>


	int b = 5;
 15c:	2305      	movs	r3, #5
 15e:	60fb      	str	r3, [r7, #12]
	swap( &a, &b );
 160:	f107 020c 	add.w	r2, r7, #12
 164:	f107 0318 	add.w	r3, r7, #24
 168:	4611      	mov	r1, r2
 16a:	4618      	mov	r0, r3
 16c:	f7ff fffe 	bl	0 <main>

	return EXIT_SUCCESS;
 170:	2300      	movs	r3, #0

}//main
 172:	4618      	mov	r0, r3
 174:	3740      	adds	r7, #64	; 0x40
 176:	46bd      	mov	sp, r7
 178:	bd80      	pop	{r7, pc}
 17a:	bf00      	nop
 17c:	00000444 	.word	0x00000444
